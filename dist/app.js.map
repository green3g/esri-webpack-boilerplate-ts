{"version":3,"sources":["webpack:///webpack/bootstrap 32d34e2d31ef227d8650","webpack:///./~/can-types/can-types.js","webpack:///./~/can-util/js/each/each.js","webpack:///./~/can-namespace/can-namespace.js","webpack:///./~/can-util/js/assign/assign.js","webpack:///./~/can-event/can-event.js","webpack:///./~/can-util/dom/document/document.js","webpack:///./~/can-util/js/dev/dev.js","webpack:///./~/can-observation/can-observation.js","webpack:///./~/can-util/dom/events/events.js","webpack:///./~/can-compute/can-compute.js","webpack:///./~/can-util/dom/data/data.js","webpack:///./~/can-event/batch/batch.js","webpack:///./~/can-util/js/make-array/make-array.js","webpack:///./~/can-util/js/global/global.js","webpack:///./~/can-cid/can-cid.js","webpack:///./~/can-observation/reader/reader.js","webpack:///./~/can-util/dom/child-nodes/child-nodes.js","webpack:///./~/can-util/dom/dispatch/dispatch.js","webpack:///./~/can-util/js/log/log.js","webpack:///./~/can-util/js/string/string.js","webpack:///./~/can-view-nodelist/can-view-nodelist.js","webpack:///./~/can-util/dom/mutation-observer/mutation-observer.js","webpack:///./~/can-util/js/is-empty-object/is-empty-object.js","webpack:///./~/can-util/js/is-function/is-function.js","webpack:///./~/can-util/dom/attr/attr.js","webpack:///./~/can-view-live/lib/core.js","webpack:///config/versionTemplate.txt","webpack:///lib/es6-promise/utils.js","webpack:///lib/es6-promise/asap.js","webpack:///lib/es6-promise/then.js","webpack:///lib/es6-promise/promise/resolve.js","webpack:///lib/es6-promise/-internal.js","webpack:///lib/es6-promise/enumerator.js","webpack:///lib/es6-promise/promise/all.js","webpack:///lib/es6-promise/promise/race.js","webpack:///lib/es6-promise/promise/reject.js","webpack:///lib/es6-promise/promise.js","webpack:///lib/es6-promise/polyfill.js","webpack:///lib/es6-promise.js","webpack:///./~/can-construct/can-construct.js","webpack:///./~/can-stache/src/mustache_core.js","webpack:///./~/can-stache/src/utils.js","webpack:///./~/can-util/dom/mutate/mutate.js","webpack:///./~/can-util/js/is-array/is-array.js","webpack:///./~/can-util/js/last/last.js","webpack:///./~/esri-promise/index.ts","webpack:///./~/can-stache/can-stache.js","webpack:///./~/can-stache/helpers/core.js","webpack:///./~/can-util/dom/frag/frag.js","webpack:///./~/can-util/js/cid/get-cid.js","webpack:///./~/can-util/js/is-array-like/is-array-like.js","webpack:///./~/can-util/js/is-plain-object/is-plain-object.js","webpack:///./~/can-view-callbacks/can-view-callbacks.js","webpack:///./~/can-view-live/can-view-live.js","webpack:///./~/can-view-scope/can-view-scope.js","webpack:///./~/can-define/can-define.js","webpack:///./~/can-define/map/map.js","webpack:///./~/can-stache/src/expression.js","webpack:///./~/can-stache/src/intermediate_and_imports.js","webpack:///./~/can-util/dom/data/core.js","webpack:///./~/can-util/dom/events/removed/removed.js","webpack:///./~/can-util/dom/is-of-global-document/is-of-global-document.js","webpack:///./~/can-util/js/cid-map/cid-map.js","webpack:///./~/can-util/js/diff/diff.js","webpack:///./~/can-util/js/get/get.js","webpack:///./~/can-util/js/set-immediate/set-immediate.js","webpack:///./~/can-view-parser/can-view-parser.js","webpack:///./~/process/browser.js","webpack:///./~/can-define/define-helpers/define-helpers.js","webpack:///./~/can-define/list/list.js","webpack:///./~/can-event/lifecycle/lifecycle.js","webpack:///./~/can-simple-map/can-simple-map.js","webpack:///./~/can-util/dom/contains/contains.js","webpack:///./~/can-util/dom/events/delegate/delegate.js","webpack:///./~/can-util/dom/events/inserted/inserted.js","webpack:///./~/can-util/dom/events/make-mutation-event/make-mutation-event.js","webpack:///./~/can-util/dom/mutation-observer/document/document.js","webpack:///./~/can-util/js/is-container/is-container.js","webpack:///./~/can-util/js/is-iterable/is-iterable.js","webpack:///./~/can-view-model/can-view-model.js","webpack:///./~/can-view-target/can-view-target.js","webpack:///./~/spectre-canjs/util/field/Field.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/ts/app.ts","webpack:///./src/ts/application/application.ts","webpack:///./src/ts/boilerplate/ItemHelper.ts","webpack:///./src/ts/boilerplate/UrlParamHelper.ts","webpack:///./src/ts/boilerplate/boilerplate.ts","webpack:///./~/spectre-canjs/property-table/property-table.stache","webpack:///./src/ts/template.stache","webpack:///./src/css/index.scss","webpack:///./~/can-component/can-component.js","webpack:///./~/can-component/control/control.js","webpack:///./~/can-compute/proto-compute.js","webpack:///./~/can-control/can-control.js","webpack:///./~/can-event-radiochange/can-event-radiochange.js","webpack:///./~/can-event-radiochange/override.js","webpack:///./~/can-stache-bindings/can-stache-bindings.js","webpack:///./~/can-stache/helpers/converter.js","webpack:///./~/can-stache/src/html_section.js","webpack:///./~/can-stache/src/text_section.js","webpack:///./~/can-util/dom/class-name/class-name.js","webpack:///./~/can-util/dom/events/attributes/attributes.js","webpack:///./~/can-util/dom/events/delegate/enter-leave.js","webpack:///./~/can-util/dom/fragment/fragment.js","webpack:///./~/can-util/dom/matches/matches.js","webpack:///./~/can-util/js/base-url/base-url.js","webpack:///./~/can-util/js/cid-set/cid-set.js","webpack:///./~/can-util/js/deep-assign/deep-assign.js","webpack:///./~/can-util/js/defaults/defaults.js","webpack:///./~/can-util/js/import/import.js","webpack:///./~/can-util/js/is-browser-window/is-browser-window.js","webpack:///./~/can-util/js/is-promise-like/is-promise-like.js","webpack:///./~/can-util/js/join-uris/join-uris.js","webpack:///./~/can-util/js/parse-uri/parse-uri.js","webpack:///./~/can-util/js/single-reference/single-reference.js","webpack:///./~/can-util/js/string-to-any/string-to-any.js","webpack:///./~/can-view-live/lib/attr.js","webpack:///./~/can-view-live/lib/attrs.js","webpack:///./~/can-view-live/lib/html.js","webpack:///./~/can-view-live/lib/list.js","webpack:///./~/can-view-live/lib/text.js","webpack:///./~/can-view-live/lib/util/runInOrder.js","webpack:///./~/can-view-scope/compute_data.js","webpack:///./~/can-view-scope/reference-map.js","webpack:///./~/object-assign/index.js","webpack:///./~/spectre-canjs/property-table/ViewModel.js","webpack:///./~/spectre-canjs/property-table/property-table.js","webpack:///./~/spectre-canjs/util/field/base/FieldIteratorMap.js","webpack:///./~/spectre-canjs/util/field/parseFieldArray/parseFieldArray.js","webpack:///./~/spectre-canjs/util/string/string.js","webpack:///(webpack)/buildin/system.js","webpack:///./src/ts/test.js","webpack:///vertx (ignored)"],"names":["resolve","reject","then","originalThen","originalResolve","Resolve","Reject"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,EAAE;AACF;AACA,eAAe,OAAO;AACtB,aAAa;AACb;AACA,qJAAqJ;AACrJ;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;ACnKA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/CA;;;;;;;ACAA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,wBAAwB;AACxB;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;ACreA;;AAEA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;;AAEA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB,UAAU;AACjE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD,0BAA0B;AAC1B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,oBAAoB;AACpB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;ACvnBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;;;;;;;ACvFD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACxGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,OAAO,iCAAiC;AACxC,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ,cAAc,sEAAsE,aAAa;AACrH,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,GAAG;AACH,aAAa;AACb;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;AC1kBA;;AAEA;AACA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;;AAEA;;;;;;;;uDCjCA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;AC9CA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,uBAAuB;AACvB;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,MAAM;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qEAAqE,mBAAmB;AACxF;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,6EAA6E;AAC7E,EAAE;AACF,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;AC9VA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrCA;;AAEA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;;;;;;;;AClBA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;ACtGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,2BAA2B,SAAS,WAAW,OAAO,KAAK,KAAK,IAAI,QAAQ;AAC5E;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uBAAuB;AACvB,uBAAuB;AACvB,4BAA4B;AAC5B,kCAAkC;AAClC,EAAE;AACF;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI,IAAI,WAAW,GAAG;AACjE,2CAA2C,MAAM,GAAG;AACpD,0CAA0C,MAAM,GAAG,IAAI,UAAU,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,YAAY,OAAO,sBAAsB,YAAY;AACrD,YAAY,OAAO;AACnB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,IAAI,YAAY,GAAG;AACxD,iCAAiC,IAAI,KAAK,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrPA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,aAAa,iCAAiC;AAC9C;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iCAAiC;AAC/C,cAAc,WAAW;AACzB,cAAc,iCAAiC;AAC/C,cAAc,QAAQ;AACtB,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,UAAU,UAAU;AACpB,UAAU,QAAQ;AAClB,WAAW,MAAM;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;;;;;;;;AC1cA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;;AAEA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;AACA;AACA;AACA,+BAA+B,GAAG;AAClC;AACA,8BAA8B,OAAO,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mCAAmC;AACnC;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,sCAAsC,GAAG;AACzC;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC/BA;;AAEA;AACA;AACA,yHAAyH,MAAM;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,gDAAgD;AACpE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF,sBAAsB,aAAa,EAAE;AACrC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,KAAK;AACL,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACjpBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA,yDAAyD,aAAa;AACtE;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AAC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EAAE;YACnD,OAAO;SACV;KACJ;;IAED,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;;;AC9B5B;AACA,OAAO,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC5B,OAAO,CAAC,OAAO,GAAG,OAAO,CACzB;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA,6BAA6B;AAC7B;AACA,8BAA8B;AAC9B,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,yCAAyC,iEAAiE;AAC1G,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA,gBAAgB;AAChB;AACA,qBAAqB;AACrB;AACA,eAAe;AACf;AACA;AACA;AACA,qCAAqC;AACrC,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA,KAAK,GAAG,EAAE;AACV;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB;AACxB,0BAA0B;AAC1B,iCAAiC;AACjC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,eAAe;AACf;AACA;AACA,gBAAgB;AAChB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,mBAAmB;AAChD,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iDAAiD;AACjD,gCAAgC;AAChC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,O;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gBAAgB;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;AC/1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,YAAY,OAAO;AACnB;;;AAGA;;AAEA,uDAAuD,EAAE,KAAK,KAAK,EAAE,EAAE,4BAA4B,EAAE,KAAK,KAAK,EAAE,EAAE;AACnH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,iBAAiB;AAC7B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,2DAA2D;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,OAAO;AACrC;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA,GAAG;AACH;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uFAAuF;;AAEvF;AACA,6BAA6B;AAC7B;AACA,IAAI;;AAEJ;AACA;AACA;;;AAGA,IAAI;AACJ;AACA;AACA;;AAEA,GAAG;AACH,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACneA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA,EAAE;AACF;AACA;;;;;;;;AC5GA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;;ACjMA;;AAEA;AACA;AACA;;;;;;;;ACJA;;AAEA;AACA;AACA;;;;;;;;;ACJA,4CAAsC;AAEtC;IACI,MAAM,CAAC,OAAO,MAAM,CAAC,SAAS,CAAC,KAAK,WAAW,CAAC;AACpD,CAAC;AAED,qBAAqB,OAAiB;IAClC,MAAM,CAAC,IAAI,qBAAO,CAAC,UAAC,OAAO,EAAE,MAAM;QAC/B,gFAAgF;QAChF,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACtC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE;YAAC,cAAO;iBAAP,UAAO,EAAP,qBAAO,EAAP,IAAO;gBAAP,yBAAO;;YAC/B,6DAA6D;YAC7D,OAAO,CAAC,IAAI,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AAED,uBAA8B,GAAY;IACtC,MAAM,CAAC,IAAI,qBAAO,CAAC,UAAC,OAAO,EAAE,MAAM;QAC/B,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YACb,8DAA8D;YAC9D,MAAM,CAAC,wDAAwD,CAAC,CAAC;QACrE,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACP,GAAG,GAAG,4BAA4B,CAAC;QACvC,CAAC;QAED,IAAI,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QAC9C,MAAM,CAAC,IAAI,GAAG,iBAAiB,CAAC;QAChC,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;QACjB,MAAM,CAAC,MAAM,GAAG;YACZ,sCAAsC;YACtC,OAAO,EAAE,CAAC;QACd,CAAC,CAAC;QACF,qDAAqD;QACrD,MAAM,CAAC,OAAO,GAAG,MAAM,CAAC;QACxB,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;AACP,CAAC;AAtBD,sCAsBC;AAED,qBAA4B,OAAiB;IACzC,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QACd,MAAM,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,cAAM,kBAAW,CAAC,OAAO,CAAC,EAApB,CAAoB,CAAC;IAC3D,CAAC;IACD,IAAI,CAAC,CAAC;QACF,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;AACL,CAAC;AAPD,kCAOC;;;;;;;AChDD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,iBAAiB,YAAY,eAAe;AACrF,mDAAmD,iBAAiB,YAAY,eAAe;AAC/F;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;;AAEA,IAAI;;AAEJ;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,kBAAkB;;AAElB;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,uDAAuD,WAAW;AAClE;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;;;AAIA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0BAA0B;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvZA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD,mBAAmB;AACtE;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA,0DAA0D;AAC1D;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA,wEAAwE,oBAAoB;AAC5F;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;AC7UA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB;;AAEA;;AAEA;;AAEA,QAAQ,iDAAiD;AACzD,QAAQ,SAAS;;AAEjB,SAAS;;AAET;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3EA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;;ACbA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACjCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;AACA;;AAEA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB,OAAO;AACP,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,2BAA2B;AACvC;AACA,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC,eAAe,cAAc;AAC7B,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;AChbA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oEAAoE;AACpE;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,iBAAiB;AACjB,GAAG;AACH,iBAAiB;AACjB;AACA;AACA,EAAE;AACF,gBAAgB;AAChB,EAAE;AACF;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;;AAEA,uBAAuB;AACvB;AACA,2BAA2B;AAC3B,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;AC/3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB,WAAW,EAAE;AACjE,uBAAuB,MAAM;AAC7B;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,SAAS;AACT,0DAA0D;AAC1D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,EAAE;AACnB,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,8BAA8B,2BAA2B;AACzD,+BAA+B;AAC/B;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,4DAA4D;AAC5D,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC7SA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,GAAG;AACH,WAAW;AACX;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,2CAA2C,IAAI;;AAE/C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;;AAEH,UAAU;AACV,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C,EAAE;AACF,6BAA6B,IAAI;AACjC;;AAEA;AACA,oCAAoC,IAAI;AACxC,EAAE;AACF,iDAAiD,IAAI;AACrD;AACA;;AAEA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,IAAI;AACrE,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,GAAG;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iDAAiD;AACpH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,yBAAyB;AACzB;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,oBAAoB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,OAAO,OAAO;AACd,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAiD;AAClG,KAAK;AACL,8CAA8C,iDAAiD;AAC/F,KAAK;AACL,yDAAyD,iDAAiD;AAC1G;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE,MAAM;AACN;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,uEAAuE,2BAA2B;AAClG;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,wBAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,iCAAiC;AAC/D,KAAK;AACL,8BAA8B,2BAA2B;AACzD,KAAK;AACL,mCAAmC,kBAAkB;AACrD,KAAK;AACL;AACA;AACA,qDAAqD,gBAAgB;AACrE,KAAK;AACL,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACh4BA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1EA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;;;;;;;AC5EA;;AAEA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oCAAoC;AAC7D;AACA;AACA,kCAAkC;AAClC;AACA;;;;;;;;ACtBA;;AAEA;AACA;AACA;AACA;;;;;;;;ACLA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;;AAEA;;;;;;;;AClDA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,gBAAgB;;AAErD;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS,sCAAsC;AACjF,kCAAkC,SAAS,qCAAqC;AAChF;AACA;AACA;AACA,SAAS,KAAK,EAAE,KAAK;AACrB,SAAS,KAAK,EAAE,KAAK;AACrB;AACA,KAAK,SAAS,oCAAoC,KAAK,EAAE;AACzD;AACA;;AAEA;AACA,eAAe,cAAc;AAC7B;AACA,cAAc,EAAE;AAChB,cAAc,qCAAqC;AACnD,eAAe,EAAE;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAA+D;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAA4C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;;;;;;;AC9GA;;AAEA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,IAAI,WAAW,YAAY;AACnD,oBAAoB,MAAM,YAAY;AACtC,qBAAqB,MAAM,GAAG,IAAI,UAAU,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC/CA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,oCAAoC,GAAG,4BAA4B,GAAG,GAAG;AACzE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,EAAE,KAAK;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAoD;AAC5E;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,MAAM,UAAU,MAAM;AAC/B;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,SAAS,EAAE;AACjD,+BAA+B,YAAY;AAC3C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,I;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;;;;;;;ACvfA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACtLtC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,mDAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA;AACA,aAAa,EAAE;AACf;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa,EAAE;AACf;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC,OAAO;AACP;AACA,iCAAiC,eAAe;AAChD,8BAA8B,6BAA6B;AAC3D;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,2BAA2B;AAC3B;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,OAAO;AACnB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,2BAA2B;AAC3B;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,OAAO;AACnB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC,OAAO;AACP;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC,OAAO;AACP;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B;AACA;AACA,cAAc,EAAE;AAChB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA,cAAc,EAAE;AAChB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0BAA0B;AAC1B;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB,kDAAkD,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iCAAiC;AACxC,OAAO,mCAAmC;AAC1C,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC11CA;AACA;AACA,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC9FA;;AAEA;AACA;AACA;;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,oBAAoB;AACnC;AACA;;AAEA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/KA;;AAEA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA,kCAAkC;AAClC;AACA;;;;;;;;ACrBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,uCAAuC,+BAA+B;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACzJA;;AAEA;AACA;AACA;AACA,E;;;;;;;ACLA;;AAEA;;AAEA;AACA;AACA;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mCAAmC;AACnC,gDAAgD,iCAAiC;;AAEjF;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA,4CAA4C,SAAS;AACrD,mCAAmC,4BAA4B;AAC/D;AACA;AACA;;;AAGA,EAAE;;AAEF;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;;AAEA,YAAY,iBAAiB;AAC7B;AACA;;AAEA,wBAAwB,qCAAqC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACrRyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,wBAAwB,WAAW,uCAAuC,kBAAkB,GAAG,OAAO;AACtG,4BAA4B,WAAW,uCAAuC,kBAAkB,GAAG,OAAO;AAC1G,wBAAwB,WAAW,uCAAuC,kBAAkB,GAAG,OAAO;AACtG,wBAAwB,WAAW,+BAA+B,MAAM,qBAAqB,OAAO;AACpG,8BAA8B,WAAW,+BAA+B,MAAM,qBAAqB,OAAO;AAC1G,wBAAwB,WAAW,+BAA+B,MAAM,qBAAqB,OAAO;AACpG,iEAAiE,kBAAkB,GAAG,OAAO,qBAAqB,WAAW;AAC7H;AAAA;AAAA;;AAEA,8EAAkC,oBAAoB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA,eAAe,4BAA4B;AAC3C,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;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ED,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAC,IAAI,WAAW,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC,CAAC;AAEvE,CAAC,CAAC,CAAC,KAAK,CAAC,UAAC,GAAG;IACX,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;AACvB,CAAC,CAAC,EA/lB6E,CA+lB7E,CAAC;;;;;;;AC/mBH;AACA;AACA;;;;AAIA,mTAAmT,uBAAuB,sDAAsD,aAAa,2CAA2C,eAAe,+BAA+B,wBAAwB,wEAAwE,OAAO;AAC7kB;;AAEA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA,wDAAwD;AACxD;;AAEA;AACA,E;;;;;;;ACpBA;AACA;AACA;;;;AAIA,iGAAiG,OAAO,6FAA6F,OAAO,WAAW,OAAO;AAC9N;;AAEA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA,wDAAwD;AACxD;;AAEA;AACA,E;;;;;;;ACpBA,yC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;;;AAIF;;;;;;;AC5UA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,KAAK,KAAK;;AAEjC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,YAAY;AACtD;AACA;;AAEA;;AAEA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,GAAG;AACH;AACA,wDAAwD,MAAM;AAC9D;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI;AACJ;AACA,sCAAsC,kBAAkB;AACxD;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAmC,mCAAmC;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;;AAEJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;;;;;;AC1iBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB,KAAK,KAAK;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,OAAO;AACjG;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,cAAc;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;;AAEN;AACA,UAAU,QAAQ;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oCAAoC;AACpC;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B;AAC/B;AACA,KAAK;AACL,qCAAqC;AACrC;AACA,KAAK;AACL;AACA;AACA,qBAAqB,qBAAqB;AAC1C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC1cA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;;;;;;ACrJA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB;AACrB,0CAA0C;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA,mBAAmB;AACnB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qBAAqB;;AAE5B;;AAEA;AACA;AACA,OAAO;AACP,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qEAAqE;AACrE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,kBAAkB;AAC9B;AACA,IAAI;AACJ;AACA;AACA,iBAAiB;AACjB;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA;;;AAGA;AACA;AACA;;AAEA,OAAO;AACP,wBAAwB,IAAI,IAAI;;AAEhC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,wBAAwB;AACxB,0BAA0B,IAAI;AAC9B;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,wDAAwD,uBAAuB;AAC/E,8DAA8D;AAC9D,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,MAAM;AACN,uGAAuG;AACvG;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,eAAe,UAAU;AAClD;AACA,gCAAgC,EAAE;AAClC;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,IAAI;AACjD,2BAA2B,KAAK;AAChC,oFAAoF;AACpF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,kBAAkB;AAClB,GAAG;AACH;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,oBAAoB;AACpB,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACrkCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;;;;;;ACpBA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW,GAAG,QAAQ;AAC/B;AACA;AACA,qCAAqC,WAAW;AAChD,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,oDAAoD;AACpD;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;ACxJA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;ACjHA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;AC9FA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,KAAK;;AAEL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;AC3EA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC7EA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;AC5EA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;+CCVA;;AAEA;AACA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gDAAgD;AAChD,0BAA0B;AAC1B;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;AC5CA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;;AAEA;;;;;;;;AC5CA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC/DA;;;AAGA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA,qBAAqB,WAAW;AAChC;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;;AAEA;AACA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;;;;;;;AC5CA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA;;;;;;;;ACxBA;;AAEA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,uCAAuC;AACvC,yCAAyC;AACzC;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;;;;;;AC1BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,G;;;;;;AChBA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC,OAAO;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC1CA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC3EA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA,WAAW,YAAY;AACvB;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;ACxFA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,WAAW,YAAY;AACvB;AACA,WAAW,0CAA0C;AACrD;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA,YAAY,GAAG,YAAY;AAC3B,SAAS;AACT,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iCAAiC;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;;;;;AC9aA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;;ACzCA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5BA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzHA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,CAAC;;AAED;AACA;;;;;;;;;;;;;AC/GA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACRD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;;;;;;;;;;ACrDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;;;;;;;;;;;AC1BA;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtBA,e","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 123);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 32d34e2d31ef227d8650","var namespace = require('can-namespace');\n/**\n * @module {Object} can-types\n * @parent can-infrastructure\n * @description A stateful container for CanJS type information.\n *\n * @body\n *\n * ## Use\n *\n * `can-types` exports an object with placeholder functions that\n * can be used to provide default types or test if something is of a certain type.\n *\n * This is where the sausage of loose coupling modules takes place.\n * Modules that provide a type will overwrite one or multiple of these functions so\n * they take into account the new type.\n *\n * For example, `can-define/map/map` might overwrite `isMapLike` to return true\n * if the object is an instance of Map:\n *\n * ```js\n * var types = require(\"can-types\");\n * var oldIsMapLike = types.isMapLike;\n * types.isMapLike = function(obj){\n *   return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\n * };\n * types.DefaultMap = DefineMap;\n * ```\n */\n\nvar types = {\n\t/**\n\t * @function can-types.isMapLike isMapLike\n\t * @signature `types.isMapLike(obj)`\n\t *   Returns true if `obj` is an observable key-value pair type object.\n\t *\n\t * @return {Boolean} `true` if the object is map like.\n\t */\n\tisMapLike: function(){\n\t\treturn false;\n\t},\n\t/**\n\t * @function can-types.isListLike isListLike\n\t * @signature `types.isListLike(obj)`\n\t *   Returns true if `obj` is an observable list-type object with numeric keys and a length.\n\t *\n\t * @return {Boolean} `true` if the object is list like.\n\t */\n\tisListLike: function(){\n\t\treturn false;\n\t},\n\t/**\n\t * @function can-types.isPromise isPromise\n\t * @signature `types.isPromise(obj)`\n\t *   Returns true if `obj` is a Promise.\n\t *\n\t * @return {Boolean} `true` if the object is a Promise.\n\t */\n\tisPromise: function(obj){\n\t\treturn (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));\n\t},\n\t/**\n\t * @function can-types.isConstructor isConstructor\n\t * @signature `types.isConstructor(obj)`\n\t *   Returns true if `obj` looks like a constructor function to be called with `new`.\n\t *\n\t * @return {Boolean} `true` if the object is a constructor function.\n\t */\n\tisConstructor: function(func){\n\t\t/* jshint unused: false */\n\t\tif(typeof func !== \"function\") {\n\t\t\treturn false;\n\t\t}\n\t\t// if there are any properties on the prototype, assume it's a constructor\n\t\tfor(var prop  in func.prototype) {\n\t\t\treturn true;\n\t\t}\n\t\t// We could also check if something is returned, if it is, probably not a constructor.\n\t\treturn false;\n\t},\n\t/**\n\t * @function can-types.isCallableForValue isCallableForValue\n\t * @signature `types.isConstructor(obj)`\n\t *   Returns true if `obj` looks like a function that should be read to get a value.\n\t *\n\t * @return {Boolean} `true` if the object should be called for a value.\n\t */\n\tisCallableForValue: function(obj){\n\t\treturn typeof obj === \"function\" && !types.isConstructor(obj);\n\t},\n\t/**\n\t * @function can-types.isCompute isCompute\n\t * @signature `types.isCompute(obj)`\n\t *   Returns true if `obj` is a [can-compute].\n\t *\n\t * @return {Boolean} `true` if the object is a [can-compute].\n\t */\n\tisCompute: function(obj){\n\t\treturn obj && obj.isComputed;\n\t},\n\t/**\n\t * @property {Symbol} can-types.iterator iterator\n\t * @option {Symbol}\n\t *\n\t * Used to implement an iterable object that can be used with [can-util/js/each/each]. In browsers that support for/of this will be Symbol.iterator; in older browsers it will be a string, but is still useful with [can-util/js/each/each].\n\t */\n\titerator: (typeof Symbol === \"function\" && Symbol.iterator) || \"@@iterator\",\n\t/**\n\t * @property {Map} can-types.DefaultMap DefaultMap\n\t *\n\t * @option {Map}\n\t *\n\t *   The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]\n\t *   are imported, the default type will be [can-define/map/map].\n\t */\n\tDefaultMap: null,\n\t/**\n\t * @property {can-connect.List} can-types.DefaultList DefaultList\n\t *\n\t * @option {can-connect.List}\n\t *\n\t *   The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]\n\t *   are imported, the default type will be [can-define/list/list].\n\t */\n\tDefaultList: null,\n\t/**\n\t * @function can-types.wrapElement wrapElement\n\t * @signature `types.wrapElement(element)`\n\t *   Wraps an element into an object useful by DOM libraries ala jQuery.\n\t *\n\t *   @param {Node} element Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node).\n\t *   @return {{}} A wrapped object.\n\t */\n\t/**\n\t * @function can-types.queueTask queueTask\n\t * @signature `types.queueTask(task)`\n\t *   Run code that will be queued at the end of the current batch.\n\t *   @param {Array} task\n\t */\n\tqueueTask: function(task){\n\t\tvar args = task[2] || [];\n\t\ttask[0].apply(task[1], args);\n\t},\n\twrapElement: function(element){\n\t\treturn element;\n\t},\n\t/**\n\t * @function can-types.unwrapElement unwrapElement\n\t * @signature `types.unwrapElement(object)`\n\t *   Unwraps an object that contains an element within.\n\t *\n\t *   @param {{}} object Any object that can be unwrapped into a Node.\n\t *   @return {Node} A Node.\n\t */\n\tunwrapElement: function(element){\n\t\treturn element;\n\t}\n};\n\nif (namespace.types) {\n\tthrow new Error(\"You can't have two versions of can-types, check your dependencies\");\n} else {\n\tmodule.exports = namespace.types = types;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-types/can-types.js\n// module id = 0\n// module chunks = 0","'use strict';\n\n/* jshint maxdepth:7*/\nvar isArrayLike = require('../is-array-like/is-array-like');\nvar has = Object.prototype.hasOwnProperty;\nvar isIterable = require(\"../is-iterable/is-iterable\");\nvar types = require(\"can-types\");\n\nfunction each(elements, callback, context) {\n\tvar i = 0,\n\t\tkey,\n\t\tlen,\n\t\titem;\n\tif (elements) {\n\t\tif ( isArrayLike(elements) ) {\n\n\t\t\tfor (len = elements.length; i < len; i++) {\n\t\t\t\titem = elements[i];\n\t\t\t\tif (callback.call(context || item, item, i, elements) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Works in anything that implements Symbol.iterator\n\t\telse if(isIterable(elements)) {\n\t\t\tvar iter = elements[types.iterator]();\n\t\t\tvar res, value;\n\n\t\t\twhile(!(res = iter.next()).done) {\n\t\t\t\tvalue = res.value;\n\t\t\t\tcallback.call(context || elements, Array.isArray(value) ?\n\t\t\t\t\t\t\t\t\t\t\tvalue[1] : value, value[0]);\n\t\t\t}\n\t\t}\n\t\t else if (typeof elements === \"object\") {\n\t\t\tfor (key in elements) {\n\t\t\t\tif (has.call(elements, key) &&\n\t\t\t\t\t\tcallback.call(context || elements[key],\n\t\t\t\t\t\t\t\t\t\t\t\t\telements[key], key, elements) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn elements;\n}\n\nmodule.exports = each;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/each/each.js\n// module id = 1\n// module chunks = 0","module.exports = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-namespace/can-namespace.js\n// module id = 2\n// module chunks = 0","/**\n * @module {function} can-util/js/assign/assign assign\n * @parent can-util/js\n * @signature `assign(target, source)`\n *\n * A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n *\n * ```js\n * var assign = require(\"can-util/js/assign/assign\");\n *\n * var obj = {};\n *\n * assign(obj, {\n *   foo: \"bar\"\n * });\n *\n * console.log(obj.foo); // -> \"bar\"\n * ```\n *\n * @param {Object} target The destination object. This object's properties will be mutated based on the object provided as `source`.\n * @param {Object} source The source object whose own properties will be applied to `target`.\n *\n * @return {Object} Returns the `target` argument.\n */\nmodule.exports = function (d, s) {\n\tfor (var prop in s) {\n\t\td[prop] = s[prop];\n\t}\n\treturn d;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/assign/assign.js\n// module id = 3\n// module chunks = 0","// # can-event\n//\n// Implements a basic event system that can be used with any type of object.\n// In addition to adding basic event functionality, it also provides the `can.event` object\n// that can be mixed into objects and prototypes.\n//\n// Most of the time when this is used, it will be used with the mixin:\n//\n// ```\n// var SomeClass = Construct(\"SomeClass\");\n// assign(SomeClass.prototype, canEvent);\n// ```\nvar domEvents = require('can-util/dom/events/events');\nvar CID = require('can-cid');\nvar isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');\nvar domDispatch = require('can-util/dom/dispatch/dispatch');\nvar namespace = require('can-namespace');\nrequire('can-util/dom/events/delegate/delegate');\nrequire('can-util/dom/events/delegate/enter-leave');\n\nfunction makeHandlerArgs(event, args) {\n    if (typeof event === 'string') {\n        event = {\n            type: event\n        };\n    }\n    var handlerArgs = [event];\n\n    // Execute handlers listening for this event.\n    if(args) {\n        handlerArgs.push.apply(handlerArgs, args);\n    }\n    return handlerArgs;\n}\n\nfunction getHandlers(eventName){\n    var events = this.__bindEvents;\n    if (!events) {\n        return;\n    }\n    return events[eventName];\n}\n\n// ## can.event\n// Create and export the `can.event` mixin\nvar canEvent = {\n    // First define core object-based methods\n\n    // ## can-event.addEventListener\n    //\n    // Adds a basic event listener to an object.\n    // This consists of storing a cache of event listeners on each object,\n    // that are iterated through later when events are dispatched.\n    /**\n     * @function can-event.addEventListener addEventListener\n     * @parent can-event.static\n     * @signature `obj.addEventListener(event, handler)`\n     *\n     * Add a basic event listener to an object.\n\t *\n\t * ```js\n\t * var canEvent = require(\"can-event\");\n\t *\n\t * var obj = {};\n\t * Object.assign(obj, canEvent);\n\t *\n\t * obj.addEventListener(\"foo\", function(){ ... });\n\t * ```\n     *\n     * @param {String} event The name of the event to listen for.\n     * @param {Function} handler The handler that will be executed to handle the event.\n     * @return {Object} this\n     *\n     * @signature `canEvent.addEventListener.call(obj, event, handler)`\n     *\n     * This syntax can be used for objects that don't include the `canEvent` mixin.\n     */\n    addEventListener: function (event, handler) {\n    \t// Initialize event cache.\n    \tvar allEvents = this.__bindEvents || (this.__bindEvents = {}),\n    \t\teventList = allEvents[event] || (allEvents[event] = []);\n\n    \t// Add the event\n    \teventList.push(handler);\n    \treturn this;\n    },\n\n    // ## can-event.removeEventListener\n    //\n    // Removes a basic event listener from an object.\n    // This removes event handlers from the cache of listened events.\n    /**\n     * @function can-event.removeEventListener removeEventListener\n     * @parent can-event.static\n     * @signature `obj.removeEventListener(event, handler)`\n     *\n     * Removes a basic event listener from an object.\n     *\n     * @param {String} event The name of the event to listen for.\n     * @param {Function} handler The handler that will be executed to handle the event.\n     * @return {Object} this\n     *\n     * @signature `canEvent.removeEventListener.call(obj, event, handler)`\n     *\n     * This syntax can be used for objects that don't include the [can-event] mixin.\n     */\n    removeEventListener: function (event, fn) {\n    \tif (!this.__bindEvents) {\n    \t\treturn this;\n    \t}\n    \tvar handlers = this.__bindEvents[event] || [],\n    \t\ti = 0,\n    \t\thandler, isFunction = typeof fn === 'function';\n    \twhile (i < handlers.length) {\n    \t\thandler = handlers[i];\n    \t\t// Determine whether this event handler is \"equivalent\" to the one requested\n    \t\t// Generally this requires the same event/function, but a validation function\n    \t\t// can be included for extra conditions. This is used in some plugins like `can/event/namespace`.\n    \t\tif ( isFunction && handler === fn || !isFunction && (handler.cid === fn || !fn)) {\n    \t\t\thandlers.splice(i, 1);\n    \t\t} else {\n    \t\t\ti++;\n    \t\t}\n    \t}\n    \treturn this;\n    },\n    // ## can-event.dispatch\n    //\n    // Dispatches/triggers a basic event on an object.\n    /**\n     * @function can-event.dispatch dispatch\n     * @parent can-event.static\n     * @signature `obj.dispatch(event, [args])`\n     *\n     * Dispatches/triggers a basic event on an object.\n\t *\n\t * ```js\n\t * var canEvent = require(\"can-event\");\n\t *\n\t * var obj = {};\n\t * Object.assign(obj, canEvent);\n\t *\n\t * obj.addEventListener(\"foo\", function(){\n\t *   console.log(\"FOO BAR!\");\n\t * });\n\t *\n\t * obj.dispatch(\"foo\"); // Causes it to log FOO BAR\n\t * ```\n     *\n     * @param {String|Object} event The event to dispatch\n     * @param {Array} [args] Additional arguments to pass to event handlers\n     * @return {Object} event The resulting event object\n     *\n     * @signature `canEvent.dispatch.call(obj, event, args)`\n     *\n     * This syntax can be used for objects that don't include the `can.event` mixin.\n     */\n    dispatchSync: function (event, args) {\n        var handlerArgs = makeHandlerArgs(event, args);\n        var handlers = getHandlers.call(this, handlerArgs[0].type);\n\n    \tif(!handlers) {\n    \t\treturn;\n    \t}\n        handlers = handlers.slice(0);\n        for (var i = 0, len = handlers.length; i < len; i++) {\n    \t\thandlers[i].apply(this, handlerArgs);\n    \t}\n\n    \treturn handlerArgs[0];\n    },\n\t// Define abstract helpers\n\n    /**\n     * @function can-event.on on\n     * @parent can-event.static\n     * @signature `obj.on(event, handler)`\n     *\n     * Add a basic event listener to an object.\n     *\n     * This is an alias of [can-event.addEventListener addEventListener].\n     *\n     * @signature `can-event.on.call(obj, event, handler)`\n     *\n     * This syntax can be used for objects that don't include the [can-event] mixin.\n     */\n    on: function(eventName, selector, handler) {\n        var method = typeof selector === \"string\" ? \"addDelegateListener\" : \"addEventListener\";\n\n        var listenWithDOM = domEvents.canAddEventListener.call(this);\n        var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];\n\n        return eventBinder.apply(this, arguments);\n    },\n\n    /**\n     * @function can-event.off off\n     * @parent can-event.static\n     * @signature `obj.off(event, handler)`\n     *\n     * Removes a basic event listener from an object.\n     *\n     * This is an alias of [can-event.removeEventListener removeEventListener].\n     *\n     * @signature `canEvent.off.call(obj, event, handler)`\n     *\n     * This syntax can be used for objects that don't include the [can-event] mixin.\n     */\n    off: function(eventName, selector, handler) {\n        var method = typeof selector === \"string\" ? \"removeDelegateListener\" : \"removeEventListener\";\n\n        var listenWithDOM = domEvents.canAddEventListener.call(this);\n        var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];\n\n        return eventBinder.apply(this, arguments);\n    },\n    /**\n     * @function can-event.trigger trigger\n     * @parent can-event.static\n     * @signature `obj.trigger(event, args)`\n     *\n     * Dispatches/triggers a basic event on an object.\n     * This is an alias of [can-event.dispatch dispatch].\n     *\n     * @signature `canEvent.trigger.call(obj, event, args)`\n     *\n     * This syntax can be used for objects that don't include the [can-event] mixin.\n     */\n    trigger: function(){\n        var listenWithDOM = domEvents.canAddEventListener.call(this);\n        var dispatch = listenWithDOM ? domDispatch : canEvent.dispatch;\n\n        return dispatch.apply(this, arguments);\n    },\n\n    // ## can-event.one\n    //\n    // Adds a basic event listener that listens to an event once and only once.\n    /**\n     * @function can-event.one one\n     * @parent can-event.static\n     * @signature `obj.one(event, handler)`\n     *\n     * Adds a basic event listener that listens to an event once and only once.\n     *\n     * @param {String} event The name of the event to listen for.\n     * @param {Function} handler The handler that will be executed to handle the event.\n     * @return {Object} this\n     */\n    one: function(event, handler) {\n    \t// Unbind the listener after it has been executed\n    \tvar one = function() {\n    \t\tcanEvent.off.call(this, event, one);\n    \t\treturn handler.apply(this, arguments);\n    \t};\n\n    \t// Bind the altered listener\n    \tcanEvent.on.call(this, event, one);\n    \treturn this;\n    },\n\n    // self listener methods\n    // ## can-event.listenTo\n    //\n    // Listens to an event without know how bind is implemented.\n    // The primary use for this is to listen to another's objects event while\n    // tracking events on the local object (similar to namespacing).\n    //\n    // The API was heavily influenced by BackboneJS: http://backbonejs.org/\n    /**\n     * @function can-event.listenTo listenTo\n     * @parent can-event.static\n     * @signature `obj.listenTo(other, event, handler)`\n     *\n     * Listens for an event on another object.\n     * This is similar to concepts like event namespacing, except that the namespace\n     * is the scope of the calling object.\n     *\n     * @param {Object} other The object to listen for events on.\n     * @param {String} event The name of the event to listen for.\n     * @param {Function} handler The handler that will be executed to handle the event.\n     * @return {Object} this\n     *\n     * @signature `canEvent.listenTo.call(obj, other, event, handler)`\n     *\n     * This syntax can be used for objects that don't include the [can-event] mixin.\n     */\n    listenTo: function (other, event, handler) {\n    \t// Initialize event cache\n    \tvar idedEvents = this.__listenToEvents;\n    \tif (!idedEvents) {\n    \t\tidedEvents = this.__listenToEvents = {};\n    \t}\n\n    \t// Identify the other object\n    \tvar otherId = CID(other);\n    \tvar othersEvents = idedEvents[otherId];\n\n    \t// Create a local event cache\n    \tif (!othersEvents) {\n    \t\tothersEvents = idedEvents[otherId] = {\n    \t\t\tobj: other,\n    \t\t\tevents: {}\n    \t\t};\n    \t}\n    \tvar eventsEvents = othersEvents.events[event];\n    \tif (!eventsEvents) {\n    \t\teventsEvents = othersEvents.events[event] = [];\n    \t}\n\n    \t// Add the event, both locally and to the other object\n    \teventsEvents.push(handler);\n    \tcanEvent.on.call(other, event, handler);\n    },\n    // ## can-event.stopListening\n    //\n    // Stops listening for events on other objects\n    /**\n     * @function can-event.stopListening stopListening\n     * @parent can-event.static\n     * @signature `obj.stopListening(other, event, handler)`\n     *\n     * Stops listening for an event on another object.\n     *\n     * @param {Object} other The object to listen for events on.\n     * @param {String} event The name of the event to listen for.\n     * @param {Function} handler The handler that will be executed to handle the event.\n     * @return {Object} this\n     *\n     * @signature `canEvent.stopListening.call(obj, other, event, handler)`\n     *\n     * This syntax can be used for objects that don't include the [can-event] mixin.\n     */\n    stopListening: function (other, event, handler) {\n    \tvar idedEvents = this.__listenToEvents,\n    \t\titerIdedEvents = idedEvents,\n    \t\ti = 0;\n    \tif (!idedEvents) {\n    \t\treturn this;\n    \t}\n    \tif (other) {\n    \t\tvar othercid = CID(other);\n    \t\t(iterIdedEvents = {})[othercid] = idedEvents[othercid];\n    \t\t// you might be trying to listen to something that is not there\n    \t\tif (!idedEvents[othercid]) {\n    \t\t\treturn this;\n    \t\t}\n    \t}\n\n    \t// Clean up events on the other object\n    \tfor (var cid in iterIdedEvents) {\n    \t\tvar othersEvents = iterIdedEvents[cid],\n    \t\t\teventsEvents;\n    \t\tother = idedEvents[cid].obj;\n\n    \t\t// Find the cache of events\n    \t\tif (!event) {\n    \t\t\teventsEvents = othersEvents.events;\n    \t\t} else {\n    \t\t\t(eventsEvents = {})[event] = othersEvents.events[event];\n    \t\t}\n\n    \t\t// Unbind event handlers, both locally and on the other object\n    \t\tfor (var eventName in eventsEvents) {\n    \t\t\tvar handlers = eventsEvents[eventName] || [];\n    \t\t\ti = 0;\n    \t\t\twhile (i < handlers.length) {\n    \t\t\t\tif (handler && handler === handlers[i] || !handler) {\n    \t\t\t\t\tcanEvent.off.call(other, eventName, handlers[i]);\n    \t\t\t\t\thandlers.splice(i, 1);\n    \t\t\t\t} else {\n    \t\t\t\t\ti++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t// no more handlers?\n    \t\t\tif (!handlers.length) {\n    \t\t\t\tdelete othersEvents.events[eventName];\n    \t\t\t}\n    \t\t}\n    \t\tif (isEmptyObject(othersEvents.events)) {\n    \t\t\tdelete idedEvents[cid];\n    \t\t}\n    \t}\n    \treturn this;\n    }\n\n};\n\n// add aliases\n/**\n * @function can-event.bind bind\n * @parent can-event.static\n * @signature `obj.bind(event, handler)`\n *\n * Add a basic event listener to an object.\n *\n * This is an alias of [can-event.addEventListener addEventListener].\n *\n * @signature `canEvent.bind.call(obj, event, handler)`\n *\n * This syntax can be used for objects that don't include the [can-event] mixin.\n */\ncanEvent.addEvent = canEvent.bind = function(){\n    // Use a wrapping function so `addEventListener`'s behavior can change.\n    return canEvent.addEventListener.apply(this, arguments);\n};\n/**\n * @function can-event.unbind unbind\n * @parent can-event.static\n * @signature `obj.unbind(event, handler)`\n *\n * Removes a basic event listener from an object.\n *\n * This is an alias of [can-event.removeEventListener removeEventListener].\n *\n * @signature `canEvent.unbind.call(obj, event, handler)`\n *\n * This syntax can be used for objects that don't include the [can-event] mixin.\n */\ncanEvent.unbind =  canEvent.removeEvent = function(){\n    return canEvent.removeEventListener.apply(this, arguments);\n};\n/**\n * @function can-event.delegate delegate\n * @parent can-event.static\n * @signature `obj.delegate(selector, event, handler)`\n *\n * Provides a compatibility layer for adding delegate event listeners.\n * This doesn't actually implement delegates, but rather allows\n * logic that assumes a delegate to still function.\n *\n * Therefore, this is essentially an alias of [can-event.addEventListener addEventListener] with the selector ignored.\n *\n * @param {String} selector The **ignored** selector to use for the delegate.\n * @param {String} event The name of the event to listen for.\n * @param {Function} handler The handler that will be executed to handle the event.\n * @return {Object} this\n *\n * @signature `canEvent.delegate.call(obj, selector, event, handler)`\n *\n * This syntax can be used for objects that don't include the [can.event] mixin.\n */\ncanEvent.delegate = canEvent.on;\n\n/**\n * @function can-event.undelegate undelegate\n * @parent can-event.static\n * @signature `obj.undelegate(selector, event, handler)`\n *\n * Provides a compatibility layer for removing delegate event listeners.\n * This doesn't actually implement delegates, but rather allows\n * logic that assumes a delegate to still function.\n *\n * Therefore, this is essentially an alias of [can-event.removeEventListener removeEventListener] with the selector ignored.\n *\n * @param {String} selector The **ignored** selector to use for the delegate.\n * @param {String} event The name of the event to listen for.\n * @param {Function} handler The handler that will be executed to handle the event.\n * @return {Object} this\n *\n * @signature `canEvent.undelegate.call(obj, selector, event, handler)`\n *\n * This syntax can be used for objects that don't include the [can-event] mixin.\n */\ncanEvent.undelegate = canEvent.off;\n\ncanEvent.dispatch = canEvent.dispatchSync;\n\n\n\nObject.defineProperty(canEvent, \"makeHandlerArgs\",{\n    enumerable: false,\n    value: makeHandlerArgs\n});\n\nObject.defineProperty(canEvent,\"handlers\", {\n    enumerable: false,\n    value: getHandlers\n});\nObject.defineProperty(canEvent,\"flush\", {\n    enumerable: false,\n    writable: true,\n    value: function(){}\n});\n\nmodule.exports = namespace.event = canEvent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-event/can-event.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nvar global = require(\"../../js/global/global\");\n\n/**\n * @module {function} can-util/dom/document/document document\n * @parent can-util/dom\n * @signature `document(document)`\n *\n * @param {Object} document An optional document-like object \n * to set as the context's document\n *\n * Optionally sets, and returns, the document object for the context.\n *\n * ```js\n * var documentShim = { getElementById() {...} };\n * var domDocument = require(\"can-util/dom/document/document\");\n * domDocument(documentShim);\n *\n * ...\n *\n * domDocument().getElementById(\"foo\");\n * ```\n */\nvar setDocument;\nmodule.exports = function(setDoc){\n\tif(setDoc) {\n\t\tsetDocument = setDoc;\n\t}\n\treturn setDocument || global().document;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/document/document.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nvar canLog = require(\"../log/log\");\n\n/**\n * @module {{}} can-util/js/dev/dev dev\n * @parent can-util/js\n *\n * Utilities for logging development-mode messages. Use this module for\n * anything that should be shown to the user during development but isn't\n * needed in production. In production these functions become noops.\n */\nmodule.exports = {\n\twarnTimeout: 5000,\n\tlogLevel: 0,\n\t/**\n\t * @function can-util/js/dev/dev.stringify stringify\n\t * @parent can-util/js/dev/dev\n\t * @description\n\t *\n\t * JSON stringifies a value, but unlike JSON, will output properties with\n\t * a value of `undefined` (e.g. `{ \"prop\": undefined }`, not `{}`).\n\t *\n\t * ```\n\t * var dev = require('can-util/js/dev/dev');\n\t * var query = { where: undefined };\n\t * \n\t * dev.warn('No records found: ' + dev.stringify(query));\n\t * ```\n\t *\n\t * @signature `dev.stringify(value)`\n\t * @param {Any} value A value to stringify.\n\t * @return {String} A stringified representation of the passed in value.\n\t */\n\tstringify: function(value) {\n\t\tvar flagUndefined = function flagUndefined(key, value) {\n\t\t\treturn value === undefined ?\n\t\t\t\t \"/* void(undefined) */\" : value;\n\t\t};\n\t\t\n\t\treturn JSON.stringify(value, flagUndefined, \"  \").replace(\n\t\t\t/\"\\/\\* void\\(undefined\\) \\*\\/\"/g, \"undefined\");\n\t},\n\t/**\n\t * @function can-util/js/dev/dev.warn warn\n\t * @parent can-util/js/dev/dev\n\t * @description\n\t *\n\t * Adds a warning message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-util/js/dev/dev');\n\t * \n\t * dev.warn(\"something evil\");\n\t * ```\n\t *\n\t * @signature `dev.warn(msg)`\n\t * @param {String} msg The warning message.\n\t */\n\twarn: function() {\n\t\t//!steal-remove-start\n\t\tcanLog.warn.apply(this, arguments);\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-util/js/dev/dev.log log\n\t * @parent can-util/js/dev/dev\n\t * @description\n\t *\n\t * Adds a message to the console.\n\t *\n\t * ```\n\t * var dev = require('can-util/js/dev/dev');\n\t * \n\t * dev.log(\"hi\");\n\t * ```\n\t *\n\t * @signature `dev.log(msg)`\n\t * @param {String} msg The message.\n\t */\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tcanLog.log.apply(this, arguments);\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-util/js/dev/dev.error error\n\t * @parent can-util/js/dev/dev\n\t * @description\n\t *\n\t * Adds an error message to the console.\n\t *\n\t * ```\n\t * var dev = require(\"can-util/js/dev/dev\");\n\t * \n\t * dev.error(new Error(\"Oh no!\"));\n\t * ```\n\t *\n\t * @signature `dev.error(err)`\n\t * @param {String|Error} err The error to be logged.\n\t */\n\terror: function() {\n\t\t//!steal-remove-start\n\t\tcanLog.error.apply(this, arguments);\n\t\t//!steal-remove-end\n\t},\n\t_logger: canLog._logger\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/dev/dev.js\n// module id = 6\n// module chunks = 0","// # can-observation - nice\n//\n// This module:\n//\n// Exports a function that calls an arbitrary function and binds to any observables that\n// function reads. When any of those observables change, a callback function is called.\n//\n// And ...\n//\n// Adds two main methods to can:\n//\n// - can.__observe - All other observes call this method to be visible to computed functions.\n// - can.__notObserve - Returns a function that can not be observed.\nrequire('can-event');\n\nvar canEvent = require('can-event');\nvar canBatch = require('can-event/batch/batch');\nvar assign = require('can-util/js/assign/assign');\nvar namespace = require('can-namespace');\nvar canLog = require('can-util/js/log/log');\n\n/**\n * @module {constructor} can-observation\n * @parent can-infrastructure\n * @group can-observation.prototype prototype\n * @group can-observation.static static\n * @group can-observation.types types\n * @package ./package.json\n *\n * Provides a mechanism to notify when an observable has been read and a\n * way to observe those reads called within a given function.\n *\n * @signature `new Observation(func, context, compute)`\n *\n * Creates an observation of a given function called with `this` as\n * a given context. Calls back `compute` when the return value of `func` changes.\n *\n * @param {function} func The function whose value is being observed.\n * @param {*} context What `this` should be when `func` is called.\n * @param {function(*,*,Number)|can-compute} updated(newValue, oldValue, batchNum) A function to call when `func`'s return value changes.\n *\n * @body\n *\n * ## Use\n *\n * Instances of `Observation` are rarely created directly.  Instead, use [can-compute]'s more friendly API to\n * observe when a function's value changes. [can-compute] uses `can-observation` internally.\n *\n * `Observation`'s static methods like: [can-observation.add], [can-observation.ignore], and [can-observation.trap]\n * are used more commonly to control which observable events a compute will listen to.\n *\n * To use `can-observation` directly, create something observable (supports `addEventListener`) and\n * calls [can-observation.add] like:\n *\n * ```js\n * var Observation = require(\"can-observation\");\n * var assign = require(\"can-util/js/assign/assign\");\n * var canEvent = require(\"can-event\");\n *\n * var me = assign({}, canEvent);\n *\n * var name = \"Justin\";\n * Object.defineProperty(me,\"name\",{\n *   get: function(){\n *     Observation.add(this,\"name\");\n *     return name;\n *   },\n *   set: function(newVal) {\n *     var oldVal = name;\n *     name = newVal;\n *     this.dispatch(\"name\", newVal, oldVal);\n *   }\n * })\n * ```\n *\n * Next, create an observation instance with a function that reads the observable value:\n *\n * ```js\n * var observation = new Observation(function(){\n *   return \"Hello \"+me.name;\n * }, null, function(newVal, oldVal, batchNum){\n *   console.log(newVal);\n * })\n * ```\n *\n * Finally, call `observation.start()` to start listening and be notified of changes:\n *\n * ```js\n * observation.start();\n * observation.value   //-> \"Hello Justin\";\n * me.name = \"Ramiya\"; // console.logs -> \"Hello Ramiya\"\n * ```\n */\n\nfunction Observation(func, context, compute){\n\tthis.newObserved = {};\n\tthis.oldObserved = null;\n\tthis.func = func;\n\tthis.context = context;\n\tthis.compute = compute.updater ? compute : {updater: compute};\n\tthis.onDependencyChange = this.onDependencyChange.bind(this);\n\tthis.childDepths = {};\n\tthis.ignore = 0;\n\tthis.needsUpdate= false;\n}\n\n// ### observationStack\n//\n// This is the stack of all `observation` objects that are the result of\n// recursive `getValueAndBind` calls.\n// `getValueAndBind` can indirectly call itself anytime a compute reads another\n// compute.\n//\n// An `observation` entry looks like:\n//\n//     {\n//       observed: {\n//         \"map1|first\": {obj: map, event: \"first\"},\n//         \"map1|last\" : {obj: map, event: \"last\"}\n//       },\n//       names: \"map1|firstmap1|last\"\n//     }\n//\n// Where:\n// - `observed` is a map of `\"cid|event\"` to the observable and event.\n//   We use keys like `\"cid|event\"` to quickly identify if we have already observed this observable.\n// - `names` is all the keys so we can quickly tell if two observation objects are the same.\nvar observationStack = [];\n// expose the obseravation stack\nObservation.observationStack = observationStack;\n\nvar remaining = {updates: 0, notifications: 0};\n// expose the remaining state\nObservation.remaining = remaining;\n\nassign(Observation.prototype,{\n\t// something is reading the value of this compute\n\tget: function(){\n\t\tif(this.bound) {\n\t\t\t// Flush events so this compute should have been notified.\n\t\t\t// But we want not only update\n\t\t\tcanEvent.flush();\n\t\t\t// we've already got a value.  However, it might be possible that\n\t\t\t// something else is going to read this that has a lower \"depth\".\n\t\t\t// We might be updating, so we want to make sure that before we give\n\t\t\t// the outer compute a value, we've had a change to update.;\n\t\t\tif(remaining.updates) {\n\t\t\t\tObservation.updateChildrenAndSelf(this);\n\t\t\t}\n\n\n\t\t\treturn this.value;\n\t\t} else {\n\t\t\treturn this.func.call(this.context);\n\t\t}\n\t},\n\tgetPrimaryDepth: function() {\n\t\treturn this.compute._primaryDepth || 0;\n\t},\n\taddEdge: function(objEv){\n\t\tobjEv.obj.addEventListener(objEv.event, this.onDependencyChange);\n\t\tif(objEv.obj.observation) {\n\t\t\tthis.depth = null;\n\t\t}\n\t},\n\tremoveEdge: function(objEv){\n\t\tobjEv.obj.removeEventListener(objEv.event, this.onDependencyChange);\n\t\tif(objEv.obj.observation) {\n\t\t\tthis.depth = null;\n\t\t}\n\t},\n\tdependencyChange: function(ev){\n\t\tif(this.bound) {\n\t\t\t// Only need to register once per batchNum\n\t\t\tif(ev.batchNum !== this.batchNum) {\n\t\t\t\tObservation.registerUpdate(this, ev.batchNum);\n\t\t\t\tthis.batchNum = ev.batchNum;\n\t\t\t}\n\t\t}\n\t},\n\tonDependencyChange: function(ev, newVal, oldVal){\n\t\tthis.dependencyChange(ev, newVal, oldVal);\n\t},\n\tupdate: function(batchNum){\n\t\tif(this.needsUpdate) {\n\t\t\tremaining.updates--;\n\t\t}\n\t\tthis.needsUpdate = false;\n\t\tif(this.bound) {\n\t\t\t// Keep the old value.\n\t\t\tvar oldValue = this.value;\n\t\t\tthis.oldValue = null;\n\t\t\t// Get the new value and register this event handler to any new observables.\n\t\t\tthis.start();\n\t\t\tif(oldValue !== this.value) {\n\t\t\t\tthis.compute.updater(this.value, oldValue, batchNum);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t},\n\tgetValueAndBind: function() {\n\t\tcanLog.warn(\"can-observation: call start instead of getValueAndBind\");\n\t\treturn this.start();\n\t},\n\t// ## getValueAndBind\n\t// Calls `func` with \"this\" as `context` and binds to any observables that\n\t// `func` reads. When any of those observables change, `onchanged` is called.\n\t// `oldObservation` is A map of observable / event pairs this function used to be listening to.\n\t// Returns the `newInfo` set of listeners and the value `func` returned.\n\t/**\n\t * @function can-observation.prototype.start start\n\t * @parent can-observation.prototype prototype\n\t *\n\t * @signature `observation.start()`\n\t *\n\t * Starts observing changes and adds event listeners. [can-observation.prototype.value] will\n\t * be available.\n\t *\n\t */\n\tstart: function(){\n\t\tthis.bound = true;\n\t\tthis.oldObserved = this.newObserved || {};\n\t\tthis.ignore = 0;\n\t\tthis.newObserved = {};\n\n\t\t// Add this function call's observation to the stack,\n\t\t// runs the function, pops off the observation, and returns it.\n\n\t\tobservationStack.push(this);\n\t\tthis.value = this.func.call(this.context);\n\t\tobservationStack.pop();\n\t\tthis.updateBindings();\n\t},\n\t// ### updateBindings\n\t// Unbinds everything in `oldObserved`.\n\tupdateBindings: function(){\n\t\tvar newObserved = this.newObserved,\n\t\t\toldObserved = this.oldObserved,\n\t\t\tname,\n\t\t\tobEv;\n\n\t\tfor (name in newObserved) {\n\t\t\tobEv = newObserved[name];\n\t\t\tif(!oldObserved[name]) {\n\t\t\t\tthis.addEdge(obEv);\n\t\t\t} else {\n\t\t\t\toldObserved[name] = null;\n\t\t\t}\n\t\t}\n\t\tfor (name in oldObserved) {\n\t\t\tobEv = oldObserved[name];\n\t\t\tif(obEv) {\n\t\t\t\tthis.removeEdge(obEv);\n\t\t\t}\n\t\t}\n\t},\n\tteardown: function(){\n\t\tcanLog.warn(\"can-observation: call stop instead of teardown\");\n\t\treturn this.stop();\n\t},\n\t/**\n\t * @function can-observation.prototype.stop stop\n\t * @parent can-observation.prototype prototype\n\t *\n\t * @signature `observation.stop()`\n\t *\n\t * Stops observing changes and removes all event listeners.\n\t *\n\t */\n\tstop: function(){\n\t\t// track this because events can be in the queue.\n\t\tthis.bound = false;\n\t\tfor (var name in this.newObserved) {\n\t\t\tvar ob = this.newObserved[name];\n\t\t\tthis.removeEdge(ob);\n\t\t}\n\t\tthis.newObserved = {};\n\t}\n\t/**\n\t * @property {*} can-observation.prototype.value\n\t *\n\t * The return value of the function once [can-observation.prototype.start] is called.\n\t *\n\t */\n});\n\n/**\n * @typedef {{}} can-observation.observed Observed\n * @parent can-observation.types\n *\n * @description\n *\n * An object representing an observation.\n *\n * ```js\n * { \"obj\": map, \"event\": \"prop1\" }\n * ```\n *\n * @option {Object} obj The observable object\n * @option {String} event The event, or more likely property, that is being observed.\n */\n\n\nvar updateOrder = [],\n\t// the min registered primary depth, this is also the next to be executed.\n\tcurPrimaryDepth = Infinity,\n\t// the max registered primary depth\n\tmaxPrimaryDepth = 0,\n\tcurrentBatchNum,\n\tisUpdating = false;\n\n\nvar updateUpdateOrder = function(observation){\n\tvar primaryDepth = observation.getPrimaryDepth();\n\n\tif(primaryDepth < curPrimaryDepth) {\n\t\tcurPrimaryDepth = primaryDepth;\n\t}\n\tif(primaryDepth > maxPrimaryDepth) {\n\t\tmaxPrimaryDepth = primaryDepth;\n\t}\n\n\tvar primary = updateOrder[primaryDepth] ||\n\t\t(updateOrder[primaryDepth] = []);\n\n\n\treturn primary;\n};\n\nObservation.registerUpdate = function(observation, batchNum){\n\t// mark as needing an update\n\tif( observation.needsUpdate ) {\n\t\treturn;\n\t}\n\tremaining.updates++;\n\tobservation.needsUpdate = true;\n\n\tvar objs = updateUpdateOrder(observation);\n\n\tobjs.push(observation);\n};\n\n\n\n// This picks the observation with the smallest \"depth\" and\n// calls update on it (`currentObservation`).\n// If the `currentObservation` reads another observation with a higher depth (`deeperObservation`),\n// the `deeperObservation` will be updated (via `updateUntil`).\n// If the `currentObservation` reads another observation with a higher primary depth (`deeperPrimaryObservation`),\n// the `deeperPrimaryObservation` will be updated, but not have its callback called\nvar afterCallbacks = [];\n/* jshint maxdepth:7*/\nObservation.updateAndNotify = function(ev, batchNum){\n\tcurrentBatchNum = batchNum;\n\tif(isUpdating){\n\t\t// only allow access at one time to this method.\n\t\t// This is because when calling .update ... that compute should be only able\n\t\t// to cause updates to other computes it directly reads.  It's possible that\n\t\t// reading other computes could call `updateAndNotify` again.\n\t\t// If we didn't return, it's possible that other computes could update unrelated to the\n\t\t// execution flow of the current compute being updated.  This would be very unexpected.\n\t\treturn;\n\t}\n\tisUpdating = true;\n\twhile(true) {\n\t\tif( curPrimaryDepth <= maxPrimaryDepth ) {\n\t\t\tvar primary = updateOrder[curPrimaryDepth];\n\t\t\tvar lastUpdate = primary && primary.pop();\n\t\t\tif(lastUpdate) {\n\t\t\t\tlastUpdate.update(currentBatchNum);\n\t\t\t} else {\n\t\t\t\tcurPrimaryDepth++;\n\t\t\t}\n\t\t} else {\n\t\t\tupdateOrder = [];\n\t\t\tcurPrimaryDepth = Infinity;\n\t\t\tmaxPrimaryDepth = 0;\n\t\t\tisUpdating = false;\n\t\t\tvar afterCB = afterCallbacks;\n\t\t\tafterCallbacks = [];\n\t\t\tafterCB.forEach(function(cb){\n\t\t\t\tcb();\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t}\n};\ncanEvent.addEventListener.call(canBatch,\"batchEnd\", Observation.updateAndNotify);\n\nObservation.afterUpdateAndNotify = function(callback){\n\tcanBatch.after(function(){\n\t\t// here we know that the events have been fired, everything should\n\t\t// be notified. Now we have to wait until all computes have\n\t\t// finished firing.\n\t\tif(isUpdating) {\n\t\t\tafterCallbacks.push(callback);\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t});\n};\n\n\n// This is going to recursively check if there's any child compute\n// that .needsUpdate.\n// If there is, we'll update every parent on the way to ourselves.\nObservation.updateChildrenAndSelf = function(observation){\n\t// check if there's children that .needsUpdate\n\tif(observation.needsUpdate) {\n\t\treturn Observation.unregisterAndUpdate(observation);\n\t}\n\tvar childHasChanged;\n\tfor(var prop in observation.newObserved) {\n\t\tif(observation.newObserved[prop].obj.observation) {\n\t\t\tif( Observation.updateChildrenAndSelf(observation.newObserved[prop].obj.observation) ) {\n\t\t\t\tchildHasChanged = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(childHasChanged) {\n\t\treturn observation.update(currentBatchNum);\n\t}\n};\n// the problem with updateTo(observation)\n// is that that the read might never change\n// but the reader might be changing, and wont update itself, but something\n// else will\nObservation.unregisterAndUpdate = function(observation){\n\tvar primaryDepth = observation.getPrimaryDepth();\n\tvar primary = updateOrder[primaryDepth];\n\tif(primary) {\n\n\t\tvar index = primary.indexOf(observation);\n\t\tif(index !== -1) {\n\t\t\tprimary.splice(index,1);\n\t\t}\n\n\t}\n\treturn observation.update(currentBatchNum);\n};\n\n\n\n/**\n * @function can-observation.add add\n * @parent can-observation.static\n *\n * Signals that an object's property is being observed, so that any functions\n * that are recording observations will see that this object is a dependency.\n *\n * @signature `Observation.add(obj, event)`\n *\n * Signals that an event should be observed. Adds the observable being read to\n * the top of the stack.\n *\n * ```js\n * Observation.add(obj, \"prop1\");\n * ```\n *\n * @param {Object} obj An observable object which is being observed.\n * @param {String} event The name of the event (or property) that is being observed.\n *\n */\nObservation.add = function (obj, event) {\n\tvar top = observationStack[observationStack.length-1];\n\tif (top && !top.ignore) {\n\t\tvar evStr = event + \"\",\n\t\t\tname = obj._cid + '|' + evStr;\n\n\t\tif(top.traps) {\n\t\t\ttop.traps.push({obj: obj, event: evStr, name: name});\n\t\t}\n\t\telse {\n\t\t\ttop.newObserved[name] = {\n\t\t\t\tobj: obj,\n\t\t\t\tevent: evStr\n\t\t\t};\n\t\t}\n\t}\n};\n\n/**\n * @function can-observation.addAll addAll\n * @parent can-observation.static\n * @signature `Observation.addAll(observes)`\n *\n * The same as `Observation.add` but takes an array of [can-observation.observed] objects.\n * This will most often by used in coordination with [can-observation.trap]:\n *\n * ```js\n * var untrap = Observation.trap();\n *\n * Observation.add(obj, \"prop3\");\n *\n * var traps = untrap();\n * Oservation.addAll(traps);\n * ```\n *\n * @param {Array<can-observation.observed>} observes An array of [can-observation.observed]s.\n */\nObservation.addAll = function(observes){\n\t// a bit more optimized so we don't have to repeat everything in\n\t// Observation.add\n\tvar top = observationStack[observationStack.length-1];\n\tif (top) {\n\t\tif(top.traps) {\n\t\t\ttop.traps.push.apply(top.traps, observes);\n\t\t} else {\n\t\t\tfor(var i =0, len = observes.length; i < len; i++) {\n\t\t\t\tvar trap = observes[i],\n\t\t\t\t\tname = trap.name;\n\n\t\t\t\tif(!top.newObserved[name]) {\n\t\t\t\t\ttop.newObserved[name] = trap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n};\n\n/**\n * @function can-observation.ignore ignore\n * @parent can-observation.static\n * @signature `Observation.ignore(fn)`\n *\n * Creates a function that, when called, will prevent observations from\n * being applied.\n *\n * ```js\n * var fn = Observation.ignore(function(){\n *   // This will be ignored\n *   Observation.add(obj, \"prop1\");\n * });\n *\n * fn();\n * Observation.trapCount(); // -> 0\n * ```\n *\n * @param {Function} fn Any function that contains potential calls to\n * [Observation.add].\n *\n * @return {Function} A function that is free of observation side-effects.\n */\nObservation.ignore = function(fn){\n\treturn function(){\n\t\tif (observationStack.length) {\n\t\t\tvar top = observationStack[observationStack.length-1];\n\t\t\ttop.ignore++;\n\t\t\tvar res = fn.apply(this, arguments);\n\t\t\ttop.ignore--;\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn fn.apply(this, arguments);\n\t\t}\n\t};\n};\n\n\n/**\n * @function can-observation.trap trap\n * @parent can-observation.static\n * @signature `Observation.trap()`\n *\n * Trap all observations until the `untrap` function is called. The state of\n * traps prior to `Observation.trap()` will be restored when `untrap()` is called.\n *\n * ```js\n * var untrap = Observation.trap();\n *\n * Observation.add(obj, \"prop1\");\n *\n * var traps = untrap();\n * console.log(traps[0].obj === obj); // -> true\n * ```\n *\n * @return {can-observation.getTrapped} A function to get the trapped observations.\n */\nObservation.trap = function(){\n\tif (observationStack.length) {\n\t\tvar top = observationStack[observationStack.length-1];\n\t\tvar oldTraps = top.traps;\n\t\tvar traps = top.traps = [];\n\t\treturn function(){\n\t\t\ttop.traps = oldTraps;\n\t\t\treturn traps;\n\t\t};\n\t} else {\n\t\treturn function(){return [];};\n\t}\n};\n/**\n * @typedef {function} can-observation.getTrapped getTrapped\n * @parent can-observation.types\n *\n * @signature `getTrapped()`\n *\n *   Returns the trapped observables captured by [can-observation.trap].\n *\n *   @return {Array<can-observation.observed>}\n */\n\nObservation.trapsCount = function(){\n\tif (observationStack.length) {\n\t\tvar top = observationStack[observationStack.length-1];\n\t\treturn top.traps.length;\n\t} else {\n\t\treturn 0;\n\t}\n};\n// sets an array of observable notifications on the current top of the observe stack.\n\n/**\n * @function can-observation.isRecording isRecording\n * @parent can-observation.static\n * @signature `Observation.isRecording()`\n *\n * Returns if some function is in the process of recording observes.\n *\n * @return {Boolean} True if a function is in the process of recording observes.\n */\nObservation.isRecording = function(){\n\tvar len = observationStack.length;\n\tvar last = len && observationStack[len-1];\n\treturn last && (last.ignore === 0) && last;\n};\n\nif (namespace.Observation) {\n\tthrow new Error(\"You can't have two versions of can-observation, check your dependencies\");\n} else {\n\tmodule.exports = namespace.Observation = Observation;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-observation/can-observation.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nvar _document = require(\"../document/document\");\nvar isBrowserWindow = require(\"../../js/is-browser-window/is-browser-window\");\nvar isPlainObject = require(\"../../js/is-plain-object/is-plain-object\");\nvar fixSyntheticEventsOnDisabled = false;\n\nfunction isDispatchingOnDisabled(element, ev) {\n\tvar isInsertedOrRemoved = isPlainObject(ev) ? (ev.type === 'inserted' || ev.type === 'removed') : (ev === 'inserted' || ev === 'removed');\n\tvar isDisabled = !!element.disabled;\n\treturn isInsertedOrRemoved && isDisabled;\n}\n/**\n * @module {{}} can-util/dom/events/events events\n * @parent can-util/dom\n * @description Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents.\n *\n * ```js\n * var domEvents = require(\"can-util/dom/events/events\");\n * ```\n */\nmodule.exports = {\n\taddEventListener: function(){\n\t\tthis.addEventListener.apply(this, arguments);\n\t},\n\tremoveEventListener: function(){\n\t\tthis.removeEventListener.apply(this, arguments);\n\t},\n\tcanAddEventListener: function(){\n\t\treturn (this.nodeName && (this.nodeType === 1 || this.nodeType === 9)) || this === window;\n\t},\n\tdispatch: function(event, args, bubbles){\n\t\tvar ret;\n\t\tvar dispatchingOnDisabled = fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(this, event);\n\n\t\tvar doc = this.ownerDocument || _document();\n\t\tvar ev = doc.createEvent('HTMLEvents');\n\t\tvar isString = typeof event === \"string\";\n\n\t\t// removed / inserted events should not bubble\n\t\tev.initEvent(isString ? event : event.type, bubbles === undefined ? true : bubbles, false);\n\n\t\tif(!isString) {\n\t\t\tfor (var prop in event) {\n\t\t\t\tif (ev[prop] === undefined) {\n\t\t\t\t\tev[prop] = event[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tev.args = args;\n\t\tif(dispatchingOnDisabled) {\n\t\t\tthis.disabled = false;\n\t\t}\n\t\tret = this.dispatchEvent(ev);\n\t\tif(dispatchingOnDisabled) {\n\t\t\tthis.disabled = true;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n// In FireFox, dispatching a synthetic event on a disabled element throws an error.\n// Other browsers, like IE 10 do not dispatch synthetic events on disabled elements at all.\n// This determines if we have to work around that when dispatching events.\n// https://bugzilla.mozilla.org/show_bug.cgi?id=329509\n(function() {\n\tif(!isBrowserWindow()) {\n\t\treturn;\n\t}\n\n\tvar testEventName = 'fix_synthetic_events_on_disabled_test';\n\tvar input = document.createElement(\"input\");\n\tinput.disabled = true;\n\tvar timer = setTimeout(function() {\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}, 50);\n\tvar onTest = function onTest (){\n\t\tclearTimeout(timer);\n\t\tmodule.exports.removeEventListener.call(input, testEventName, onTest);\n\t};\n\tmodule.exports.addEventListener.call(input, testEventName, onTest);\n\ttry {\n\t\tmodule.exports.dispatch.call(input, testEventName, [], false);\n\t} catch(e) {\n\t\tonTest();\n\t\tfixSyntheticEventsOnDisabled = true;\n\t}\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/events.js\n// module id = 8\n// module chunks = 0","/* jshint maxdepth:7*/\n\n// # can.compute\n//\n// `can.compute` allows the creation of observable values in different forms.\n// This module is now just a facade around [proto_compute.js](proto_compute.html).\n// `proto_compute.js` provides `can.Compute` as a constructor function where this file,\n// `compute.js` wraps an instance of a `can.Compute` with a function.\n//\n// Other files:\n// - [get_value_and_bind.js](get_value_and_bind.js) provides the low-level utility for observing functions.\n// - [read.js](read.html) provides a helper that read properties and values in an observable way.\n\n\nrequire('can-event');\nrequire('can-event/batch/batch');\n\nvar Compute = require('./proto-compute');\nvar CID = require('can-cid');\nvar namespace = require('can-namespace');\n\n// The `can.compute` generator function.\n\n\nvar addEventListener = function(ev, handler){\n\tvar compute = this;\n\tvar computeHandler = handler && handler[compute.handlerKey];\n\tif(handler && !computeHandler) {\n\t\tcomputeHandler = handler[compute.handlerKey] = function() {\n\t\t\thandler.apply(compute, arguments);\n\t\t};\n\t}\n\n\treturn compute.computeInstance.addEventListener(ev, computeHandler);\n};\n\nvar removeEventListener = function(ev, handler){\n\tvar compute = this;\n\n\tvar computeHandler = handler && handler[compute.handlerKey];\n\n\tif(computeHandler) {\n\t\tdelete handler[compute.handlerKey];\n\t\treturn compute.computeInstance.removeEventListener(ev, computeHandler);\n\t}\n\treturn compute.computeInstance.removeEventListener.apply(compute.computeInstance, arguments);\n};\n\n\nvar COMPUTE = function (getterSetter, context, eventName, bindOnce) {\n\n\tfunction compute(val) {\n\t\tif(arguments.length) {\n\t\t\treturn compute.computeInstance.set(val);\n\t\t}\n\n\t\treturn compute.computeInstance.get();\n\t}\n\tvar cid = CID(compute, 'compute');\n\n\t// Create an internal `can.Compute`.\n\tcompute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);\n\n\tcompute.handlerKey = '__handler' + cid;\n\tcompute.on = compute.bind = compute.addEventListener = addEventListener;\n\tcompute.off = compute.unbind = compute.removeEventListener = removeEventListener;\n\n\tcompute.isComputed = compute.computeInstance.isComputed;\n\n\tcompute.clone = function(ctx) {\n\t\tif(typeof getterSetter === 'function') {\n\t\t\tcontext = ctx;\n\t\t}\n\t\treturn COMPUTE(getterSetter, context, ctx, bindOnce);\n\t};\n\n\treturn compute;\n};\n\n// ## Helpers\n\n// ### truthy\n// Wraps a compute with another compute that only changes when\n// the wrapped compute's `truthiness` changes.\nCOMPUTE.truthy = function (compute) {\n\treturn COMPUTE(function () {\n\t\tvar res = compute();\n\t\treturn !!res;\n\t});\n};\n\n// ### async\n// A simple helper that makes an async compute a bit easier.\nCOMPUTE.async = function(initialValue, asyncComputer, context){\n\treturn COMPUTE(initialValue, {\n\t\tfn: asyncComputer,\n\t\tcontext: context\n\t});\n};\n\n// ### compatability\n// Setting methods that should not be around in 3.0.\nCOMPUTE.temporarilyBind = Compute.temporarilyBind;\n\nmodule.exports = namespace.compute = COMPUTE;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-compute/can-compute.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nvar domDataCore = require(\"./core\");\nvar mutationDocument = require(\"../mutation-observer/document/document\");\n\nvar deleteNode = function() {\n\treturn domDataCore.delete.call(this);\n};\n\n// count of distinct elements that have domData set\nvar elementSetCount = 0;\n\nvar cleanupDomData = function(node) {\n\t// decrement count if node was deleted\n\telementSetCount -= deleteNode.call(node) ? 1 : 0;\n\n\t// remove handler once all domData has been cleaned up\n\tif (elementSetCount === 0) {\n\t\tmutationDocument.offAfterRemovedNodes(cleanupDomData);\n\t}\n};\n\n/**\n * @module {{}} can-util/dom/data/data data\n * @parent can-util/dom\n * @description Allows associating data as a key/value pair for a particular\n * DOM Node.\n *\n * ```js\n * var domData = require(\"can-util/dom/data/data\");\n * ```\n */\nmodule.exports = {\n\t/**\n\t * @function can-util/dom/data/data.getCid domData.getCid\n\t * @signature `domData.getCid.call(el)`\n\t * @return {Number} The value of the element's unique CID\n\t *\n\t * Return the previously set unique identifier for the dom node.\n\t */\n\tgetCid: domDataCore.getCid,\n\t/**\n\t * @function can-util/dom/data/data.cid domData.cid\n\t * @signature `domData.cid.call(el)`\n\t * @return {Number} The value of the element's unique CID\n\t *\n\t * Set a unique identifier for the dom node, using the\n\t * [can-util/dom/data/data.expando expando] property.\n\t *\n\t * @body\n\t *\n\t * If a unique cid value has not yet been set for this element, set it\n\t * using the [can-util/dom/data/data.expando expando] property.  Return the\n\t * unique cid whether or not it is newly set\n\t */\n\tcid: domDataCore.cid,\n\t/**\n\t * @property can-util/dom/data/data.expando domData.expando\n\t * @type {String}\n\t *\n\t * The key in which elements' cids are stored\n\t */\n\texpando: domDataCore.expando,\n\t/**\n\t * @function can-util/dom/data/data.clean domData.clean\n\t * @param  {String} prop the property to remove from the element's data\n\t * @signature `domData.clean.call(el, key)`\n\t *\n\t * Remove data from an element previously added by [can-util/dom/data/data.set set]\n\t *\n\t * ```js\n\t * var domData = require(\"can-util/dom/data/data\");\n\t * \n\t * domData.clean.call(el, \"metadata\");\n\t * ```\n\t */\n\tclean: domDataCore.clean,\n\t/**\n\t * @function can-util/dom/data/data.get domData.get\n\t * @signature `domData.get.call(el, key)`\n\t *\n\t * Get data that was stored in a DOM Node using the specified `key`.\n\t *\n\t * ```js\n\t * var domData = require(\"can-util/dom/data/data\");\n\t * \n\t * var metadata = domData.get.call(el, \"metadata\");\n\t * ```\n\t *\n\t * @param {String} key A string used as a unique key for storing data associated with this DOM Node.\n\t */\n\tget: domDataCore.get,\n\t/**\n\t * @function can-util/dom/data/data.set domData.set\n\t * @signature `domData.set.call(el, name, value)`\n\t *\n\t * @param {String} name the key to store the value under\n\t * @param {*} value     the value to store under the key\n\t *\n\t * Set data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\t *\n\t * ```js\n\t * var domData = require(\"can-util/dom/data/data\");\n\t * \n\t * domData.set.call(el, \"metadata\", {\n\t *   foo: \"bar\"\n\t * });\n\t * ```\n\t */\n\tset: function(name, value) {\n\t\t// set up handler to clean up domData when elements are removed\n\t\t// handler only needs to be set up the first time set is called\n\t\tif (elementSetCount === 0) {\n\t\t\tmutationDocument.onAfterRemovedNodes(cleanupDomData);\n\t\t}\n\t\t// increment elementSetCount if set returns true\n\t\telementSetCount += domDataCore.set.call(this, name, value) ? 1 : 0;\n\t},\n\t/**\n\t * @function can-util/dom/data/data.delete domData.delete\n\t * @signature `domData.delete.call(el)`\n\t *\n\t * Remove all data for an element previously added by [can-util/dom/data/data.set set]\n\t *\n\t * ```js\n\t * var domData = require(\"can-util/dom/data/data\");\n\t * \n\t * domData.delete.call(el);\n\t * ```\n\t */\n\tdelete: deleteNode\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/data/data.js\n// module id = 10\n// module chunks = 0","\"use strict\";\n// # can-event/batch/\n// Adds task batching abilities to event dispatching.\n// Provides a `queue` method to add batched work.\n// Overwrites `event.dispatch` to use the task queue when dispatching events.\n// Provides a `start` and `stop` method used to a queue.\n// Provides `collecting` which returns the queue collecting tasks.\n// Provides `dispatching` which returns the queue dispatching tasks.\n// Dispatches `batchEnd` when a queue's tasks have been completed.\n\nvar canEvent = require('../can-event');\nvar last = require('can-util/js/last/last');\nvar namespace = require('can-namespace');\nvar canTypes = require(\"can-types\");\nvar canDev = require(\"can-util/js/dev/dev\");\nvar canLog = require(\"can-util/js/log/log\");\n\n//!steal-remove-start\nvar group = console.group && console.group.bind(console) || canLog.log;\nvar groupEnd = console.groupEnd && console.groupEnd.bind(console) || function() {};\n//!steal-remove-end\n\n// Which batch of events this is for -- might not want to send multiple\n// messages on the same batch.  This is mostly for event delegation.\nvar batchNum = 1,\n\tcollectionQueue = null,\n\tqueues = [],\n\tdispatchingQueues = false,\n\tmakeHandlerArgs = canEvent.makeHandlerArgs,\n\tgetHandlers = canEvent.handlers;\n\nfunction addToCollectionQueue(item, event, args, handlers){\n\tvar handlerArgs = makeHandlerArgs(event, args);\n\tvar tasks = [];\n\tfor(var i = 0, len = handlers.length; i < len; i++) {\n\t\ttasks[i] = [handlers[i], item, handlerArgs];\n\t}\n\n\t[].push.apply(collectionQueue.tasks,tasks);\n}\n\n\nvar canBatch = {\n\t// how many times has start been called without a stop\n\ttransactions: 0,\n\t/**\n\t * @function can-event/batch/batch.start start\n\t * @parent can-event/batch/batch\n\t * @description Begin an event batch.\n\t *\n\t * @signature `canBatch.start([batchStopHandler])`\n\t *\n\t * @param {Function} [batchStopHandler] a callback that gets called after all batched events have been called.\n\t *\n\t * @body\n\t * `canBatch.start` begins an event batch. Until `[can-event/batch/batch.stop]` is called, any\n\t * events that would result from calls to [can-event/batch/batch.trigger] to are held back from firing. If you have\n\t * lots of changes to make to observables, batching them together can help performance - especially if\n\t * those observables are live-bound to the DOM.\n\t *\n\t * In this example, you can see how the _first_ event is not fired (and their handlers\n\t * are not called) until `canBatch.stop` is called.\n\t *\n\t * ```\n\t * var person = new DefineMap({\n\t *     first: 'Alexis',\n\t *     last: 'Abril'\n\t * });\n\t *\n\t * person.on('first', function() {\n\t *     console.log(\"First name changed.\");\n\t * }).on('last', function() {\n\t *     console.log(\"Last name changed.\");\n\t * });\n\t *\n\t * canBatch.start();\n\t * person.first = 'Alex';\n\t * console.log('Still in the batch.');\n\t * canBatch.stop();\n\t *\n\t * // the log has:\n\t * // Still in the batch.\n\t * // First name changed.\n\t * ```\n\t *\n\t * You can also pass a callback to `canBatch.start` which will be called after all the events have\n\t * been fired:\n\t *\n\t * ```\n\t * canBatch.start(function() {\n\t *     console.log('The batch is over.');\n\t * });\n\t * person.first = \"Izzy\"\n\t * console.log('Still in the batch.');\n\t * canBatch.stop();\n\t *\n\t * // The console has:\n\t * // Still in the batch.\n\t * // First name changed.\n\t * // The batch is over.\n\t * ```\n\t *\n\t * ## Calling `canBatch.start` multiple times\n\t *\n\t * If you call `canBatch.start` more than once, `canBatch.stop` needs to be called\n\t * the same number of times before any batched events will fire. For ways\n\t * to circumvent this process, see [can-event/batch/batch.stop].\n\t *\n\t * Here is an example that demonstrates how events are affected by calling\n\t * `canBatch.start` multiple times.\n\t *\n\t * ```\n\t * var Todo = DefineMap.extend({\n\t *   completed: \"boolean\",\n\t *   name: \"string\"\n\t *   updatedAt: \"date\",\n\t *   complete: function(){\n\t *     canBatch.start();\n\t *     this.completed = true;\n\t *     this.updatedAt = new Date();\n\t *     canBatch.end();\n\t *   }\n\t * });\n\t *\n\t * Todo.List = DefineList.extend({\n\t *   \"#\": Todo,\n\t *   completeAll: function(){\n\t *     this.forEach(function(todo){\n\t *       todo.complete();\n\t *     });\n\t *   }\n\t * });\n\t *\n\t * var todos = new Todo.List([\n\t *   {name: \"dishes\", completed: false},\n\t *   {name: \"lawn\", completed: false}\n\t * ]);\n\t *\n\t * todos[0].on(\"completed\", function(ev){\n\t *   console.log(\"todos[0] \"+ev.batchNum);\n\t * })\n\t * todos[1].on(\"completed\", function(ev){\n\t *   console.log(\"todos[1] \"+ev.batchNum);\n\t * });\n\t *\n\t * todos.completeAll();\n\t * // console.logs ->\n\t * //        todos[0] 1\n\t * //        todos[1] 1\n\t * ```\n\t */\n\tstart: function (batchStopHandler) {\n\t\tcanBatch.transactions++;\n\t\tif(canBatch.transactions === 1) {\n\t\t\tvar queue = {\n\t\t\t\t// the batch number\n\t\t\t\tnumber: batchNum++,\n\n\t\t\t\t// where are we in the task queue\n\t\t\t\tindex: 0,\n\t\t\t\ttasks: [],\n\n\t\t\t\t// the batch end event has fired\n\t\t\t\tbatchEnded: false,\n\n\t\t\t\t// where are we in the post-batch queue\n\t\t\t\tcallbacksIndex: 0,\n\t\t\t\tcallbacks: [],\n\n\t\t\t\t// if everything this batch can do has been done\n\t\t\t\tcomplete: false\n\t\t\t};\n\n\t\t\tif (batchStopHandler) {\n\t\t\t\tqueue.callbacks.push(batchStopHandler);\n\t\t\t}\n\t\t\tcollectionQueue = queue;\n\t\t}\n\n\t},\n\t/**\n\t * @function can-event/batch/batch.collecting collecting\n\t * @parent can-event/batch/batch\n\t *\n\t * @signature `batch.collecting()`\n\t *\n\t * Returns the Queue that is currently collecting tasks.\n\t *\n\t * ```\n\t * batch.start();\n\t * batch.collecting() //-> Queue\n\t *\n\t * batch.stop();\n\t * batch.collecting() //-> null\n\t * ```\n\t *\n\t * @return {can-event/batch/Queue} The queue currently collecting tasks.\n\t */\n\tcollecting: function(){\n\t\treturn collectionQueue;\n\t},\n\t/**\n\t * @function can-event/batch/batch.dispatching dispatching\n\t * @parent can-event/batch/batch\n\t *\n\t * @signature `batch.dispatching()`\n\t *\n\t * Returns the Queue that is executing tasks.\n\t *\n\t * ```\n\t * var canEvent = require(\"can-event\");\n\t * var batch = require(\"can-event/batch/batch\");\n\t *\n\t *\n\t * var obj = Object.assign({}, canEvent);\n\t *\n\t *\n\t *\n\t * batch.start();\n\t * obj.dispatch(\"first\");\n\t * batch.stop();\n\t * ```\n\t *\n\t * @return {can-event/batch/Queue} The queue currently executing tasks.\n\t */\n\tdispatching: function(){\n\t\treturn queues[0];\n\t},\n\t/**\n\t * @function can-event/batch/batch.stop stop\n\t * @parent can-event/batch/batch\n\t * @description End an event batch.\n\t *\n\t * @signature `canBatch.stop([force[, callStart]])`\n\t *\n\t * If this call to `stop` matches the number of calls to `start`, all of this batch's [can-event/batch/batch.trigger triggered]\n\t * events will be dispatched.  If the firing of those events creates new events, those new events will be dispatched\n\t * after the current batch in their own batch.\n\t *\n\t * @param {bool} [force=false] Whether to stop batching events immediately.\n\t * @param {bool} [callStart=false] Whether to call [can-event/batch/batch.start] after firing batched events.\n\t *\n\t * @body\n\t *\n\t * `canBatch.stop` matches an earlier `[can-event/batch/batch.start]` call. If `canBatch.stop` has been\n\t * called as many times as `canBatch.start` (or if _force_ is true), all batched events will be\n\t * fired and any callbacks passed to `canBatch.start` since the beginning of the batch will be\n\t * called. If _force_ and _callStart_ are both true, a new batch will be started when all\n\t * the events and callbacks have been fired.\n\t *\n\t * See `[can-event/batch/batch.start]` for examples of `canBatch.start` and `canBatch.stop` in normal use.\n\t *\n\t */\n\tstop: function (force, callStart) {\n\t\tif (force) {\n\t\t\tcanBatch.transactions = 0;\n\t\t} else {\n\t\t\tcanBatch.transactions--;\n\t\t}\n\t\tif (canBatch.transactions === 0) {\n\t\t\tqueues.push(collectionQueue);\n\t\t\tcollectionQueue = null;\n\t\t\tif(!dispatchingQueues) {\n\t\t\t\tcanEvent.flush();\n\t\t\t}\n\t\t}\n\t},\n\t// Flushes the current\n\tflush: function() {\n\t\t//!steal-remove-start\n\t\tvar debug = canDev.logLevel >= 1;\n\t\t//!steal-remove-end\n\n\t\tdispatchingQueues = true;\n\t\twhile(queues.length) {\n\t\t\tvar queue = queues[0];\n\t\t\tvar tasks = queue.tasks,\n\t\t\t\tcallbacks = queue.callbacks;\n\n\t\t\tcanBatch.batchNum = queue.number;\n\n\t\t\tvar len = tasks.length;\n\n\t\t\t//!steal-remove-start\n\t\t\tif(debug && queue.index === 0 && queue.index < len) {\n\t\t\t\tgroup(\"batch running \"+queue.number);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\twhile(queue.index < len) {\n\t\t\t\tvar task = tasks[queue.index++];\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(debug) {\n\t\t\t\t\tvar context = task[1];\n\t\t\t\t\tvar args = task[2];\n\t\t\t\t\tif(args && args[0]) {\n\t\t\t\t\t\tcanLog.log(\"dispatching\", args[0].type, \"on\", context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\ttask[0].apply(task[1], task[2]);\n\t\t\t}\n\n\t\t\tif(!queue.batchEnded) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(debug) {\n\t\t\t\t\tcanLog.log(\"tasks ended\");\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tqueue.batchEnded = true;\n\t\t\t\tcanEvent.dispatchSync.call(canBatch,\"batchEnd\",[queue.number]);\n\t\t\t}\n\n\t\t\t//!steal-remove-start\n\t\t\tif(debug && queue.callbacksIndex < callbacks.length) {\n\t\t\t\tcanLog.log(\"calling callbacks\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\twhile(queue.callbacksIndex < callbacks.length) {\n\t\t\t\tcallbacks[queue.callbacksIndex++]();\n\t\t\t}\n\n\n\t\t\tif(!queue.complete) {\n\t\t\t\tqueue.complete = true;\n\t\t\t\tcanBatch.batchNum = undefined;\n\t\t\t\tqueues.shift();\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(debug) {\n\t\t\t\t\tgroupEnd();\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t}\n\n\t\t}\n\t\tdispatchingQueues = false;\n\t},\n\t/**\n\t * @function can-event/batch/batch.dispatch dispatch\n\t * @parent can-event/batch/batch\n\t * @description Dispatchs an event within the event batching system.\n\t * @signature `canBatch.trigger(item, event [, args])`\n\t *\n\t * Makes sure an event is fired at the appropriate time within the appropriate batch.\n\t * How and when the event fires depends on the batching state.\n\t *\n\t * There are three states of batching:\n\t *\n\t * - no queues - `trigger` is called outside of any `start` or `stop` call -> The event is dispatched immediately.\n\t * - collecting batch - `trigger` is called between a `start` or `stop` call -> The event is dispatched when `stop` is called.\n\t * - firing queues -  `trigger` is called due to another `trigger` called within a batch -> The event is dispatched after the current batch has completed in a new batch.\n\t *\n\t * Finally, if the event has a `batchNum` it is fired immediately.\n\t *\n\t * @param {Object} item the target of the event.\n\t * @param {String|{type: String}} event the type of event, or an event object with a type given like `{type: 'name'}`\n\t * @param {Array} [args] the parameters to trigger the event with.\n\t *\n\t * @body\n\t *\n\t */\n\tdispatch: function (event, args) {\n\t\t//!steal-remove-start\n\t\tif (arguments.length > 2) {\n\t\t\tcanDev.warn('Arguments to dispatch should be an array, not multiple arguments.');\n\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t}\n\n\t\tif (args && !Array.isArray(args)) {\n\t\t\tcanDev.warn('Arguments to dispatch should be an array.');\n\t\t\targs = [ args ];\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar item = this,\n\t\t\thandlers;\n\t\t// Don't send events if initalizing.\n\t\tif (!item.__inSetup) {\n\t\t\tevent = typeof event === 'string' ? {\n\t\t\t\ttype: event\n\t\t\t} : event;\n\n\t\t\t// If this is trying to belong to another batch, let it fire\n\t\t\tif(event.batchNum) {\n\t\t\t\t// It's a possibility we want to add this to the\n\t\t\t\t// end of the tasks if they haven't completed yet.\n\t\t\t\tcanBatch.batchNum = event.batchNum;\n\t\t\t\tcanEvent.dispatchSync.call( item, event, args );\n\t\t\t}\n\t\t\t// if there's a batch, add it to this queues events\n\t\t\telse if(collectionQueue) {\n\n\t\t\t\thandlers = getHandlers.call(this, event.type);\n\t\t\t\tif(handlers) {\n\t\t\t\t\tevent.batchNum = collectionQueue.number;\n\t\t\t\t\taddToCollectionQueue(item, event, args, handlers);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if there are queues, but this doesn't belong to a batch\n\t\t\t// add it to its own batch fired at the end\n\t\t\telse if(queues.length) {\n\t\t\t\t// start a batch so it can be colllected.\n\t\t\t\t// this should never hit in async\n\t\t\t\thandlers = getHandlers.call(this, event.type);\n\t\t\t\tif(handlers) {\n\t\t\t\t\tcanBatch.start();\n\t\t\t\t\tevent.batchNum = collectionQueue.number;\n\t\t\t\t\taddToCollectionQueue(item, event, args, handlers);\n\t\t\t\t\tlast(queues).callbacks.push(canBatch.stop);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\t// there are no queues, so just fire the event.\n\t\t\telse {\n\t\t\t\thandlers = getHandlers.call(this, event.type);\n\t\t\t\tif(handlers) {\n\t\t\t\t\tcanBatch.start();\n\t\t\t\t\tevent.batchNum = collectionQueue.number;\n\t\t\t\t\taddToCollectionQueue(item, event, args, handlers);\n\t\t\t\t\tcanBatch.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function can-event/batch/batch.queue queue\n\t * @parent can-event/batch/batch\n\t * @description Queues a method to be called.\n\t *\n\t * @signature `batch.queue(task)`\n\t *\n\t * Queues a method to be called in the current [can-event/batch/batch.collecting]\n\t * queue if there is one.  If there is a [can-event/batch/batch.dispatching] queue,\n\t * it will create a batch and add the task to that batch.\n\t * Finally, if there is no batch, the task will be executed immediately.\n\t *\n\t * ```\n\t * var me = {\n\t *   say: function(message){\n\t *     console.log(this.name,\"says\", message);\n\t *   }\n\t * }\n\t * batch.queue([me.say, me, [\"hi\"]]);\n\t * ```\n\t *\n\t * @param  {Array<function,*,Array>} task An array that details a\n\t * function to be called, the context the function should be called with, and\n\t * the arguments to the function like: `[function,context, [arg1, arg2]]`\n\t */\n\tqueue: function(task, inCurrentBatch){\n\t\tif(collectionQueue) {\n\t\t\tcollectionQueue.tasks.push(task);\n\t\t}\n\t\t// if there are queues, but this doesn't belong to a batch\n\t\t// add it to its own batch\n\t\telse if(queues.length) {\n\t\t\tif(inCurrentBatch && queues[0].index < queues.tasks.length) {\n\t\t\t\tqueues[0].tasks.push(task);\n\t\t\t} else {\n\t\t\t\tcanBatch.start();\n\t\t\t\tcollectionQueue.tasks.push(task);\n\t\t\t\tlast(queues).callbacks.push(canBatch.stop);\n\t\t\t}\n\t\t}\n\t\t// there are no queues, so create one and run it.\n\t\telse {\n\t\t\tcanBatch.start();\n\t\t\tcollectionQueue.tasks.push(task);\n\t\t\tcanBatch.stop();\n\t\t}\n\t},\n\tqueues: function(){\n\t\treturn queues;\n\t},\n\t/**\n\t * @function can-event/batch/batch.afterPreviousEvents afterPreviousEvents\n\t * @parent can-event/batch/batch\n\t * @description Run code when all previuos state has settled.\n\t *\n\t * @signature `canBatch.afterPreviousEvents(handler)`\n\t *\n\t * Calls `handler` when all previously [can-event/batch/batch.trigger triggered] events have\n\t * been fired.  This is useful to know when all fired events match the current state.\n\t *\n\t * @param {function} handler A function to call back when all previous events have fired.\n\t *\n\t * @body\n\t *\n\t *\n\t * ## Use\n\t *\n\t * With batching, it's possible for a piece of code to read some observable, and listen to\n\t * changes in that observable, but have events fired that it should ignore.\n\t *\n\t * For example, consider a list widget that creates `<li>`'s for each item in the list and listens to\n\t * updates in that list and adds or removes `<li>`s:\n\t *\n\t * ```js\n\t * var makeLi = function(){\n\t *   return document.createElement(\"li\")\n\t * };\n\t *\n\t * var listWidget = function(list){\n\t *   var lis = list.map(makeLi);\n\t *   list.on(\"add\", function(ev, added, index){\n\t *     var newLis = added.map(makeLi);\n\t *     lis.splice.apply(lis, [index, 0].concat(newLis) );\n\t *   }).on(\"remove\", function(ev, removed, index){\n\t *     lis.splice(index, removed.length);\n\t *   });\n\t *\n\t *   return lis;\n\t * }\n\t * ```\n\t *\n\t * The problem with this is if someone calls `listWidget` within a batch:\n\t *\n\t * ```js\n\t * var list = new DefineList([]);\n\t *\n\t * canBatch.start();\n\t * list.push(\"can-event\",\"can-event/batch/\");\n\t * listWidget(list);\n\t * canBatch.stop();\n\t * ```\n\t *\n\t * The problem is that list will immediately create an `li` for both `can-event` and `can-event/batch/`, and then,\n\t * when `canBatch.stop()` is called, the `add` event listener will create duplicate `li`s.\n\t *\n\t * The solution, is to use `afterPreviousEvents`:\n\t *\n\t * ```js\n\t * var makeLi = function(){\n\t *   return document.createElement(\"li\")\n\t * };\n\t *\n\t * var listWidget = function(list){\n\t *   var lis = list.map(makeLi);\n\t *   canBatch.afterPreviousEvents(function(){\n\t *     list.on(\"add\", function(ev, added, index){\n\t *       var newLis = added.map(makeLi);\n\t *       lis.splice.apply(lis, [index, 0].concat(newLis) );\n\t *     }).on(\"remove\", function(ev, removed, index){\n\t *       lis.splice(index, removed.length);\n\t *     });\n\t *   });\n\t *\n\t *   return lis;\n\t * }\n\t * ```\n\t *\n\t */\n\t// call handler after any events from currently settled stated have fired\n\t// but before any future change events fire.\n\tafterPreviousEvents: function(handler){\n\t\tthis.queue([handler]);\n\t},\n\tafter: function(handler){\n\t\tvar queue = collectionQueue || queues[0];\n\n\t\tif(queue) {\n\t\t\tqueue.callbacks.push(handler);\n\t\t} else {\n\t\t\thandler({});\n\t\t}\n\t}\n};\n\n\ncanEvent.flush = canBatch.flush;\ncanEvent.dispatch = canBatch.dispatch;\n\ncanBatch.trigger = function(){\n\tcanLog.warn(\"use canEvent.dispatch instead\");\n\treturn canEvent.dispatch.apply(this, arguments);\n};\n\ncanTypes.queueTask = canBatch.queue;\n\nif (namespace.batch) {\n\tthrow new Error(\"You can't have two versions of can-event/batch/batch, check your dependencies\");\n} else {\n\tmodule.exports = namespace.batch = canBatch;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-event/batch/batch.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nvar each = require('../each/each');\nvar isArrayLike = require('../is-array-like/is-array-like');\n\n/**\n * @module {function} can-util/js/make-array/make-array make-array\n * @parent can-util/js\n * @signature `makeArray(element)`\n * @param  {ArrayLike|Object} element any array-like or object data structure\n * @return {Array}     a JavaScript array object with the same elements as the passed-in ArrayLike\n *\n * makeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n * \n * ```\n * var makeArray = require(\"can-util/js/make-array/make-array\");\n * \n * makeArray({0: \"a\", length: 1}); //-> [\"a\"]\n * \n * ```\n */\nfunction makeArray(element) {\n\tvar ret = [];\n\tif (isArrayLike(element)) {\n\t\teach(element, function (a, i) {\n\t\t\tret[i] = a;\n\t\t});\n\t} else if(element === 0 || element) {\n\t\tret.push(element);\n\t}\n\treturn ret;\n}\n\nmodule.exports = makeArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/make-array/make-array.js\n// module id = 12\n// module chunks = 0","'use strict';\n\n/**\n * @module {function} can-util/js/global/global global\n * @parent can-util/js\n * @signature `GLOBAL()`\n *\n * Returns the global that this environment provides. It will be one of:\n *\n * * **Browser**: `window`\n * * **Web Worker**: `self`\n * * **Node.js**: `global`\n *\n * ```js\n * var GLOBAL = require(\"can-util/js/global/global\");\n *\n * var g = GLOBAL();\n *\n * // In a browser\n * console.log(g === window); // -> true\n * ```\n *\n * @return {Object} The global object for this JavaScript environment.\n */\n\n/* global self */\n/* global WorkerGlobalScope */\nvar GLOBAL;\nmodule.exports = function(setGlobal){\n\t// Web Worker\n\tif(setGlobal !== undefined) {\n\t\tGLOBAL = setGlobal;\n\t}\n\tif(GLOBAL) {\n\t\treturn GLOBAL;\n\t} else {\n\t\treturn GLOBAL = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self :\n\n\t\t\t// Node.js\n\t\t\ttypeof process === \"object\" &&\n\t\t\t{}.toString.call(process) === \"[object process]\" ? global :\n\n\t\t\t// Browser window\n\t\t\twindow;\n\t}\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/global/global.js\n// module id = 13\n// module chunks = 0","var namespace = require('can-namespace');\n/**\n * @module {function} can-cid\n * @parent can-infrastructure\n * @signature `cid(object, optionalObjectType)`\n *\n * Get a unique identifier for the object, optionally prefixed by a type name.\n *\n * Once set, the unique identifier does not change, even if the type name\n * changes on subsequent calls.\n *\n * ```js\n * var cid = require(\"can-cid\");\n * var x = {};\n * var y = {};\n *\n * console.log(cid(x, \"demo\")); // -> \"demo1\"\n * console.log(cid(x, \"prod\")); // -> \"demo1\"\n * console.log(cid(y));         // -> \"2\"\n * ```\n *\n * @param {Object} object The object to uniquely identify.\n * @param {String} name   An optional type name with which to prefix the identifier\n *\n * @return {String} Returns the unique identifier\n */\nvar _cid = 0;\nvar cid = function (object, name) {\n\tif (!object._cid) {\n\t\t_cid++;\n\t\tobject._cid = (name || '') + _cid;\n\t}\n\treturn object._cid;\n};\n\nif (namespace.cid) {\n\tthrow new Error(\"You can't have two versions of can-cid, check your dependencies\");\n} else {\n\tmodule.exports = namespace.cid = cid;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-cid/can-cid.js\n// module id = 14\n// module chunks = 0","var Observation = require('can-observation');\nvar assign = require('can-util/js/assign/assign');\nvar CID = require('can-cid');\nvar types = require('can-types');\nvar dev = require('can-util/js/dev/dev');\nvar canEvent = require('can-event');\nvar each = require('can-util/js/each/each');\nvar isPromiseLike = require('can-util/js/is-promise-like/is-promise-like');\n\nvar observeReader;\nvar isAt = function(index, reads) {\n\tvar prevRead = reads[index-1];\n\treturn prevRead && prevRead.at;\n};\n\nvar readValue = function(value, index, reads, options, state, prev){\n\t// if the previous read is AT false ... we shouldn't be doing this;\n\tvar usedValueReader;\n\tdo {\n\n\t\tusedValueReader = false;\n\t\tfor(var i =0, len = observeReader.valueReaders.length; i < len; i++){\n\t\t\tif( observeReader.valueReaders[i].test(value, index, reads, options) ) {\n\t\t\t\tvalue = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);\n\t\t\t\t//usedValueReader = true;\n\t\t\t}\n\t\t}\n\t} while(usedValueReader);\n\n\treturn value;\n};\n\nvar specialRead = {index: true, key: true, event: true, element: true, viewModel: true};\n\nvar checkForObservableAndNotify = function(options, state, getObserves, value, index){\n\tif(options.foundObservable && !state.foundObservable) {\n\t\tif(Observation.trapsCount()) {\n\t\t\tObservation.addAll( getObserves() );\n\t\t\toptions.foundObservable(value, index);\n\t\t\tstate.foundObservable = true;\n\t\t}\n\t}\n};\n\nobserveReader = {\n\t// there are things that you need to evaluate when you get them back as a property read\n\t// for example a compute or a function you might need to call to get the next value to\n\t// actually check\n\t// - isArgument - should be renamed to something like \"onLastPropertyReadReturnFunctionInsteadOfCallingIt\".\n\t//   This is used to make a compute out of that function if necessary.\n\t// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a\n\t//   compute as a delegate.  In 3.0, this should be removed and force people to write \"{@prop} change\"\n\t// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.\n\t// - executeAnonymousFunctions - call a function if it's found, defaults to true\n\t// - proxyMethods - if the last read is a method, return a function so `this` will be correct.\n\t// - args - arguments to call functions with.\n\t//\n\t// Callbacks\n\t// - earlyExit - called if a value could not be found\n\t// - foundObservable - called when an observable value is found\n\tread: function (parent, reads, options) {\n\t\toptions = options || {};\n\t\tvar state = {\n\t\t\tfoundObservable: false\n\t\t};\n\t\tvar getObserves;\n\t\tif(options.foundObservable) {\n\t\t\tgetObserves = Observation.trap();\n\t\t}\n\n\t\t// `cur` is the current value.\n\t\tvar cur = readValue(parent, 0, reads, options, state),\n\t\t\ttype,\n\t\t\t// `prev` is the object we are reading from.\n\t\t\tprev,\n\t\t\t// `foundObs` did we find an observable.\n\t\t\treadLength = reads.length,\n\t\t\ti = 0,\n\t\t\tlast;\n\n\t\tcheckForObservableAndNotify(options, state, getObserves, parent, 0);\n\n\t\twhile( i < readLength ) {\n\t\t\tprev = cur;\n\t\t\t// try to read the property\n\t\t\tfor(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {\n\t\t\t\tvar reader = observeReader.propertyReaders[r];\n\t\t\t\tif(reader.test(cur)) {\n\t\t\t\t\tcur = reader.read(cur, reads[i], i, options, state);\n\t\t\t\t\tbreak; // there can be only one reading of a property\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i);\n\t\t\tlast = cur;\n\t\t\ti = i+1;\n\t\t\t// read the value if it is a compute or function\n\t\t\tcur = readValue(cur, i, reads, options, state, prev);\n\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i-1);\n\n\n\n\t\t\ttype = typeof cur;\n\t\t\t// early exit if need be\n\t\t\tif (i < reads.length && (cur === null || cur === undefined )) {\n\t\t\t\tif (options.earlyExit) {\n\t\t\t\t\toptions.earlyExit(prev, i - 1, cur);\n\t\t\t\t}\n\t\t\t\t// return undefined so we know this isn't the right value\n\t\t\t\treturn {\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\tparent: prev\n\t\t\t\t};\n\t\t\t}\n\n\t\t}\n\t\t// if we don't have a value, exit early.\n\t\tif (cur === undefined) {\n\t\t\tif (options.earlyExit) {\n\t\t\t\toptions.earlyExit(prev, i - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: cur,\n\t\t\tparent: prev\n\t\t};\n\t},\n\tget: function(parent, reads, options){\n\t\treturn observeReader.read(parent, observeReader.reads(reads), options || {}).value;\n\t},\n\tvalueReadersMap: {},\n\t// an array of types that might have a value inside them like functions\n\t// value readers check the current value\n\t// and get a new value from it\n\t// ideally they would keep calling until\n\t// none of these passed\n\tvalueReaders: [\n\t\t{\n\t\t\tname: \"function\",\n\t\t\t// if this is a function before the last read and its not a constructor function\n\t\t\ttest: function(value, i, reads, options){\n\t\t\t\treturn types.isCallableForValue(value) && !types.isCompute(value);\n\t\t\t},\n\t\t\tread: function(value, i, reads, options, state, prev){\n\t\t\t\tif( isAt(i, reads) ) {\n\t\t\t\t\treturn i === reads.length ? value.bind(prev) : value;\n\t\t\t\t}\n\t\t\t\telse if(options.callMethodsOnObservables && types.isMapLike(prev)) {\n\t\t\t\t\treturn value.apply(prev, options.args || []);\n\t\t\t\t}\n\t\t\t\telse if ( options.isArgument && i === reads.length ) {\n\t\t\t\t\treturn options.proxyMethods !== false ? value.bind(prev) : value;\n\t\t\t\t}\n\t\t\t\treturn value.apply(prev, options.args || []);\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname: \"compute\",\n\t\t\t// compute value reader\n\t\t\ttest: function(value, i, reads, options){\n\t\t\t\treturn types.isCompute(value) && !isAt(i, reads);\n\t\t\t},\n\t\t\tread: function(value, i, reads, options, state){\n\t\t\t\tif(options.readCompute === false && i === reads.length ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn value.get ? value.get() : value();\n\t\t\t},\n\t\t\twrite: function(base, newVal){\n\t\t\t\tif(base.set) {\n\t\t\t\t\tbase.set(newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase(newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\tpropertyReadersMap: {},\n\t// an array of things that might have a property\n\tpropertyReaders: [\n\t\t{\n\t\t\tname: \"map\",\n\t\t\ttest: function(){\n\t\t\t\treturn types.isMapLike.apply(this, arguments) || types.isListLike.apply(this, arguments);\n\t\t\t},\n\t\t\tread: function(value, prop, index, options, state){\n\t\t\t\tvar res = value.get ? value.get(prop.key) : value.attr(prop.key);\n\t\t\t\tif(res !== undefined) {\n\t\t\t\t\treturn res;\n\t\t\t\t} else {\n\t\t\t\t\treturn value[prop.key];\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: function(base, prop, newVal){\n\t\t\t\tif(typeof base.set === \"function\") {\n\t\t\t\t\tbase.set(prop, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase.attr(prop, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// read a promise\n\t\t// it would be good to remove this ... then\n\t\t//\n\t\t{\n\t\t\tname: \"promise\",\n\t\t\ttest: function(value){\n\t\t\t\t// eventually this will use canReflect.isPromiseLike\n\t\t\t\treturn isPromiseLike(value);\n\t\t\t},\n\t\t\tread: function(value, prop, index, options, state){\n\t\t\t\tvar observeData = value.__observeData;\n\t\t\t\tif(!value.__observeData) {\n\t\t\t\t\tobserveData = value.__observeData = {\n\t\t\t\t\t\tisPending: true,\n\t\t\t\t\t\tstate: \"pending\",\n\t\t\t\t\t\tisResolved: false,\n\t\t\t\t\t\tisRejected: false,\n\t\t\t\t\t\tvalue: undefined,\n\t\t\t\t\t\treason: undefined\n\t\t\t\t\t};\n\t\t\t\t\tCID(observeData);\n\t\t\t\t\t// proto based would be faster\n\t\t\t\t\tassign(observeData, canEvent);\n\t\t\t\t\tvalue.then(function(value){\n\t\t\t\t\t\tobserveData.isPending = false;\n\t\t\t\t\t\tobserveData.isResolved = true;\n\t\t\t\t\t\tobserveData.value = value;\n\t\t\t\t\t\tobserveData.state = \"resolved\";\n\t\t\t\t\t\tobserveData.dispatch(\"state\",[\"resolved\",\"pending\"]);\n\t\t\t\t\t}, function(reason){\n\t\t\t\t\t\tobserveData.isPending = false;\n\t\t\t\t\t\tobserveData.isRejected = true;\n\t\t\t\t\t\tobserveData.reason = reason;\n\t\t\t\t\t\tobserveData.state = \"rejected\";\n\t\t\t\t\t\tobserveData.dispatch(\"state\",[\"rejected\",\"pending\"]);\n\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tdev.error(\"Failed promise:\", reason);\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tObservation.add(observeData,\"state\");\n\t\t\t\treturn prop.key in observeData ? observeData[prop.key] : value[prop.key];\n\t\t\t}\n\t\t},\n\n\t\t// read a normal object\n\t\t{\n\t\t\tname: \"object\",\n\t\t\t// this is the default\n\t\t\ttest: function(){return true;},\n\t\t\tread: function(value, prop){\n\t\t\t\tif(value == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tif(typeof value === \"object\") {\n\t\t\t\t\t\tif(prop.key in value) {\n\t\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: remove in 3.0.  This is for backwards compat with @key and @index.\n\t\t\t\t\t\telse if( prop.at && specialRead[prop.key] && ( (\"@\"+prop.key) in value)) {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tdev.warn(\"Use %\"+prop.key+\" in place of @\"+prop.key+\".\");\n\n\t\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\t\treturn value[\"@\"+prop.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: function(base, prop, newVal){\n\t\t\t\tbase[prop] = newVal;\n\t\t\t}\n\t\t}\n\t],\n\treads: function(keyArg) {\n\t\tvar key = \"\"+keyArg;\n\t\tvar keys = [];\n\t\tvar last = 0;\n\t\tvar at = false;\n\t\tif( key.charAt(0) === \"@\" ) {\n\t\t\tlast = 1;\n\t\t\tat = true;\n\t\t}\n\t\tvar keyToAdd = \"\";\n\t\tfor(var i = last; i < key.length; i++) {\n\t\t\tvar character = key.charAt(i);\n\t\t\tif(character === \".\" || character === \"@\") {\n\t\t\t\tif( key.charAt(i -1) !== \"\\\\\" ) {\n\t\t\t\t\tkeys.push({\n\t\t\t\t\t\tkey: keyToAdd,\n\t\t\t\t\t\tat: at\n\t\t\t\t\t});\n\t\t\t\t\tat = character === \"@\";\n\t\t\t\t\tkeyToAdd = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tkeyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + \".\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeyToAdd += character;\n\t\t\t}\n\t\t}\n\t\tkeys.push({\n\t\t\tkey: keyToAdd,\n\t\t\tat: at\n\t\t});\n\n\t\treturn keys;\n\t},\n\t// This should be able to set a property similar to how read works.\n\twrite: function(parent, key, value, options) {\n\t\tvar keys = typeof key === \"string\" ? observeReader.reads(key) : key;\n\t\tvar last;\n\t\tif(keys.length > 1) {\n\t\t\tlast = keys.pop();\n\t\t\tparent = observeReader.read(parent, keys, options).value;\n\t\t\tkeys.push(last);\n\t\t} else {\n\t\t\tlast = keys[0];\n\t\t}\n\t\t// here's where we need to figure out the best way to write\n\n\t\t// if property being set points at a compute, set the compute\n\t\tif( observeReader.valueReadersMap.compute.test(parent[last.key], keys.length - 1, keys, options) ) {\n\t\t\tobserveReader.valueReadersMap.compute.write(parent[last.key], value, options);\n\t\t} else {\n\t\t\tif(observeReader.valueReadersMap.compute.test(parent, keys.length - 1, keys, options) ) {\n\t\t\t\tparent = parent();\n\t\t\t}\n\t\t\tif(observeReader.propertyReadersMap.map.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.map.write(parent, last.key, value, options);\n\t\t\t}\n\t\t\telse if(observeReader.propertyReadersMap.object.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.object.write(parent, last.key, value, options);\n\t\t\t}\n\t\t}\n\t}\n};\neach(observeReader.propertyReaders, function(reader){\n\tobserveReader.propertyReadersMap[reader.name] = reader;\n});\neach(observeReader.valueReaders, function(reader){\n\tobserveReader.valueReadersMap[reader.name] = reader;\n});\nobserveReader.set = observeReader.write;\n\nmodule.exports = observeReader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-observation/reader/reader.js\n// module id = 15\n// module chunks = 0","'use strict';\n\n/**\n * @module {function} can-util/dom/child-nodes/child-nodes child-nodes\n * @parent can-util/dom\n * @signature `childNodes(node)`\n *\n * Get all of the childNodes of a given node.\n *\n * ```js\n * var stache = require(\"can-stache\");\n * var childNodes = require(\"can-util/child-nodes/child-nodes\");\n *\n * var html = \"<div><h1><span></span></h1></div>\";\n * var frag = stache(html)();\n *\n * console.log(childNodes(frag)[0].nodeName); // -> DIV\n * ```\n *\n * @param {Object} node The Node that you want child nodes for.\n */\n\nfunction childNodes(node) {\n\tvar childNodes = node.childNodes;\n\tif (\"length\" in childNodes) {\n\t\treturn childNodes;\n\t} else {\n\t\tvar cur = node.firstChild;\n\t\tvar nodes = [];\n\t\twhile (cur) {\n\t\t\tnodes.push(cur);\n\t\t\tcur = cur.nextSibling;\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = childNodes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/child-nodes/child-nodes.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nvar domEvents = require(\"../events/events\");\n\n/**\n * @module {function} can-util/dom/dispatch/dispatch dispatch\n * @parent can-util/dom\n * @signature `dispatch.call(el, event, args, bubbles)`\n *\n * Dispatch an event on an element.\n *\n * @param {Object|String} event An object specifies options applied to this event.\n * @param {Array} [args] Arguments passed into this event.\n * @param {Boolean} [bubbles=true] Specifies whether this event should bubble (by default it will).\n */\n\nmodule.exports = function(){\n\treturn domEvents.dispatch.apply(this, arguments);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/dispatch/dispatch.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nexports.warnTimeout = 5000;\nexports.logLevel = 0;\n\n/**\n * @module {{}} can-util/js/log/log log\n * @parent can-util/js\n * \n * Utilities for logging to the console.\n */\n\n/**\n * @function can-util/js/log/log.warn warn\n * @parent can-util/js/log/log\n * @description\n * \n * Adds a warning message to the console.\n *\n * ```\n * var canLog = require(\"can-util/js/log/log\");\n * \n * canLog.warn(\"something evil\");\n * ```\n *\n * @signature `canLog.warn(msg)`\n * @param {String} msg the message to be logged.\n */\nexports.warn = function(out) {\n\tvar ll = this.logLevel;\n\tif (ll < 2) {\n\t\tArray.prototype.unshift.call(arguments, 'WARN:');\n\t\tif (typeof console !== \"undefined\" && console.warn) {\n\t\t\tthis._logger(\"warn\", Array.prototype.slice.call(arguments));\n\t\t} else if (typeof console !== \"undefined\" && console.log) {\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t} else if (window && window.opera && window.opera.postError) {\n\t\t\twindow.opera.postError(\"CanJS WARNING: \" + out);\n\t\t}\n\t}\n};\n\n/**\n * @function can-util/js/log/log.log log\n * @parent can-util/js/log/log\n * @description\n * Adds a message to the console.\n *\n * ```\n * var canLog = require(\"can-util/js/log/log\");\n * \n * canLog.log(\"hi\");\n * ```\n *\n * @signature `canLog.log(msg)`\n * @param {String} msg the message\n */\nexports.log = function(out) {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.log) {\n\t\t\tArray.prototype.unshift.call(arguments, 'INFO:');\n\t\t\tthis._logger(\"log\", Array.prototype.slice.call(arguments));\n\t\t} else if (window && window.opera && window.opera.postError) {\n\t\t\twindow.opera.postError(\"CanJS INFO: \" + out);\n\t\t}\n\t}\n};\n\n/**\n * @function can-util/js/log/log.error error\n * @parent can-util/js/log/log\n * @description\n * Adds an error message to the console.\n *\n * ```\n * var canLog = require(\"can-util/js/log/log\");\n * \n * canLog.error(new Error(\"Oh no!\"));\n * ```\n *\n * @signature `canLog.error(err)`\n * @param {String|Error} err The error to be logged.\n */\nexports.error = function(out) {\n\tvar ll = this.logLevel;\n\tif (ll < 1) {\n\t\tif (typeof console !== \"undefined\" && console.error) {\n\t\t\tArray.prototype.unshift.call(arguments, 'ERROR:');\n\t\t\tthis._logger(\"error\", Array.prototype.slice.call(arguments));\n\t\t} else if (window && window.opera && window.opera.postError) {\n\t\t\twindow.opera.postError(\"ERROR: \" + out);\n\t\t}\n\t}\n};\n\nexports._logger = function (type, arr) {\n\ttry {\n\t\tconsole[type].apply(console, arr);\n\t} catch(e) {\n\t\tconsole[type](arr);\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/log/log.js\n// module id = 18\n// module chunks = 0","'use strict';\n\nvar get = require('../get/get');\nvar isContainer = require('../is-container/is-container');\nvar canDev = require(\"../dev/dev\");\nvar isArray = require('../is-array/is-array');\n\n// ##string.js\n// _Miscellaneous string utility functions._\n// Several of the methods in this plugin use code adapated from Prototype\n// Prototype JavaScript framework, version 1.6.0.1.\n// © 2005-2007 Sam Stephenson\n/**\n * @module {{}} can-util/js/string/string string\n * @parent can-util/js\n *\n * @description  String utilities used by CanJS libraries\n */\nvar strUndHash = /_|-/,\n\tstrColons = /\\=\\=/,\n\tstrWords = /([A-Z]+)([A-Z][a-z])/g,\n\tstrLowUp = /([a-z\\d])([A-Z])/g,\n\tstrDash = /([a-z\\d])([A-Z])/g,\n\tstrReplacer = /\\{([^\\}]+)\\}/g,\n\tstrQuote = /\"/g,\n\tstrSingleQuote = /'/g,\n\tstrHyphenMatch = /-+(.)?/g,\n\tstrCamelMatch = /[a-z][A-Z]/g,\n\tconvertBadValues = function (content) {\n\t\t// Convert bad values into empty strings\n\t\tvar isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';\n\t\treturn '' + (isInvalid ? '' : content);\n\t},\n\tdeleteAtPath = function(data, path) {\n\t\tvar parts = path ? path.replace(/\\[/g,'.')\n\t\t\t.replace(/]/g,'').split('.') : [];\n\t\tvar current = data;\n\n\t\tfor(var i = 0; i < parts.length - 1; i++) {\n\t\t\tif(current) {\n\t\t\t\tcurrent = current[parts[i]];\n\t\t\t}\n\t\t}\n\n\t\tif(current) {\n\t\t\tdelete current[parts[parts.length - 1 ]];\n\t\t}\n\t};\n\nvar string = {\n\t/**\n\t * @function can-util/js/string/string.esc string.esc\n\t * @signature `string.esc(content)`\n\t * @param  {String} content a string\n\t * @return {String}         the string safely HTML-escaped\n\t * \n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t * \n\t * string.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n\t * ```\n\t */\n\tesc: function (content) {\n\t\treturn convertBadValues(content)\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t.replace(strQuote, '&#34;')\n\t\t\t.replace(strSingleQuote, '&#39;');\n\t},\n\t/**\n\t * @function can-util/js/string/string.getObject string.getObject\n\t * @signature `string.getObject(name, roots)`\n\t * @param  {String} name  a String of dot-separated keys, representing a path of properties\n\t * @param  {Object|Array} roots the object to use as the root for property based navigation\n\t * @return {*}       the value at the property path descending from `roots`\n\t *\n\t * Return the result of descending the path `name` through the properties of the object or objects\n\t * `roots`\n\t *\n\t * If `roots` is an Array, each element of the array is evaluated, in order, until\n\t * the path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n\t * `roots` is evaluated as the root object, returning either the object at the property path\n\t * descended from `roots` or `undefined` if any subpath is not found.\n\t *\n\t * A *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n\t * 'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\n\t * if it's an array, `roots` itself otherwise.\n\t *\n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t * \n\t * console.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\n\t * console.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\n\t * console.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n\t * ```\n\t */\n\tgetObject: function (name, roots) {\n\t\t//!steal-remove-start\n\t\tcanDev.warn('string.getObject is deprecated, please use can-util/js/get/get instead.');\n\t\t//!steal-remove-end\n\n\t\troots = isArray(roots) ? roots : [roots || window];\n\n\t\tvar result, l = roots.length;\n\n\t\tfor(var i = 0; i < l; i++) {\n\t\t\tresult = get(roots[i], name);\n\n\t\t\tif(result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function can-util/js/string/string.capitalize string.capitalize\n\t * @signature `string.capitalize(s)`\n\t * @param  {String} s     the string to capitalize\n\t * @return {String}       the supplied string with the first character uppercased if it is a letter\n\t *\n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t *\n\t * console.log(string.capitalize(\"foo\")); // -> \"Foo\"\n\t * console.log(string.capitalize(\"123\")); // -> \"123\"\n\t * ```\n\t */\n\tcapitalize: function (s, cache) {\n\t\t// Used to make newId.\n\t\treturn s.charAt(0)\n\t\t\t.toUpperCase() + s.slice(1);\n\t},\n\t/**\n\t * @function can-util/js/string/string.camelize string.camelize\n\t * @signature `string.camelize(s)`\n\t * @param  {String} str   the string to camelCase\n\t * @return {String}       the supplied string with hyphens removed and following letters capitalized.\n\t *\n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t *\n\t * console.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\n\t * console.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n\t * ```\n\t */\n\tcamelize: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strHyphenMatch, function (match, chr) {\n\t\t\t\treturn chr ? chr.toUpperCase() : '';\n\t\t\t});\n\t},\n\t/**\n\t * @function can-util/js/string/string.hyphenate string.hyphenate\n\t * @signature `string.hyphenate(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t *\n\t * console.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\n\t * console.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n\t * ```\n\t */\n\thyphenate: function (str) {\n\t\treturn convertBadValues(str)\n\t\t\t.replace(strCamelMatch, function (str, offset) {\n\t\t\t\treturn str.charAt(0) + '-' + str.charAt(1)\n\t\t\t\t\t.toLowerCase();\n\t\t\t});\n\t},\n\t/**\n\t * @function can-util/js/string/string.underscore string.underscore\n\t * @signature `string.underscore(s)`\n\t * @param  {String} str   a string in camelCase\n\t * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs\n\t *\n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t *\n\t * console.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\n\t * console.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n\t * ```\n\t */\n\tunderscore: function (s) {\n\t\treturn s.replace(strColons, '/')\n\t\t\t.replace(strWords, '$1_$2')\n\t\t\t.replace(strLowUp, '$1_$2')\n\t\t\t.replace(strDash, '_')\n\t\t\t.toLowerCase();\n\t},\n\t/**\n\t * @function can-util/js/string/string.sub string.sub\n\t * @signature `string.sub(str, data, remove)`\n\t * @param {String} str   a string with {curly brace} delimited property names\n\t * @param {Object} data  an object from which to read properties\n\t * @return {String|null} the supplied string with delimited properties replaced with their values\n\t *                       if all properties exist on the object, null otherwise\n\t *\n\t * If `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\t *\n\t * ```js\n\t * var string = require(\"can-util/js/string/string\");\n\t *\n\t * console.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\n\t * console.log(string.sub(\"foo_{bar}\", {})); // -> null\n\t * ```\n\t */\n\tsub: function (str, data, remove) {\n\t\tvar obs = [];\n\t\tstr = str || '';\n\t\tobs.push(str.replace(strReplacer, function (whole, inside) {\n\t\t\t// Convert inside to type.\n\t\t\tvar ob = get(data, inside);\n\n\t\t\tif(remove === true) {\n\t\t\t\tdeleteAtPath(data, inside);\n\t\t\t}\n\n\t\t\tif (ob === undefined || ob === null) {\n\t\t\t\tobs = null;\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\t// If a container, push into objs (which will return objects found).\n\t\t\tif (isContainer(ob) && obs) {\n\t\t\t\tobs.push(ob);\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn '' + ob;\n\t\t}));\n\t\treturn obs === null ? obs : obs.length <= 1 ? obs[0] : obs;\n\t},\n\t/**\n\t * @property {RegExp} can-util/js/string/string.strReplacer string.strReplacer\n\t *\n\t * The regex used to find replacement sections in [can-util/js/string/string.sub string.sub]\n\t */\n\treplacer: strReplacer,\n\t/**\n\t * @property {RegExp} can-util/js/string/string.strUndHash string.strUndHash\n\t *\n\t * A regex which matches an underscore or hyphen character\n\t */\n\tundHash: strUndHash\n};\nmodule.exports = string;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/string/string.js\n// module id = 19\n// module chunks = 0","var makeArray = require('can-util/js/make-array/make-array');\nvar each = require('can-util/js/each/each');\nvar namespace = require('can-namespace');\nvar domMutate = require('can-util/dom/mutate/mutate');\n\nvar CIDMap = require(\"can-util/js/cid-map/cid-map\");\n// # can/view/node_lists/node_list.js\n//\n// ## Helpers\n\n// A mapping of element ids to nodeList id allowing us to quickly find an element\n// that needs to be replaced when updated.\nvar nodeMap = new CIDMap(),\n\tsplice = [].splice,\n\tpush = [].push,\n\n\t// ## nodeLists.itemsInChildListTree\n\t// Given a nodeList return the number of child items in the provided\n\t// list and any child lists.\n\titemsInChildListTree = function(list){\n\t\tvar count = 0;\n\t\tfor(var i = 0, len = list.length ; i < len; i++){\n\t\t\tvar item = list[i];\n\t\t\t// If the item is an HTMLElement then increment the count by 1.\n\t\t\tif(item.nodeType) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\t// If the item is not an HTMLElement it is a list, so\n\t\t\t\t// increment the count by the number of items in the child\n\t\t\t\t// list.\n\t\t\t\tcount += itemsInChildListTree(item);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t},\n\t// replacements is an array of nodeLists\n\t// makes a map of the first node in the replacement to the nodeList\n\treplacementMap = function(replacements, idMap){\n\t\tvar map = new CIDMap();\n\t\tfor(var i = 0, len = replacements.length; i < len; i++){\n\t\t\tvar node = nodeLists.first(replacements[i]);\n\t\t\tmap.set(node, replacements[i]);\n\t\t}\n\t\treturn map;\n\t},\n\taddUnfoundAsDeepChildren = function(list, rMap){\n\t\trMap.forEach(function(replacement){\n\t\t\tlist.newDeepChildren.push(replacement);\n\t\t});\n\t};\n\n// ## Registering & Updating\n//\n// To keep all live-bound sections knowing which elements they are managing,\n// all live-bound elments are registered and updated when they change.\n//\n// For example, the above template, when rendered with data like:\n//\n//     data = new can.Map({\n//         items: [\"first\",\"second\"]\n//     })\n//\n// This will first render the following content:\n//\n//     <div>\n//         <span data-view-id='5'/>\n//     </div>\n//\n// When the `5` callback is called, this will register the `<span>` like:\n//\n//     var ifsNodes = [<span 5>]\n//     nodeLists.register(ifsNodes);\n//\n// And then render `{{if}}`'s contents and update `ifsNodes` with it:\n//\n//     nodeLists.update( ifsNodes, [<\"\\nItems:\\n\">, <span data-view-id=\"6\">] );\n//\n// Next, hookup `6` is called which will regsiter the `<span>` like:\n//\n//     var eachsNodes = [<span 6>];\n//     nodeLists.register(eachsNodes);\n//\n// And then it will render `{{#each}}`'s content and update `eachsNodes` with it:\n//\n//     nodeLists.update(eachsNodes, [<label>,<label>]);\n//\n// As `nodeLists` knows that `eachsNodes` is inside `ifsNodes`, it also updates\n// `ifsNodes`'s nodes to look like:\n//\n//     [<\"\\nItems:\\n\">,<label>,<label>]\n//\n// Now, if all items were removed, `{{#if}}` would be able to remove\n// all the `<label>` elements.\n//\n// When you regsiter a nodeList, you can also provide a callback to know when\n// that nodeList has been replaced by a parent nodeList.  This is\n// useful for tearing down live-binding.\nvar nodeLists = {\n\n   /**\n\t* @function can-view-nodelist.update update\n\t* @parent can-view-nodelist/methods\n\t*\n\t* @signature `nodeLists.update(nodeList, newNodes)`\n\t*\n\t* Updates a nodeList with new items, i.e. when values for the template have changed.\n\t*\n\t*   @param {can-view-nodelist/types/NodeList} nodeList The list to update with the new nodes.\n\t*   @param {can-view-nodelist/types/NodeList} newNodes The new nodes to update with.\n\t*\n\t*   @return {Array<Node>} The nodes that were removed from `nodeList`.\n\t*/\n\tupdate: function (nodeList, newNodes) {\n\t\t// Unregister all childNodeLists.\n\t\tvar oldNodes = nodeLists.unregisterChildren(nodeList);\n\n\t\tnewNodes = makeArray(newNodes);\n\n\t\tvar oldListLength = nodeList.length;\n\n\t\t// Replace oldNodeLists's contents.\n\t\tsplice.apply(nodeList, [\n\t\t\t0,\n\t\t\toldListLength\n\t\t].concat(newNodes));\n\n\t\t// Replacements are nodes that have replaced the original element this is on.\n\t\t// We can't simply insert elements because stache does children before parents.\n\t\tif(nodeList.replacements){\n\t\t\tnodeLists.nestReplacements(nodeList);\n\t\t\tnodeList.deepChildren = nodeList.newDeepChildren;\n\t\t\tnodeList.newDeepChildren = [];\n\t\t} else {\n\t\t\tnodeLists.nestList(nodeList);\n\t\t}\n\n\t\treturn oldNodes;\n\t},\n   /**\n\t* @function can-view-nodelist.nestReplacements nestReplacements\n\t* @parent can-view-nodelist/methods\n\t* @signature `nodeLists.nestReplacements(list)`\n\t*\n\t* Goes through each node in the list. `[el1, el2, el3, ...]`\n\t* Finds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\n\t* Replaces that element and any other elements in the node list with the\n\t* nodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\n\t* If a replacement is not found, it was improperly added, so we add it as a deepChild.\n\t*\n\t* @param {can-view-nodelist/types/NodeList} list  The nodeList of nodes to go over\n\t*\n\t*/\n\tnestReplacements: function(list){\n\t\tvar index = 0,\n\t\t\t// temporary id map that is limited to this call\n\t\t\tidMap = {},\n\t\t\t// replacements are in reverse order in the DOM\n\t\t\trMap = replacementMap(list.replacements, idMap),\n\t\t\trCount = list.replacements.length;\n\n\t\twhile(index < list.length && rCount) {\n\t\t\tvar node = list[index],\n\t\t\t\treplacement = rMap.get(node);\n\t\t\tif( replacement ) {\n\t\t\t\trMap[\"delete\"](node);\n\t\t\t\tlist.splice( index, itemsInChildListTree(replacement), replacement );\n\t\t\t\trCount--;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\t// Only do this if\n\t\tif(rCount) {\n\t\t\taddUnfoundAsDeepChildren(list, rMap );\n\t\t}\n\n\t\tlist.replacements = [];\n\t},\n\t/**\n\t * @function can-view-nodelist.nestList nestList\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.nestList(list)`\n\t *\n\t * If a given list does not exist in the nodeMap then create an lookup\n\t * id for it in the nodeMap and assign the list to it.\n\t * If the the provided does happen to exist in the nodeMap update the\n\t * elements in the list.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} list The nodeList being nested.\n\t *\n\t */\n\tnestList: function(list){\n\t\tvar index = 0;\n\t\twhile(index < list.length) {\n\t\t\tvar node = list[index],\n\t\t\t\tchildNodeList = nodeMap.get(node);\n\n\n\t\t\tif(childNodeList) {\n\t\t\t\t// if this node is in another nodelist\n\t\t\t\tif(childNodeList !== list) {\n\t\t\t\t\t// update this nodeList to point to the childNodeList\n\t\t\t\t\tlist.splice( index, itemsInChildListTree(childNodeList), childNodeList );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Indicate the new nodes belong to this list.\n\t\t\t\tnodeMap.set(node, list);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t},\n\n\t/**\n\t * @function can-view-nodelist.last last\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.last(nodeList)`\n\t *\n\t * Return the last HTMLElement in a nodeList; if the last\n\t * element is a nodeList, returns the last HTMLElement of\n\t * the child list, etc.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t * @return {HTMLElement} The last element of the last list nested in this list.\n\t *\n\t */\n\tlast: function(nodeList){\n\t\tvar last = nodeList[nodeList.length - 1];\n\t\t// If the last node in the list is not an HTMLElement\n\t\t// it is a nodeList so call `last` again.\n\t\tif(last.nodeType) {\n\t\t\treturn last;\n\t\t} else {\n\t\t\treturn nodeLists.last(last);\n\t\t}\n\t},\n\n\t/**\n\t * @function can-view-nodelist.first first\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.first(nodeList)`\n\t *\n\t * Return the first HTMLElement in a nodeList; if the first\n\t * element is a nodeList, returns the first HTMLElement of\n\t * the child list, etc.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t * @return {HTMLElement} The first element of the first list nested in this list.\n\t *\n\t *\n\t */\n\tfirst: function(nodeList) {\n\t\tvar first = nodeList[0];\n\t\t// If the first node in the list is not an HTMLElement\n\t\t// it is a nodeList so call `first` again.\n\t\tif(first.nodeType) {\n\t\t\treturn first;\n\t\t} else {\n\t\t\treturn nodeLists.first(first);\n\t\t}\n\t},\n\tflatten: function(nodeList){\n\t\tvar items = [];\n\t\tfor(var i = 0 ; i < nodeList.length; i++) {\n\t\t\tvar item = nodeList[i];\n\t\t\tif(item.nodeType) {\n\t\t\t\titems.push(item);\n\t\t\t} else {\n\t\t\t\titems.push.apply(items, nodeLists.flatten(item));\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\t/**\n\t * @function can-view-nodelist.register register\n\t * @parent can-view-nodelist/methods\n\t *\n\t * @signature `nodeLists.register(nodeList, unregistered, parent, directlyNested)`\n\t *\n\t * Registers a nodeList and returns the nodeList passed to register.\n\t *\n\t *   @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t *   @param {function()} unregistered A callback to call when the nodeList is unregistered.\n\t *   @param {can-view-nodelist/types/NodeList} parent The parent nodeList of this nodeList.\n\t *   @param {Boolean} directlyNested `true` if nodes in the nodeList are direct children of the parent.\n\t *   @return {can-view-nodelist/types/NodeList} The passed in nodeList.\n\t *\n\t */\n\tregister: function (nodeList, unregistered, parent, directlyNested) {\n\t\t// If a unregistered callback has been provided assign it to the nodeList\n\t\t// as a property to be called when the nodeList is unregistred.\n\t\tnodeList.unregistered = unregistered;\n\t\tnodeList.parentList = parent;\n\t\tnodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;\n\n\t\tif(parent) {\n\t\t\tnodeList.deepChildren = [];\n\t\t\tnodeList.newDeepChildren = [];\n\t\t\tnodeList.replacements = [];\n\t\t\tif(parent !== true) {\n\t\t\t\tif(directlyNested) {\n\t\t\t\t\tparent.replacements.push(nodeList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent.newDeepChildren.push(nodeList);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnodeLists.nestList(nodeList);\n\t\t}\n\n\n\t\treturn nodeList;\n\t},\n\n\t/**\n\t * @function can-view-nodelist.unregisterChildren unregisterChildren\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.unregisterChildren(nodeList)`\n\t *\n\t * Unregister all childen within the provided list and return the\n\t * unregistred nodes.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList The nodeList of child nodes to unregister.\n\t * @return {Array} The list of all nodes that were unregistered.\n\t */\n\tunregisterChildren: function(nodeList){\n\t\tvar nodes = [];\n\t\t// For each node in the nodeList we want to compute it's id\n\t\t// and delete it from the nodeList's internal map.\n\t\teach(nodeList, function (node) {\n\t\t\t// If the node does not have a nodeType it is an array of\n\t\t\t// nodes.\n\t\t\tif(node.nodeType) {\n\t\t\t\tif(!nodeList.replacements) {\n\t\t\t\t\tnodeMap[\"delete\"](node);\n\t\t\t\t}\n\n\t\t\t\tnodes.push(node);\n\t\t\t} else {\n\t\t\t\t// Recursively unregister each of the child lists in\n\t\t\t\t// the nodeList.\n\t\t\t\tpush.apply(nodes, nodeLists.unregister(node, true));\n\t\t\t}\n\t\t});\n\n\t\teach(nodeList.deepChildren, function(nodeList){\n\t\t\tnodeLists.unregister(nodeList, true);\n\t\t});\n\n\t\treturn nodes;\n\t},\n\n\t/**\n\t\t@function can-view-nodelist.unregister unregister\n\t\t@parent can-view-nodelist/methods\n\t\t@signature `nodeLists.unregister(nodeList, isChild)`\n\t\t@param {ArrayLike} nodeList a nodeList to unregister from its parent\n\t\t@param {isChild}  true if the nodeList is a direct child, false if a deep child\n\t\t@return {Array}   a list of all nodes that were unregistered\n\n\t\tUnregister's a nodeList and returns the unregistered nodes.\n\t\tCall if the nodeList is no longer being updated. This will\n\t\talso unregister all child nodeLists.\n\t*/\n\tunregister: function (nodeList, isChild) {\n\t\tvar nodes = nodeLists.unregisterChildren(nodeList, true);\n\n\t\t// If an 'unregisted' function was provided during registration, remove\n\t\t// it from the list, and call the function provided.\n\t\tif (nodeList.unregistered) {\n\t\t\tvar unregisteredCallback = nodeList.unregistered;\n\t\t\tnodeList.replacements = nodeList.unregistered = null;\n\t\t\tif(!isChild) {\n\t\t\t\tvar deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;\n\t\t\t\tif(deepChildren) {\n\t\t\t\t\tvar index = deepChildren.indexOf(nodeList);\n\t\t\t\t\tif(index !== -1) {\n\t\t\t\t\t\tdeepChildren.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunregisteredCallback();\n\t\t}\n\t\treturn nodes;\n\t},\n\t/**\n\t * @function can-view-nodelist.after after\n\t * @parent can-view-nodelist/methods\n\t * @hide\n\t * @signature `nodeLists.after(oldElements, newFrag)`\n\t *\n\t *   Inserts `newFrag` after `oldElements`.\n\t *\n\t *   @param {ArrayLike<Node>} oldElements The elements to use as reference.\n\t *   @param {DocumentFragment} newFrag The fragment to insert.\n\t *\n\t */\n\tafter: function (oldElements, newFrag) {\n\t\tvar last = oldElements[oldElements.length - 1];\n\t\t// Insert it in the `document` or `documentFragment`\n\t\tif (last.nextSibling) {\n\t\t\tdomMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);\n\t\t} else {\n\t\t\tdomMutate.appendChild.call(last.parentNode, newFrag );\n\t\t}\n\t},\n\t/**\n\t * @function can-view-nodelist.replace replace\n\t * @hide\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.replace(oldElements, newFrag)`\n\t *\n\t * Replaces `oldElements` with `newFrag`.\n\t *\n\t * @param {Array<Node>} oldElements the list elements to remove\n\t * @param {DocumentFragment} newFrag the fragment to replace the old elements\n\t *\n\t */\n\treplace: function (oldElements, newFrag) {\n\t\t// The following helps make sure that a selected <option> remains\n\t\t// the same by removing `selected` from the currently selected option\n\t\t// and adding selected to an option that has the same value.\n\t\tvar selectedValue,\n\t\t\tparentNode = oldElements[0].parentNode;\n\n\t\tif(parentNode.nodeName.toUpperCase() === \"SELECT\" && parentNode.selectedIndex >= 0) {\n\t\t\tselectedValue = parentNode.value;\n\t\t}\n\t\tif(oldElements.length === 1) {\n\t\t\tdomMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);\n\t\t} else {\n\t\t\tnodeLists.after(oldElements, newFrag);\n\t\t\tnodeLists.remove(oldElements);\n\t\t}\n\n\t\tif(selectedValue !== undefined) {\n\t\t\tparentNode.value = selectedValue;\n\t\t}\n\t},\n\t/**\n\t * @function can-view-nodelist.remove remove\n\t * @parent can-view-nodelist/methods\n\t * @hide\n\t * @signature `nodeLists.remove(elementsToBeRemoved)`\n\t *\n\t * Remove all Nodes in `oldElements` from the DOM.\n\t *\n\t * @param {ArrayLike<Node>} oldElements the list of Elements to remove (must have a common parent)\n\t *\n\t */\n\tremove: function(elementsToBeRemoved){\n\t\tvar parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;\n\t\teach(elementsToBeRemoved, function(child){\n\t\t\tdomMutate.removeChild.call(parent, child);\n\t\t});\n\t},\n\tnodeMap: nodeMap\n};\nmodule.exports = namespace.nodeLists = nodeLists;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-nodelist/can-view-nodelist.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nvar global = require(\"../../js/global/global\")();\nvar setMutationObserver;\nmodule.exports = function(setMO){\n\tif(setMO !== undefined) {\n\t\tsetMutationObserver = setMO;\n\t}\n\treturn setMutationObserver !== undefined ? setMutationObserver :\n\t\tglobal.MutationObserver || global.WebKitMutationObserver || global.MozMutationObserver;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/mutation-observer/mutation-observer.js\n// module id = 21\n// module chunks = 0","'use strict';\n\n/* jshint unused: false */\n\n/**\n * @module {function} can-util/js/is-empty-object/is-empty-object is-empty-object\n * @parent can-util/js\n * @signature `isEmptyObject(obj)`\n *\n * Used to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n *\n * ```js\n * var isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\n *\n * console.log(isEmptyObject({})); // -> true\n *\n * console.log(isEmptyObject({ a: 1 })); // -> false\n *\n * var obj = {};\n * Object.defineProperty(obj, \"foo\", {\n *     enumerable: false,\n *     value: \"bar\"\n * });\n * console.log(isEmptyObject(obj)); // -> true\n * ```\n *\n * @param {Object} obj Any object.\n * @return {Boolean} True if the object is an object with no enumerable properties.\n */\nmodule.exports = function(obj){\n\tfor(var prop in obj) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-empty-object/is-empty-object.js\n// module id = 22\n// module chunks = 0","'use strict';\n\n/**\n * @module {function} can-util/js/is-function/is-function is-function\n * @parent can-util/js\n *\n * @signature `isFunction(value)`\n *\n * @param {*} value the item to test for being a function\n * @return {Boolean} True if the provided argument is a function.\n *\n * ```js\n * var isFunction = require(\"can-util/js/is-function/is-function\");\n *\n * console.log(isFunction(function(){})); // -> true\n *\n * console.log(isFunction({})); // -> false\n * ```\n *\n */\nvar isFunction = (function() {\n\tif (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {\n\t\treturn function(value) {\n\t\t\treturn Object.prototype.toString.call(value) === '[object Function]';\n\t\t};\n\t}\n\treturn function(value) {\n\t\treturn typeof value === 'function';\n\t};\n}());\n\nmodule.exports = isFunction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-function/is-function.js\n// module id = 23\n// module chunks = 0","'use strict';\n\n// # can/util/attr.js\n// Central location for attribute changing to occur, used to trigger an\n// `attributes` event on elements. This enables the user to do (jQuery example): `$(el).bind(\"attributes\", function(ev) { ... })` where `ev` contains `attributeName` and `oldValue`.\nvar setImmediate = require(\"../../js/set-immediate/set-immediate\");\nvar getDocument = require(\"../document/document\");\nvar global = require(\"../../js/global/global\")();\nvar isOfGlobalDocument = require(\"../is-of-global-document/is-of-global-document\");\nvar setData = require(\"../data/data\");\nvar domContains = require(\"../contains/contains\");\nvar domEvents = require(\"../events/events\");\nvar domDispatch = require(\"../dispatch/dispatch\");\nvar MUTATION_OBSERVER = require(\"../mutation-observer/mutation-observer\");\nvar each = require(\"../../js/each/each\");\nvar types = require(\"can-types\");\nvar diff = require('../../js/diff/diff');\n\nrequire(\"../events/attributes/attributes\");\nrequire(\"../events/inserted/inserted\");\n\nvar namespaces = {\n\t'xlink': 'http://www.w3.org/1999/xlink'\n};\n\nvar formElements = {\"INPUT\": true, \"TEXTAREA\": true, \"SELECT\": true},\n\t// Used to convert values to strings.\n\ttoString = function(value){\n\t\tif(value == null) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn \"\"+value;\n\t\t}\n\t},\n\tisSVG = function(el){\n\t\treturn el.namespaceURI === \"http://www.w3.org/2000/svg\";\n\t},\n\ttruthy = function() { return true; },\n\tgetSpecialTest = function(special){\n\t\treturn (special && special.test) || truthy;\n\t},\n\tpropProp = function(prop, obj){\n\t\tobj = obj || {};\n\t\tobj.get = function(){\n\t\t\treturn this[prop];\n\t\t};\n\t\tobj.set = function(value){\n\t\t\tif(this[prop] !== value) {\n\t\t\t\tthis[prop] = value;\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\t\treturn obj;\n\t},\n\tbooleanProp = function(prop){\n\t\treturn {\n\t\t\tisBoolean: true,\n\t\t\tset: function(value){\n\t\t\t\tif(prop in this) {\n\t\t\t\t\tthis[prop] = value !== false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.setAttribute(prop, \"\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tremove: function(){\n\t\t\t\tthis[prop] = false;\n\t\t\t}\n\t\t};\n\t},\n\tsetupMO = function(el, callback){\n\t\tvar attrMO = setData.get.call(el, \"attrMO\");\n\t\tif(!attrMO) {\n\t\t\tvar onMutation = function(){\n\t\t\t\tcallback.call(el);\n\t\t\t};\n\t\t\tvar MO = MUTATION_OBSERVER();\n\t\t\tif(MO) {\n\t\t\t\tvar observer = new MO(onMutation);\n\t\t\t\tobserver.observe(el, {\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tsubtree: true\n\t\t\t\t});\n\t\t\t\tsetData.set.call(el, \"attrMO\", observer);\n\t\t\t} else {\n\t\t\t\tsetData.set.call(el, \"attrMO\", true);\n\t\t\t\tsetData.set.call(el, \"canBindingCallback\", {onMutation: onMutation});\n\t\t\t}\n\t\t}\n\t},\n\t_findOptionToSelect = function (parent, value) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === 'OPTION' && value === child.value) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tif (child.nodeName === 'OPTGROUP') {\n\t\t\t\tvar groupChild = _findOptionToSelect(child, value);\n\t\t\t\tif (groupChild) {\n\t\t\t\t\treturn groupChild;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tsetChildOptions = function(el, value){\n\t\tvar option;\n\t\tif (value != null) {\n\t\t\toption = _findOptionToSelect(el, value);\n\t\t}\n\t\tif (option) {\n\t\t\toption.selected = true;\n\t\t} else {\n\t\t\tel.selectedIndex = -1;\n\t\t}\n\t},\n\tforEachOption = function (parent, fn) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === 'OPTION') {\n\t\t\t\tfn(child);\n\t\t\t}\n\t\t\tif (child.nodeName === 'OPTGROUP') {\n\t\t\t\tforEachOption(child, fn);\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tcollectSelectedOptions = function (parent) {\n\t\tvar selectedValues = [];\n\t\tforEachOption(parent, function (option) {\n\t\t\tif (option.selected) {\n\t\t\t\tselectedValues.push(option.value);\n\t\t\t}\n\t\t});\n\t\treturn selectedValues;\n\t},\n\tmarkSelectedOptions = function (parent, values) {\n\t\tforEachOption(parent, function (option) {\n\t\t\toption.selected = values.indexOf(option.value) !== -1;\n\t\t});\n\t},\n\t// Create a handler, only once, that will set the child options any time\n\t// the select's value changes.\n\tsetChildOptionsOnChange = function(select, aEL){\n\t\tvar handler = setData.get.call(select, \"attrSetChildOptions\");\n\t\tif(handler) {\n\t\t\treturn Function.prototype;\n\t\t}\n\t\thandler = function(){\n\t\t\tsetChildOptions(select, select.value);\n\t\t};\n\t\tsetData.set.call(select, \"attrSetChildOptions\", handler);\n\t\taEL.call(select, \"change\", handler);\n\t\treturn function(rEL){\n\t\t\tsetData.clean.call(select, \"attrSetChildOptions\");\n\t\t\trEL.call(select, \"change\", handler);\n\t\t};\n\t},\n\tattr = {\n\t\tspecial: {\n\t\t\tchecked: {\n\t\t\t\tget: function(){\n\t\t\t\t\treturn this.checked;\n\t\t\t\t},\n\t\t\t\tset: function(val){\n\t\t\t\t\t// - `set( truthy )` => TRUE\n\t\t\t\t\t// - `set( \"\" )`     => TRUE\n\t\t\t\t\t// - `set()`         => TRUE\n\t\t\t\t\t// - `set(undefined)` => false.\n\t\t\t\t\tvar notFalse = !!val || val === \"\" || arguments.length === 0;\n\t\t\t\t\tthis.checked = notFalse;\n\t\t\t\t\tif(notFalse && this.type === \"radio\") {\n\t\t\t\t\t\tthis.defaultChecked = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn val;\n\t\t\t\t},\n\t\t\t\tremove: function(){\n\t\t\t\t\tthis.checked = false;\n\t\t\t\t},\n\t\t\t\ttest: function(){\n\t\t\t\t\treturn this.nodeName === \"INPUT\";\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"class\": {\n\t\t\t\tget: function(){\n\t\t\t\t\tif(isSVG(this)) {\n\t\t\t\t\t\treturn this.getAttribute(\"class\");\n\t\t\t\t\t}\n\t\t\t\t\treturn this.className;\n\t\t\t\t},\n\t\t\t\tset: function(val){\n\t\t\t\t\tval = val || \"\";\n\n\t\t\t\t\tif(isSVG(this)) {\n\t\t\t\t\t\tthis.setAttribute(\"class\", \"\" + val);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.className = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdisabled: booleanProp(\"disabled\"),\n\t\t\tfocused: {\n\t\t\t\tget: function(){\n\t\t\t\t\treturn this === document.activeElement;\n\t\t\t\t},\n\t\t\t\tset: function(val){\n\t\t\t\t\tvar cur = attr.get(this, 'focused');\n\t\t\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\t\t\tvar element = this;\n\t\t\t\t\tfunction focusTask() {\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\telement.focus();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telement.blur();\n\t\t\t\t\t\t}                            \t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (cur !== val) {\n\t\t\t\t\t\tif (!domContains.call(docEl, element)) {\n\t\t\t\t\t\t\tvar initialSetHandler = function () {\n\t\t\t\t\t\t\t\tdomEvents.removeEventListener.call(element, 'inserted', initialSetHandler);\n\t\t\t\t\t\t\t\tfocusTask();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdomEvents.addEventListener.call(element, 'inserted', initialSetHandler);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttypes.queueTask([\n\t\t\t\t\t\t\t\tfocusTask,\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn !!val;\n\t\t\t\t},\n\t\t\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\t\t\taEL.call(this, \"focus\", handler);\n\t\t\t\t\taEL.call(this, \"blur\", handler);\n\t\t\t\t\treturn function(rEL){\n\t\t\t\t\t\trEL.call(this, \"focus\", handler);\n\t\t\t\t\t\trEL.call(this, \"blur\", handler);\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\ttest: function(){\n\t\t\t\t\treturn this.nodeName === \"INPUT\";\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"for\": propProp(\"htmlFor\"),\n\t\t\tinnertext: propProp(\"innerText\"),\n\t\t\tinnerhtml: propProp(\"innerHTML\"),\n\t\t\tinnerHTML: propProp(\"innerHTML\", {\n\t\t\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\t\t\tvar handlers = [];\n\t\t\t\t\tvar el = this;\n\t\t\t\t\teach([\"change\", \"blur\"], function(eventName){\n\t\t\t\t\t\tvar localHandler = function(){\n\t\t\t\t\t\t\thandler.apply(this, arguments);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tdomEvents.addEventListener.call(el, eventName, localHandler);\n\t\t\t\t\t\thandlers.push([eventName, localHandler]);\n\t\t\t\t\t});\n\n\t\t\t\t\treturn function(rEL){\n\t\t\t\t\t\teach(handlers, function(info){\n\t\t\t\t\t\t\trEL.call(el, info[0], info[1]);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}),\n\t\t\trequired: booleanProp(\"required\"),\n\t\t\treadonly: booleanProp(\"readOnly\"),\n\t\t\tselected: {\n\t\t\t\tget: function(){\n\t\t\t\t\treturn this.selected;\n\t\t\t\t},\n\t\t\t\tset: function(val){\n\t\t\t\t\tval = !!val;\n\t\t\t\t\tsetData.set.call(this, \"lastSetValue\", val);\n\t\t\t\t\treturn this.selected = val;\n\t\t\t\t},\n\t\t\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\t\t\tvar option = this;\n\t\t\t\t\tvar select = this.parentNode;\n\t\t\t\t\tvar lastVal = option.selected;\n\t\t\t\t\tvar localHandler = function(changeEvent){\n\t\t\t\t\t\tvar curVal = option.selected;\n\t\t\t\t\t\tlastVal = setData.get.call(option, \"lastSetValue\") || lastVal;\n\t\t\t\t\t\tif(curVal !== lastVal) {\n\t\t\t\t\t\t\tlastVal = curVal;\n\n\t\t\t\t\t\t\tdomDispatch.call(option, eventName);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tvar removeChangeHandler = setChildOptionsOnChange(select, aEL);\n\t\t\t\t\tdomEvents.addEventListener.call(select, \"change\", localHandler);\n\t\t\t\t\taEL.call(option, eventName, handler);\n\n\t\t\t\t\treturn function(rEL){\n\t\t\t\t\t\tremoveChangeHandler(rEL);\n\t\t\t\t\t\tdomEvents.removeEventListener.call(select, \"change\", localHandler);\n\t\t\t\t\t\trEL.call(option, eventName, handler);\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\ttest: function(){\n\t\t\t\t\treturn this.nodeName === \"OPTION\" && this.parentNode &&\n\t\t\t\t\t\tthis.parentNode.nodeName === \"SELECT\";\n\t\t\t\t}\n\t\t\t},\n\t\t\tsrc: {\n\t\t\t\tset: function (val) {\n\t\t\t\t\tif (val == null || val === \"\") {\n\t\t\t\t\t\tthis.removeAttribute(\"src\");\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setAttribute(\"src\", val);\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tstyle: {\n\t\t\t\tset: (function () {\n\t\t\t\t\tvar el = global.document && getDocument().createElement('div');\n\t\t\t\t\tif ( el && el.style && (\"cssText\" in el.style) ) {\n\t\t\t\t\t\treturn function (val) {\n\t\t\t\t\t\t\treturn this.style.cssText = (val || \"\");\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn function (val) {\n\t\t\t\t\t\t\treturn this.setAttribute(\"style\", val);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t})()\n\t\t\t},\n\t\t\ttextcontent: propProp(\"textContent\"),\n\t\t\tvalue: {\n\t\t\t\tget: function(){\n\t\t\t\t\tvar value = this.value;\n\t\t\t\t\tif(this.nodeName === \"SELECT\") {\n\t\t\t\t\t\tif((\"selectedIndex\" in this) && this.selectedIndex === -1) {\n\t\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tset: function(value){\n\t\t\t\t\tvar nodeName = this.nodeName.toLowerCase();\n\t\t\t\t\tif(nodeName === \"input\") {\n\t\t\t\t\t\t// Do some input types support non string values?\n\t\t\t\t\t\tvalue = toString(value);\n\t\t\t\t\t}\n\t\t\t\t\tif(this.value !== value || nodeName === \"option\") {\n\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t}\n\t\t\t\t\tif(attr.defaultValue[nodeName]) {\n\t\t\t\t\t\tthis.defaultValue = value;\n\t\t\t\t\t}\n\t\t\t\t\tif(nodeName === \"select\") {\n\t\t\t\t\t\tsetData.set.call(this, \"attrValueLastVal\", value);\n\t\t\t\t\t\t//If it's null then special case\n\t\t\t\t\t\tsetChildOptions(this, value === null ? value : this.value);\n\n\t\t\t\t\t\t// If not in the document reset the value when inserted.\n\t\t\t\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\t\t\t\tif(!domContains.call(docEl, this)) {\n\t\t\t\t\t\t\tvar select = this;\n\t\t\t\t\t\t\tvar initialSetHandler = function(){\n\t\t\t\t\t\t\t\tdomEvents.removeEventListener.call(select, \"inserted\", initialSetHandler);\n\t\t\t\t\t\t\t\tsetChildOptions(select, value === null ? value : select.value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdomEvents.addEventListener.call(this, \"inserted\", initialSetHandler);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// MO handler is only set up **ONCE**\n\t\t\t\t\t\tsetupMO(this, function(){\n\t\t\t\t\t\t\tvar value = setData.get.call(this, \"attrValueLastVal\");\n\t\t\t\t\t\t\tattr.set(this, \"value\", value);\n\t\t\t\t\t\t\tdomDispatch.call(this, \"change\");\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\ttest: function(){\n\t\t\t\t\treturn formElements[this.nodeName];\n\t\t\t\t}\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tget: function(){\n\t\t\t\t\treturn collectSelectedOptions(this);\n\t\t\t\t},\n\t\t\t\tset: function(values){\n\t\t\t\t\tvalues = values || [];\n\n\t\t\t\t\t// set new DOM state\n\t\t\t\t\tmarkSelectedOptions(this, values);\n\n\t\t\t\t\t// store new DOM state\n\t\t\t\t\tsetData.set.call(this, \"stickyValues\", attr.get(this,\"values\") );\n\n\t\t\t\t\t// MO handler is only set up **ONCE**\n\t\t\t\t\t// TODO: should this be moved into addEventListener?\n\t\t\t\t\tsetupMO(this, function(){\n\n\t\t\t\t\t\t// Get the previous sticky state\n\t\t\t\t\t\tvar previousValues = setData.get.call(this,\n\t\t\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t\t\t// Set DOM to previous sticky state\n\t\t\t\t\t\tattr.set(this, \"values\", previousValues);\n\n\t\t\t\t\t\t// Get the new result after trying to maintain the sticky state\n\t\t\t\t\t\tvar currentValues = setData.get.call(this,\n\t\t\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t\t\t// If there are changes, trigger a `values` event.\n\t\t\t\t\t\tvar changes = diff(previousValues.slice().sort(),\n\t\t\t\t\t\t\tcurrentValues.slice().sort());\n\n\t\t\t\t\t\tif (changes.length) {\n\t\t\t\t\t\t\tdomDispatch.call(this, \"values\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\t\t\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\t\t\tvar localHandler = function(){\n\t\t\t\t\t\tdomDispatch.call(this, \"values\");\n\t\t\t\t\t};\n\n\t\t\t\t\tdomEvents.addEventListener.call(this, \"change\", localHandler);\n\t\t\t\t\taEL.call(this, eventName, handler);\n\n\t\t\t\t\treturn function(rEL){\n\t\t\t\t\t\tdomEvents.removeEventListener.call(this, \"change\", localHandler);\n\t\t\t\t\t\trEL.call(this, eventName, handler);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// These are elements whos default value we should set.\n\t\tdefaultValue: {input: true, textarea: true},\n\t\tsetAttrOrProp: function(el, attrName, val){\n\t\t\tattrName = attrName.toLowerCase();\n\t\t\tvar special = attr.special[attrName];\n\t\t\tif(special && special.isBoolean && !val) {\n\t\t\t\tthis.remove(el, attrName);\n\t\t\t} else {\n\t\t\t\tthis.set(el, attrName, val);\n\t\t\t}\n\t\t},\n\t\t// ## attr.set\n\t\t// Set the value an attribute on an element.\n\t\tset: function (el, attrName, val) {\n\t\t\tvar usingMutationObserver = isOfGlobalDocument(el) && MUTATION_OBSERVER();\n\t\t\tattrName = attrName.toLowerCase();\n\t\t\tvar oldValue;\n\t\t\t// In order to later trigger an event we need to compare the new value to the old value,\n\t\t\t// so here we go ahead and retrieve the old value for browsers that don't have native MutationObservers.\n\t\t\tif (!usingMutationObserver) {\n\t\t\t\toldValue = attr.get(el, attrName);\n\t\t\t}\n\n\t\t\tvar newValue;\n\t\t\tvar special = attr.special[attrName];\n\t\t\tvar setter = special && special.set;\n\t\t\tvar test = getSpecialTest(special);\n\n\t\t\t// First check if this is a special attribute with a setter.\n\t\t\t// Then run the special's test function to make sure we should\n\t\t\t// call its setter, and if so use the setter.\n\t\t\t// Otherwise fallback to setAttribute.\n\t\t\tif(typeof setter === \"function\" && test.call(el)) {\n\t\t\t\t// To distinguish calls with explicit undefined, e.g.:\n\t\t\t\t// - `attr.set(el, \"checked\")`\n\t\t\t\t// - `attr.set(el, \"checked\", undefined)`\n\t\t\t\tif (arguments.length === 2){\n\t\t\t\t\tnewValue = setter.call(el);\n\t\t\t\t} else {\n\t\t\t\t\tnewValue = setter.call(el, val);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattr.setAttribute(el, attrName, val);\n\t\t\t}\n\n\t\t\tif (!usingMutationObserver && newValue !== oldValue) {\n\t\t\t\tattr.trigger(el, attrName, oldValue);\n\t\t\t}\n\t\t},\n\t\tsetSelectValue: function(el, value){\n\t\t\tattr.set(el, \"value\", value);\n\t\t},\n\t\tsetAttribute: (function(){\n\t\t\tvar doc = getDocument();\n\t\t\tif(doc && document.createAttribute) {\n\t\t\t\ttry {\n\t\t\t\t\tdoc.createAttribute(\"{}\");\n\t\t\t\t} catch(e) {\n\t\t\t\t\tvar invalidNodes = {},\n\t\t\t\t\t\tattributeDummy = document.createElement('div');\n\n\t\t\t\t\treturn function(el, attrName, val){\n\t\t\t\t\t\tvar first = attrName.charAt(0),\n\t\t\t\t\t\t\tcachedNode,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tattr;\n\t\t\t\t\t\tif((first === \"{\" || first === \"(\" || first === \"*\") && el.setAttributeNode) {\n\t\t\t\t\t\t\tcachedNode = invalidNodes[attrName];\n\t\t\t\t\t\t\tif(!cachedNode) {\n\t\t\t\t\t\t\t\tattributeDummy.innerHTML = '<div ' + attrName + '=\"\"></div>';\n\t\t\t\t\t\t\t\tcachedNode = invalidNodes[attrName] = attributeDummy.childNodes[0].attributes[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnode = cachedNode.cloneNode();\n\t\t\t\t\t\t\tnode.value = val;\n\t\t\t\t\t\t\tel.setAttributeNode(node);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tattr = attrName.split(':');\n\n\t\t\t\t\t\t\tif(attr.length !== 1) {\n\t\t\t\t\t\t\t\tel.setAttributeNS(namespaces[attr[0]], attrName, val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tel.setAttribute(attrName, val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function(el, attrName, val){\n\t\t\t\tel.setAttribute(attrName, val);\n\t\t\t};\n\n\t\t})(),\n\t\t// ## attr.trigger\n\t\t// Used to trigger an \"attributes\" event on an element. Checks to make sure that someone is listening for the event and then queues a function to be called asynchronously using `setImmediate.\n\t\ttrigger: function (el, attrName, oldValue) {\n\t\t\tif (setData.get.call(el, \"canHasAttributesBindings\")) {\n\t\t\t\tattrName = attrName.toLowerCase();\n\t\t\t\treturn setImmediate(function () {\n\t\t\t\t\tdomDispatch.call(el, {\n\t\t\t\t\t\ttype: \"attributes\",\n\t\t\t\t\t\tattributeName: attrName,\n\t\t\t\t\t\ttarget: el,\n\t\t\t\t\t\toldValue: oldValue,\n\t\t\t\t\t\tbubbles: false\n\t\t\t\t\t}, []);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t// ## attr.get\n\t\t// Gets the value of an attribute. First checks if the property is an `attr.special` and if so calls the special getter. Otherwise uses `getAttribute` to retrieve the value.\n\t\tget: function (el, attrName) {\n\t\t\tattrName = attrName.toLowerCase();\n\n\t\t\tvar special = attr.special[attrName];\n\t\t\tvar getter = special && special.get;\n\t\t\tvar test = getSpecialTest(special);\n\n\t\t\tif(typeof getter === \"function\" && test.call(el)) {\n\t\t\t\treturn getter.call(el);\n\t\t\t} else {\n\t\t\t\treturn el.getAttribute(attrName);\n\t\t\t}\n\t\t},\n\t\t// ## attr.remove\n\t\t// Removes an attribute from an element. First checks attr.special to see if the attribute is special and has a setter. If so calls the setter with `undefined`. Otherwise `removeAttribute` is used.\n\t\t// If the attribute previously had a value and the browser doesn't support MutationObservers we then trigger an \"attributes\" event.\n\t\tremove: function (el, attrName) {\n\t\t\tattrName = attrName.toLowerCase();\n\t\t\tvar oldValue;\n\t\t\tif (!MUTATION_OBSERVER()) {\n\t\t\t\toldValue = attr.get(el, attrName);\n\t\t\t}\n\n\t\t\tvar special = attr.special[attrName];\n\t\t\tvar setter = special && special.set;\n\t\t\tvar remover = special && special.remove;\n\t\t\tvar test = getSpecialTest(special);\n\n\t\t\tif(typeof remover === \"function\" && test.call(el)) {\n\t\t\t\tremover.call(el);\n\t\t\t} else if(typeof setter === \"function\" && test.call(el)) {\n\t\t\t\tsetter.call(el, undefined);\n\t\t\t} else {\n\t\t\t\tel.removeAttribute(attrName);\n\t\t\t}\n\n\t\t\tif (!MUTATION_OBSERVER() && oldValue != null) {\n\t\t\t\tattr.trigger(el, attrName, oldValue);\n\t\t\t}\n\t\t},\n\t\t// ## attr.has\n\t\t// Checks if an element contains an attribute.\n\t\t// For browsers that support `hasAttribute`, creates a function that calls hasAttribute, otherwise creates a function that uses `getAttribute` to check that the attribute is not null.\n\t\thas: (function () {\n\t\t\tvar el = getDocument() && document.createElement('div');\n\t\t\tif (el && el.hasAttribute) {\n\t\t\t\treturn function (el, name) {\n\t\t\t\t\treturn el.hasAttribute(name);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn function (el, name) {\n\t\t\t\t\treturn el.getAttribute(name) !== null;\n\t\t\t\t};\n\t\t\t}\n\t\t})()\n\t};\n\nvar oldAddEventListener = domEvents.addEventListener;\ndomEvents.addEventListener = function(eventName, handler){\n\tvar special = attr.special[eventName];\n\n\tif(special && special.addEventListener) {\n\t\tvar teardown = special.addEventListener.call(this, eventName, handler,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toldAddEventListener);\n\t\tvar teardowns = setData.get.call(this, \"attrTeardowns\");\n\t\tif(!teardowns) {\n\t\t\tsetData.set.call(this, \"attrTeardowns\", teardowns = {});\n\t\t}\n\n\t\tif(!teardowns[eventName]) {\n\t\t\tteardowns[eventName] = [];\n\t\t}\n\n\t\tteardowns[eventName].push({\n\t\t\tteardown: teardown,\n\t\t\thandler: handler\n\t\t});\n\t\treturn;\n\t}\n\n\treturn oldAddEventListener.apply(this, arguments);\n};\n\nvar oldRemoveEventListener = domEvents.removeEventListener;\ndomEvents.removeEventListener = function(eventName, handler){\n\tvar special = attr.special[eventName];\n\tif(special && special.addEventListener) {\n\t\tvar teardowns = setData.get.call(this, \"attrTeardowns\");\n\t\tif(teardowns && teardowns[eventName]) {\n\t\t\tvar eventTeardowns = teardowns[eventName];\n\t\t\tfor(var i = 0, len = eventTeardowns.length; i < len; i++) {\n\t\t\t\tif(eventTeardowns[i].handler === handler) {\n\t\t\t\t\teventTeardowns[i].teardown.call(this, oldRemoveEventListener);\n\t\t\t\t\teventTeardowns.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(eventTeardowns.length === 0) {\n\t\t\t\tdelete teardowns[eventName];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\treturn oldRemoveEventListener.apply(this, arguments);\n};\n\nmodule.exports = exports = attr;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/attr/attr.js\n// module id = 24\n// module chunks = 0","var parser = require('can-view-parser');\nvar domEvents = require('can-util/dom/events/events');\nvar nodeLists = require('can-view-nodelist');\nvar makeFrag = require('can-util/dom/frag/frag');\nvar childNodes = require('can-util/dom/child-nodes/child-nodes');\n\nrequire(\"can-util/dom/events/removed/removed\");\n\nvar childMutationCallbacks = {};\n\n\n/**\n * @module {{}} can-view-live can-view-live\n * @parent can-infrastructure\n * @package ../package.json\n *\n * Setup live-binding between the DOM and a compute manually.\n *\n * @option {Object} An object with the live-binding methods:\n * [can-view-live.html], [can-view-live.list], [can-view-live.text], and\n * [can-view-live.attr].\n *\n * @release 2.0.4\n *\n * @body\n *\n * ## Use\n *\n *  [can-view-live] is an object with utility methods for setting up\n *  live-binding in relation to different parts of the DOM and DOM elements.  For\n *  example, to make an `<h2>`'s text stay live with\n *  a compute:\n *\n *   var live = require(\"can-view-live\");\n *   var text = canCompute(\"Hello World\");\n *   var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n *   live.text(textNode, text);\n *\n *\n */\nvar live = {\n\tsetup: function (el, bind, unbind) {\n\t\t// #### setup\n\t\t// Setup a live listener on an element that binds now,\n\t\t//  but unbinds when an element is no longer in the DOM \n\t\tvar tornDown = false,\n\t\t\tteardown = function () {\n\t\t\t\t// Removing an element can call teardown which\n\t\t\t\t// unregister the nodeList which calls teardown\n\t\t\t\tif (!tornDown) {\n\t\t\t\t\ttornDown = true;\n\t\t\t\t\tunbind(data);\n\t\t\t\t\tdomEvents.removeEventListener.call(el, 'removed', teardown);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}, data = {\n\t\t\t\tteardownCheck: function (parent) {\n\t\t\t\t\treturn parent ? false : teardown();\n\t\t\t\t}\n\t\t\t};\n\t\tdomEvents.addEventListener.call(el, 'removed', teardown);\n\t\tbind(data);\n\t\treturn data;\n\t},\n\t// #### listen\n\t// Calls setup, but presets bind and unbind to\n\t// operate on a compute\n\tlisten: function (el, compute, change) {\n\t\treturn live.setup(el, function () {\n\t\t\tcompute.computeInstance.addEventListener('change', change);\n\t\t}, function (data) {\n\t\t\tcompute.computeInstance.removeEventListener('change', change);\n\t\t\tif (data.nodeList) {\n\t\t\t\tnodeLists.unregister(data.nodeList);\n\t\t\t}\n\t\t});\n\t},\n\t// #### getAttributeParts\n\t// Breaks up a string like foo='bar' into an object of {\"foo\": \"bar\"} pairs\n\t// See can-view-parser for more about attrStart/attrEnd/attrValue\n\tgetAttributeParts: function (newVal) {\n\t\tvar attrs = {},\n\t\t\tattr;\n\t\tparser.parseAttrs(newVal,{\n\t\t\tattrStart: function(name){\n\t\t\t\tattrs[name] = \"\";\n\t\t\t\tattr = name;\n\t\t\t},\n\t\t\tattrValue: function(value){\n\t\t\t\tattrs[attr] += value;\n\t\t\t},\n\t\t\tattrEnd: function(){}\n\t\t});\n\t\treturn attrs;\n\t},\n\t// #### isNode\n\t// Checks a possible node object for the nodeType property\n\tisNode: function(obj){\n\t\treturn obj && obj.nodeType;\n\t},\n\t// #### addTextNodeIfNoChildren\n\t// Append an empty text node to a parent with no children;\n\t//  do nothing if the parent already has children.\n\taddTextNodeIfNoChildren: function(frag){\n\t\tif(!frag.firstChild) {\n\t\t\tfrag.appendChild(frag.ownerDocument.createTextNode(\"\"));\n\t\t}\n\t},\n\t// #### registerChildMutationCallback\n\t// Getter/setter for mutation callbacks\n\tregisterChildMutationCallback: function(tag, callback){\n\t\tif(callback) {\n\t\t\tchildMutationCallbacks[tag] = callback;\n\t\t} else {\n\t\t\treturn childMutationCallbacks[tag];\n\t\t}\n\t},\n\tcallChildMutationCallback: function(el) {\n\t\tvar callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];\n\t\tif(callback) {\n\t\t\tcallback(el);\n\t\t}\n\t},\n\n\n\t/**\n\t * @function can.view.live.replace\n\t * @parent can.view.live\n\t * @release 2.0.4\n\t *\n\t * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\n\t * correct.\n\t *\n\t * @param {Array.<HTMLElement>} nodes An array of elements.  There should typically be one element.\n\t * @param {String|HTMLElement|DocumentFragment} val The content that should replace\n\t * `nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n\t *\n\t * @param {function} [teardown] A callback if these elements are torn down.\n\t */\n\treplace: function (nodes, val, teardown) {\n\t\t// #### replace\n\t\t// Replaces one element with some content while keeping nodeLists data\n\t\t// correct.\n\t\t// \n\t\t// Take a copy of old nodeList\n\t\tvar oldNodes = nodes.slice(0),\n\t\t\tfrag = makeFrag(val);\n\t\t// Register a teardown callback\n\t\tnodeLists.register(nodes, teardown);\n\t\t// Mark each node as belonging to the node list.\n\t\tnodeLists.update(nodes, childNodes(frag));\n\t\t// Replace old nodes with new on the DOM\n\t\tnodeLists.replace(oldNodes, frag);\n\t\treturn nodes;\n\t},\n\t// #### getParentNode\n\t// Return default parent if el is a fragment, el's parent otherwise\n\tgetParentNode: function (el, defaultParentNode) {\n\t\treturn defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;\n\t},\n\t// #### makeString\n\t// any -> string converter (including nullish)\n\tmakeString: function(txt){\n\t\treturn txt == null ? \"\" : \"\"+txt;\n\t}\n};\n\nmodule.exports = live;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/core.js\n// module id = 25\n// module chunks = 0","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   4.1.0\n */\n\n\n\n// WEBPACK FOOTER //\n// config/versionTemplate.txt","'use strict';\n\nexport { objectOrFunction };\nexport { isFunction };\nexport { isMaybeThenable };\n\nfunction objectOrFunction(x) {\n  return typeof x === 'function' || typeof x === 'object' && x !== null;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nfunction isMaybeThenable(x) {\n  return typeof x === 'object' && x !== null;\n}\n\nvar _isArray = undefined;\nif (!Array.isArray) {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n} else {\n  _isArray = Array.isArray;\n}\n\nvar isArray = _isArray;\nexport { isArray };\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/utils.js","'use strict';\n\nexport { setScheduler };\nexport { setAsap };\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nexport { asap };\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = r('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/asap.js","'use strict';\n\nexport default then;\nimport { invokeCallback, subscribe, FULFILLED, REJECTED, noop, makePromise, PROMISE_ID } from './-internal';\n\nimport { asap } from './asap';\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/then.js","'use strict';\n\nexport default resolve;\nimport { noop, resolve as _resolve } from '../-internal';\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  _resolve(promise, object);\n  return promise;\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/promise/resolve.js","'use strict';\n\nimport { objectOrFunction, isFunction } from './utils';\n\nimport { asap } from './asap';\n\nimport originalThen from './then';\nimport originalResolve from './promise/resolve';\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nexport { PROMISE_ID };\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then) {\n  if (maybeThenable.constructor === promise.constructor && then === originalThen && maybeThenable.constructor.resolve === originalResolve) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then === GET_THEN_ERROR) {\n      reject(promise, GET_THEN_ERROR.error);\n      GET_THEN_ERROR.error = null;\n    } else if (then === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then)) {\n      handleForeignThenable(promise, maybeThenable, then);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value.error = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      resolve(promise, value);\n    } else if (failed) {\n      reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nexport { nextId, makePromise, getThen, noop, resolve, reject, fulfill, subscribe, publish, publishRejection, initializePromise, invokeCallback, FULFILLED, REJECTED, PENDING, handleMaybeThenable };\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/-internal.js","'use strict';\n\nimport { isArray, isMaybeThenable } from './utils';\n\nimport { noop, reject, fulfill, subscribe, FULFILLED, REJECTED, PENDING, getThen, handleMaybeThenable } from './-internal';\n\nimport then from './then';\nimport Promise from './promise';\nimport originalResolve from './promise/resolve';\nimport originalThen from './then';\nimport { makePromise, PROMISE_ID } from './-internal';\n\nexport default Enumerator;\nfunction Enumerator(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this._input = input;\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate();\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n};\n\nEnumerator.prototype._enumerate = function () {\n  var length = this.length;\n  var _input = this._input;\n\n  for (var i = 0; this._state === PENDING && i < length; i++) {\n    this._eachEntry(_input[i], i);\n  }\n};\n\nEnumerator.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve = c.resolve;\n\n  if (resolve === originalResolve) {\n    var _then = getThen(entry);\n\n    if (_then === originalThen && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve) {\n        return resolve(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve(entry), i);\n  }\n};\n\nEnumerator.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/enumerator.js","'use strict';\n\nexport default all;\nimport Enumerator from '../enumerator';\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/promise/all.js","\"use strict\";\n\nexport default race;\nimport { isArray } from \"../utils\";\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/promise/race.js","'use strict';\n\nexport default reject;\nimport { noop, reject as _reject } from '../-internal';\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  _reject(promise, reason);\n  return promise;\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/promise/reject.js","'use strict';\n\nexport default Promise;\n\nimport { isFunction } from './utils';\n\nimport { noop, nextId, PROMISE_ID, initializePromise } from './-internal';\n\nimport { asap, setAsap, setScheduler } from './asap';\n\nimport all from './promise/all';\nimport race from './promise/race';\nimport Resolve from './promise/resolve';\nimport Reject from './promise/reject';\nimport then from './then';\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = Resolve;\nPromise.reject = Reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\nPromise.prototype = {\n  constructor: Promise,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/promise.js","/*global self*/\n'use strict';\n\nexport default polyfill;\nimport Promise from './promise';\nfunction polyfill() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise;\n}\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise/polyfill.js","'use strict';\n\nimport Promise from './es6-promise/promise';\nimport polyfill from './es6-promise/polyfill';\n\n// Strange compat..\nPromise.polyfill = polyfill;\nPromise.Promise = Promise;\nexport default Promise;\n\n\n// WEBPACK FOOTER //\n// lib/es6-promise.js","\"use strict\";\nvar assign = require(\"can-util/js/assign/assign\");\nvar deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\nvar dev = require(\"can-util/js/dev/dev\");\nvar makeArray = require(\"can-util/js/make-array/make-array\");\nvar types = require('can-types');\nvar namespace = require('can-namespace');\n//!steal-remove-start\nvar CanString = require('can-util/js/string/string');\nvar reservedWords = {\n\t\"abstract\": true,\n\t\"boolean\": true,\n\t\"break\": true,\n\t\"byte\": true,\n\t\"case\": true,\n\t\"catch\": true,\n\t\"char\": true,\n\t\"class\": true,\n\t\"const\": true,\n\t\"continue\": true,\n\t\"debugger\": true,\n\t\"default\": true,\n\t\"delete\": true,\n\t\"do\": true,\n\t\"double\": true,\n\t\"else\": true,\n\t\"enum\": true,\n\t\"export\": true,\n\t\"extends\": true,\n\t\"false\": true,\n\t\"final\": true,\n\t\"finally\": true,\n\t\"float\": true,\n\t\"for\": true,\n\t\"function\": true,\n\t\"goto\": true,\n\t\"if\": true,\n\t\"implements\": true,\n\t\"import\": true,\n\t\"in\": true,\n\t\"instanceof\": true,\n\t\"int\": true,\n\t\"interface\": true,\n\t\"let\": true,\n\t\"long\": true,\n\t\"native\": true,\n\t\"new\": true,\n\t\"null\": true,\n\t\"package\": true,\n\t\"private\": true,\n\t\"protected\": true,\n\t\"public\": true,\n\t\"return\": true,\n\t\"short\": true,\n\t\"static\": true,\n\t\"super\": true,\n\t\"switch\": true,\n\t\"synchronized\": true,\n\t\"this\": true,\n\t\"throw\": true,\n\t\"throws\": true,\n\t\"transient\": true,\n\t\"true\": true,\n\t\"try\": true,\n\t\"typeof\": true,\n\t\"var\": true,\n\t\"void\": true,\n\t\"volatile\": true,\n\t\"while\": true,\n\t\"with\": true\n};\nvar constructorNameRegex = /[^A-Z0-9_]/gi;\n//!steal-remove-end\n\n// ## construct.js\n// `Construct`\n// _This is a modified version of\n// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).\n// It provides class level inheritance and callbacks._\n// A private flag used to initialize a new class instance without\n// initializing it's bindings.\nvar initializing = 0;\n\n//!steal-remove-start\nvar namedCtor = (function(cache){\n\treturn function(name, fn) {\n\t\treturn ((name in cache) ? cache[name] : cache[name] = new Function(\n\t\t\t\"__\", \"function \"+name+\"(){return __.apply(this,arguments)};return \"+name\n\t\t))( fn );\n\t};\n}({}));\n//!steal-remove-end\n\n/**\n * @add can-construct\n */\nvar Construct = function () {\n\tif (arguments.length) {\n\t\treturn Construct.extend.apply(Construct, arguments);\n\t}\n};\n\nvar canGetDescriptor;\ntry {\n\tObject.getOwnPropertyDescriptor({});\n\tcanGetDescriptor = true;\n} catch(e) {\n\tcanGetDescriptor = false;\n}\n\nvar getDescriptor = function(newProps, name) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(newProps, name);\n\t\tif(descriptor && (descriptor.get || descriptor.set)) {\n\t\t\treturn descriptor;\n\t\t}\n\t\treturn null;\n\t},\n\tinheritGetterSetter = function(newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\t\tvar descriptor;\n\n\t\tfor (var name in newProps) {\n\t\t\tif( (descriptor = getDescriptor(newProps, name)) ) {\n\t\t\t\tthis._defineProperty(addTo, oldProps, name, descriptor);\n\t\t\t} else {\n\t\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t\t}\n\t\t}\n\t},\n\tsimpleInherit = function (newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\n\t\tfor (var name in newProps) {\n\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t}\n\t};\n/**\n * @static\n */\nassign(Construct, {\n\t/**\n\t * @property {Boolean} can-construct.constructorExtends constructorExtends\n\t * @parent can-construct.static\n\t *\n\t * @description\n\t * Toggles the behavior of a constructor function called\n\t * without the `new` keyword to extend the constructor function or\n\t * create a new instance.\n\t *\n\t * ```js\n\t * var animal = Animal();\n\t * // vs\n\t * var animal = new Animal();\n\t * ```\n\t *\n\t * @body\n\t *\n\t * If `constructorExtends` is:\n\t *\n\t *  - `true` - the constructor extends\n\t *  - `false` - a new instance of the constructor is created\n\t *\n\t * This property defaults to false.\n\t *\n\t * Example of constructExtends as `true`:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: true // the constructor extends\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var Pony = Animal({\n\t *   gallop: function () {\n\t *      console.log(\"Galloping!!\");\n\t *   }\n\t * }); // Pony is now a constructor function extended from Animal\n\t *\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * var gertrude = new Pony(); // gertrude is a new instance of Pony\n\t * gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n\t * gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n\t *```\n\t *\n\t * The default behavior is shown in the example below:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: false // the constructor does NOT extend\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var pony = Animal(); // pony is a new instance of Animal\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * pony.sayHi() // \"hai!\"\n\t * frank.sayHi() // \"hai!\"\n\t *```\n\t * By default to extend a constructor, you must use [can-construct.extend extend].\n\t */\n\tconstructorExtends: true,\n\t/**\n\t * @function can-construct.newInstance newInstance\n\t * @parent can-construct.static\n\t *\n\t * @description Returns an instance of `Construct`. This method\n\t * can be overridden to return a cached instance.\n\t *\n\t * @signature `Construct.newInstance([...args])`\n\t *\n\t * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\n\t * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\n\t * instead.\n\t * @return {class} instance of the class\n\t *\n\t * @body\n\t * Creates a new instance of the constructor function. This method is useful for creating new instances\n\t * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n\t * __new__ operator.\n\t *\n\t * ## Example\n\t *\n\t * The following creates a `Person` Construct and overrides `newInstance` to cache all\n\t * instances of Person to prevent duplication. If the properties of a new Person match an existing one it\n\t * will return a reference to the previously created object, otherwise it returns a new object entirely.\n\t *\n\t * ```js\n\t * // define and create the Person constructor\n\t * var Person = Construct.extend({\n\t *   init : function(first, middle, last) {\n\t *     this.first = first;\n\t *     this.middle = middle;\n\t *     this.last = last;\n\t *   }\n\t * });\n\t *\n\t * // store a reference to the original newInstance function\n\t * var _newInstance = Person.newInstance;\n\t *\n\t * // override Person's newInstance function\n\t * Person.newInstance = function() {\n\t *   // if cache does not exist make it an new object\n\t *   this.__cache = this.__cache || {};\n\t *   // id is a stingified version of the passed arguments\n\t *   var id = JSON.stringify(arguments);\n\t *\n\t *   // look in the cache to see if the object already exists\n\t *   var cachedInst = this.__cache[id];\n\t *   if(cachedInst) {\n\t *     return cachedInst;\n\t *   }\n\t *\n\t *   //otherwise call the original newInstance function and return a new instance of Person.\n\t *   var newInst = _newInstance.apply(this, arguments);\n\t *   this.__cache[id] = newInst;\n\t *   return newInst;\n\t * };\n\t *\n\t * // create two instances with the same arguments\n\t * var justin = new Person('Justin', 'Barry', 'Meyer'),\n\t *\t\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\t *\n\t * console.log(justin === brian); // true - both are references to the same instance\n\t * ```\n\t *\n\t */\n\tnewInstance: function () {\n\t\t// Get a raw instance object (`init` is not called).\n\t\tvar inst = this.instance(),\n\t\t\targs;\n\t\t// Call `setup` if there is a `setup`\n\t\tif (inst.setup) {\n\t\t\tObject.defineProperty(inst,\"__inSetup\",{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\targs = inst.setup.apply(inst, arguments);\n\t\t\tif (args instanceof Construct.ReturnValue){\n\t\t\t\treturn args.value;\n\t\t\t}\n\t\t\tinst.__inSetup = false;\n\t\t}\n\t\t// Call `init` if there is an `init`\n\t\t// If `setup` returned `args`, use those as the arguments\n\t\tif (inst.init) {\n\t\t\tinst.init.apply(inst, args || arguments);\n\t\t}\n\t\treturn inst;\n\t},\n\t// Overwrites an object with methods. Used in the `super` plugin.\n\t// `newProps` - New properties to add.\n\t// `oldProps` - Where the old properties might be (used with `super`).\n\t// `addTo` - What we are adding to.\n\t_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,\n\n\t// Adds a `defineProperty` with the given name and descriptor\n\t// Will only ever be called if ES5 is supported\n\t_defineProperty: function(what, oldProps, propName, descriptor) {\n\t\tObject.defineProperty(what, propName, descriptor);\n\t},\n\n\t// used for overwriting a single property.\n\t// this should be used for patching other objects\n\t// the super plugin overwrites this\n\t_overwrite: function (what, oldProps, propName, val) {\n\t\tObject.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});\n\t},\n\t// Set `defaults` as the merger of the parent `defaults` and this\n\t// object's `defaults`. If you overwrite this method, make sure to\n\t// include option merging logic.\n\t/**\n\t * @function can-construct.setup setup\n\t * @parent can-construct.static\n\t *\n\t * @description Perform initialization logic for a constructor function.\n\t *\n\t * @signature `Construct.setup(base, fullName, staticProps, protoProps)`\n\t *\n\t * A static `setup` method provides inheritable setup functionality\n\t * for a Constructor function. The following example\n\t * creates a Group constructor function.  Any constructor\n\t * functions that inherit from Group will be added to\n\t * `Group.childGroups`.\n\t *\n\t *\n\t *     Group = Construct.extend({\n\t *       setup: function(Construct, fullName, staticProps, protoProps){\n\t *         this.childGroups = [];\n\t *         if(Construct !== Construct){\n\t *           this.childGroups.push(Construct)\n\t *         }\n\t *         Construct.setup.apply(this, arguments)\n\t *       }\n\t *     },{})\n\t *     var Flock = Group.extend(...)\n\t *     Group.childGroups[0] //-> Flock\n\t *\n\t * @param {constructor} base The base constructor that is being inherited from.\n\t * @param {String} fullName The name of the new constructor.\n\t * @param {Object} staticProps The static properties of the new constructor.\n\t * @param {Object} protoProps The prototype properties of the new constructor.\n\t *\n\t * @body\n\t * The static `setup` method is called immediately after a constructor\n\t * function is created and\n\t * set to inherit from its base constructor. It is useful for setting up\n\t * additional inheritance work.\n\t * Do not confuse this with the prototype `[can-construct::setup]` method.\n\t *\n\t * ## Example\n\t *\n\t * This `Parent` class adds a reference to its base class to itself, and\n\t * so do all the classes that inherit from it.\n\t *\n\t * ```js\n\t * Parent = Construct.extend({\n\t *   setup : function(base, fullName, staticProps, protoProps){\n\t *     this.base = base;\n\t *\n\t *     // call base functionality\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{});\n\t *\n\t * Parent.base; // Construct\n\t *\n\t * Child = Parent({});\n\t *\n\t * Child.base; // Parent\n\t * ```\n\t */\n\tsetup: function (base) {\n\t\tthis.defaults = deepAssign(true, {}, base.defaults, this.defaults);\n\t},\n\t// Create's a new `class` instance without initializing by setting the\n\t// `initializing` flag.\n\tinstance: function () {\n\t\t// Prevents running `init`.\n\t\tinitializing = 1;\n\t\tvar inst = new this();\n\t\t// Allow running `init`.\n\t\tinitializing = 0;\n\t\treturn inst;\n\t},\n\t// Extends classes.\n\t/**\n\t * @function can-construct.extend extend\n\t * @parent can-construct.static\n\t *\n\t * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`\n\t *\n\t * Extends `Construct`, or constructor functions derived from `Construct`,\n\t * to create a new constructor function. Example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   sayHi: function(){\n\t *     console.log(\"hi\")\n\t *   }\n\t * });\n\t *\n\t * var animal = new Animal()\n\t * animal.sayHi();\n\t * ```\n\t *\n\t * @param {String} [name] Adds a name to the constructor function so\n\t * it is nicely labeled in the developer tools. The following:\n\t *\n\t *     Construct.extend(\"ConstructorName\",{})\n\t *\n\t * returns a constructur function that will show up as `ConstructorName`\n\t * in the developer tools.\n\t * It also sets \"ConstructorName\" as [can-construct.shortName shortName].\n\t *\n\t * @param {Object} [staticProperties] Properties that are added the constructor\n\t * function directly. For example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   findAll: function(){\n\t *     return can.ajax({url: \"/animals\"})\n\t *   }\n\t * },{}); // need to pass an empty instanceProperties object\n\t *\n\t * Animal.findAll().then(function(json){ ... })\n\t * ```\n\t *\n\t * The [can-construct.setup static setup] method can be used to\n\t * specify inheritable behavior when a Constructor function is created.\n\t *\n\t * @param {Object} instanceProperties Properties that belong to\n\t * instances made with the constructor. These properties are added to the\n\t * constructor's `prototype` object. Example:\n\t *\n\t *     var Animal = Construct.extend({\n\t *\t\t  findAll: function() {\n\t *\t\t\treturn can.ajax({url: \"/animals\"});\n\t *\t\t  }\n\t *     },{\n\t *       init: function(name) {\n\t *         this.name = name;\n\t *       },\n\t *       sayHi: function() {\n\t *         console.log(this.name,\" says hai!\");\n\t *       }\n\t *     })\n\t *     var pony = new Animal(\"Gertrude\");\n\t *     pony.sayHi(); // \"Gertrude says hai!\"\n\t *\n\t * The [can-construct::init init] and [can-construct::setup setup] properties\n\t * are used for initialization.\n\t *\n\t * @return {function} The constructor function.\n\t *\n\t * ```js\n\t *\tvar Animal = Construct.extend(...);\n\t *\tvar pony = new Animal(); // Animal is a constructor function\n\t * ```\n\t * @body\n\t * ## Inheritance\n\t * Creating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\n\t * with the new function's static and instance properties. For example, we want our `Snake` to\n\t * be an `Animal`, but there are some differences:\n\t *\n\t *\n\t *     var Snake = Animal.extend({\n\t *         legs: 0\n\t *     }, {\n\t *         init: function() {\n\t *             Animal.prototype.init.call(this, 'ssssss');\n\t *         },\n\t *         slither: function() {\n\t *             console.log('slithering...');\n\t *         }\n\t *     });\n\t *\n\t *     var baslisk = new Snake();\n\t *     baslisk.speak();   // \"ssssss\"\n\t *     baslisk.slither(); // \"slithering...\"\n\t *     baslisk instanceof Snake;  // true\n\t *     baslisk instanceof Animal; // true\n\t *\n\t *\n\t * ## Static properties and inheritance\n\t *\n\t * If you pass all three arguments to Construct, the second one will be attached directy to the\n\t * constructor, allowing you to imitate static properties and functions. You can access these\n\t * properties through the `[can-construct::constructor this.constructor]` property.\n\t *\n\t * Static properties can get overridden through inheritance just like instance properties. In the example below,\n\t * we override both the legs static property as well as the the init function for each instance:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *     legs: 4\n\t * }, {\n\t *     init: function(sound) {\n\t *         this.sound = sound;\n\t *     },\n\t *     speak: function() {\n\t *         console.log(this.sound);\n\t *     }\n\t * });\n\t *\n\t * var Snake = Animal.extend({\n\t *     legs: 0\n\t * }, {\n\t *     init: function() {\n\t *         this.sound = 'ssssss';\n\t *     },\n\t *     slither: function() {\n\t *         console.log('slithering...');\n\t *     }\n\t * });\n\t *\n\t * Animal.legs; // 4\n\t * Snake.legs; // 0\n\t * var dog = new Animal('woof');\n\t * var blackMamba = new Snake();\n\t * dog.speak(); // 'woof'\n\t * blackMamba.speak(); // 'ssssss'\n\t * ```\n\t * \n\t * ## Alternative value for a new instance\n\t * \n\t * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.\n\t * For example, you want your class to act as a singleton, or check whether an item with the given id was already\n\t * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\t * \n\t * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\t * \n\t * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\n\t * the new data into the existing instance and return the updated instance.\n\t * \n\t * ```\n\t * var myStore = {};\n\t * \n\t * var Item = Construct.extend({\n\t *     setup: function(params){\n\t *         if (myStore[params.id]){\n\t *             var item = myStore[params.id];\n\t *             \n\t *             // Merge new data to the existing instance:\n\t *             Object.assign(item, params);\n\t *             \n\t *             // Return the updated item:\n\t *             return new Construct.ReturnValue( item );\n\t *         } else {\n\t *             // Save to cache store:\n\t *             myStore[this.id] = this;\n\t *             \n\t *             return [params];\n\t *         }\n\t *     },\n\t *     init: function(params){\n\t *         Object.assign(this, params);\n\t *     }\n\t * });\n\t * \n\t * var item_1  = new Item( {id: 1, name: \"One\"} );\n\t * var item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n\t * ```\n\t */\n\textend: function (name, staticProperties, instanceProperties) {\n\t\tvar shortName = name,\n\t\t\tklass = staticProperties,\n\t\t\tproto = instanceProperties;\n\n\t\t// Figure out what was passed and normalize it.\n\t\tif (typeof shortName !== 'string') {\n\t\t\tproto = klass;\n\t\t\tklass = shortName;\n\t\t\tshortName = null;\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto = klass;\n\t\t\tklass = null;\n\t\t}\n\t\tproto = proto || {};\n\t\tvar _super_class = this,\n\t\t\t_super = this.prototype,\n\t\t\tConstructor, prototype;\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the init constructor).\n\t\tprototype = this.instance();\n\t\t// Copy the properties over onto the new prototype.\n\t\tConstruct._inherit(proto, _super, prototype);\n\n\t\tif(shortName) {\n\n\t\t} else if(klass && klass.shortName) {\n\t\t\tshortName = klass.shortName;\n\t\t} else if(this.shortName) {\n\t\t\tshortName = this.shortName;\n\t\t}\n\t\t// We want constructor.name to be the same as shortName, within\n\t\t// the bounds of what the JS VM will allow (meaning no non-word characters).\n\t\t// new Function() is significantly faster than eval() here.\n\n\t\t// Strip semicolons\n\t\t//!steal-remove-start\n\t\tvar constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';\n\t\tif(reservedWords[constructorName]) {\n\t\t\tconstructorName = CanString.capitalize(constructorName);\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// The dummy class constructor.\n\t\tfunction init() {\n\t\t\t/* jshint validthis: true */\n\t\t\t// All construction is actually done in the init method.\n\t\t\tif (!initializing) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(!this || (this.constructor !== Constructor) &&\n\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\targuments.length && Constructor.constructorExtends) {\n\t\t\t\t\tdev.warn('can/construct/construct.js: extending a Construct without calling extend');\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn (!this || this.constructor !== Constructor) &&\n\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\targuments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :\n\t\t\t\t// We are being called with `new`.\n\t\t\t\tConstructor.newInstance.apply(Constructor, arguments);\n\t\t\t}\n\t\t}\n\t\tConstructor = typeof namedCtor === \"function\" ?\n\t\t\tnamedCtor( constructorName, init ) :\n\t\t\tfunction() { return init.apply(this, arguments); };\n\n\t\t// Copy old stuff onto class (can probably be merged w/ inherit)\n\t\tfor (var propName in _super_class) {\n\t\t\tif (_super_class.hasOwnProperty(propName)) {\n\t\t\t\tConstructor[propName] = _super_class[propName];\n\t\t\t}\n\t\t}\n\t\t// Copy new static properties on class.\n\t\tConstruct._inherit(klass, _super_class, Constructor);\n\n\t\t// Set things that shouldn't be overwritten.\n\t\tassign(Constructor, {\n\t\t\tconstructor: Constructor,\n\t\t\tprototype: prototype\n\t\t\t/**\n\t\t\t * @property {String} can-construct.shortName shortName\n\t\t\t * @parent can-construct.static\n\t\t\t *\n\t\t\t * If you pass a name when creating a Construct, the `shortName` property will be set to the\n\t\t\t * name.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var MyConstructor = Construct.extend(\"MyConstructor\",{},{});\n\t\t\t * MyConstructor.shortName // \"MyConstructor\"\n\t\t\t * ```\n\t\t\t */\n\t\t});\n\n\t\tif (shortName !== undefined) {\n\t\t\tConstructor.shortName = shortName;\n\t\t}\n\t\t// Make sure our prototype looks nice.\n\t\tConstructor.prototype.constructor = Constructor;\n\t\t// Call the class `setup` and `init`\n\t\tvar t = [_super_class].concat(makeArray(arguments)),\n\t\t\targs = Constructor.setup.apply(Constructor, t);\n\t\tif (Constructor.init) {\n\t\t\tConstructor.init.apply(Constructor, args || t);\n\t\t}\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\treturn Constructor; //\n\t\t/**\n\t\t * @property {Object} can-construct.prototype.constructor constructor\n\t\t * @parent can-construct.prototype\n\t\t *\n\t\t * A reference to the constructor function that created the instance. This allows you to access\n\t\t * the constructor's static properties from an instance.\n\t\t *\n\t\t * @body\n\t\t * ## Example\n\t\t *\n\t\t * This Construct has a static counter that counts how many instances have been created:\n\t\t *\n\t\t * ```js\n\t\t * var Counter = Construct.extend({\n\t\t *     count: 0\n\t\t * }, {\n\t\t *     init: function() {\n\t\t *         this.constructor.count++;\n\t\t *     }\n\t\t * });\n\t\t *\n\t\t * var childCounter = new Counter();\n\t\t * console.log(childCounter.constructor.count); // 1\n\t\t * console.log(Counter.count); // 1\n\t\t * ```\n\t\t */\n\t},\n\t/**\n\t * @function can-construct.ReturnValue ReturnValue\n\t * @parent can-construct.static\n\t * \n\t * Use to overwrite the return value of new Construct(...).\n\t * \n\t * @signature `new Construct.ReturnValue( value )`\n\t * \n\t *   This constructor function can be used for creating a return value of the `setup` method.\n\t *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n\t *   If it is then its `value` will be used as the new instance.\n\t * \n\t *   @param {Object} value A value to be used for a new instance instead of a new object.\n\t * \n\t *   ```\n\t *   var Student = function( name, school ){\n\t *       this.name = name;\n\t *       this.school = school;\n\t *   } \n\t * \n\t *   var Person = Construct.extend({\n\t *       setup: function( options ){\n\t *           if (options.school){\n\t *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n\t *           } else {\n\t *               return [options];\n\t *           }\n\t *       }\n\t *   });\n\t * \n\t *   var myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\t * \n\t *   myPerson instanceof Student // => true\n\t *   ```\n   */\n\tReturnValue: function(value){\n\t\tthis.value = value;\n\t}\n});\n/**\n * @function can-construct.prototype.setup setup\n * @parent can-construct.prototype\n *\n * @signature `construct.setup(...args)`\n *\n * A setup function for the instantiation of a constructor function.\n *\n * @param {*} args The arguments passed to the constructor.\n *\n * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as\n * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\n * instance's value will be returned as the result of calling new Construct(). The following example always makes\n * sure that init is called with a jQuery wrapped element:\n *\n * ```js\n * \tWidgetFactory = Construct.extend({\n * \t\t\tsetup: function(element){\n * \t\t\t\t\treturn [$(element)]\n * \t\t\t}\n * \t});\n *\n * \tMyWidget = WidgetFactory.extend({\n * \t\t\tinit: function($el){\n * \t\t\t\t\t$el.html(\"My Widget!!\")\n * \t\t\t}\n * \t});\n *  ```\n *\n * Otherwise, the arguments to the\n * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n *\n * @body\n *\n * ## Deciding between `setup` and `init`\n *\n *\n * Usually, you should use [can-construct::init init] to do your constructor function's initialization.\n * You should, instead, use `setup` when:\n *\n *   - there is initialization code that you want to run before the inheriting constructor's\n *     `init` method is called.\n *   - there is initialization code that should run whether or not inheriting constructors\n *     call their base's `init` methods.\n *   - you want to modify the arguments that will get passed to `init`.\n *\n */\nConstruct.prototype.setup = function () {};\n/**\n * @function can-construct.prototype.init init\n * @parent can-construct.prototype\n *\n * @description Called when a new instance of a Construct is created.\n *\n * @signature `construct.init(...args)`\n * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n *\n * @body\n * If a prototype `init` method is provided, `init` is called when a new Construct is created---\n * after [can-construct::setup]. The `init` method is where the bulk of your initialization code\n * should go. A common thing to do in `init` is save the arguments passed into the constructor.\n *\n * ## Examples\n *\n * First, we'll make a Person constructor that has a first and last name:\n *\n * ```js\n * var Person = Construct.extend({\n *     init: function(first, last) {\n *         this.first = first;\n *         this.last  = last;\n *     }\n * });\n *\n * var justin = new Person(\"Justin\", \"Meyer\");\n * justin.first; // \"Justin\"\n * justin.last; // \"Meyer\"\n * ```\n *\n * Then, we'll extend Person into Programmer, and add a favorite language:\n *\n * ```js\n * var Programmer = Person.extend({\n *     init: function(first, last, language) {\n *         // call base's init\n *         Person.prototype.init.apply(this, arguments);\n *\n *         // other initialization code\n *         this.language = language;\n *     },\n *     bio: function() {\n *         return \"Hi! I'm \" + this.first + \" \" + this.last +\n *             \" and I write \" + this.language + \".\";\n *     }\n * });\n *\n * var brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\n * brian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n * ```\n *\n * ## Modified Arguments\n *\n * [can-construct::setup] is able to modify the arguments passed to `init`.\n * If you aren't receiving the arguments you passed to `new Construct(args)`,\n * check that they aren't being changed by `setup` along\n * the inheritance chain.\n */\nConstruct.prototype.init = function () {};\n\nvar oldIsConstructor = types.isConstructor;\ntypes.isConstructor = function(obj){\n\treturn obj.prototype instanceof Construct || oldIsConstructor.call(null, obj);\n};\n\n\nmodule.exports = namespace.Construct = Construct;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-construct/can-construct.js\n// module id = 27\n// module chunks = 0","//\n// This provides helper utilities for Mustache processing. Currently,\n// only stache uses these helpers.  Ideally, these utilities could be used\n// in other libraries implementing Mustache-like features.\nvar live = require('can-view-live');\nvar nodeLists = require('can-view-nodelist');\nvar compute = require('can-compute');\nvar Observation = require('can-observation');\n\nvar utils = require('./utils');\nvar expression = require('./expression');\n\nvar types = require(\"can-types\");\nvar frag = require(\"can-util/dom/frag/frag\");\nvar attr = require(\"can-util/dom/attr/attr\");\n\n\n// ## Types\n\n// A lookup is an object that is used to identify a lookup in the scope.\n/**\n * @hide\n * @typedef {{get: String}} can.stache.Lookup\n * @option {String} get A value in the scope to look up.\n */\n\n\n// ## Helpers\n\nvar mustacheLineBreakRegExp = /(?:(?:^|(\\r?)\\n)(\\s*)(\\{\\{([^\\}]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([^\\}]*)\\}\\}\\}?)/g,\n\tk = function(){};\n\n\nvar core = {\n\texpression: expression,\n\t// ## mustacheCore.makeEvaluator\n\t// Given a scope and expression, returns a function that evaluates that expression in the scope.\n\t//\n\t// This function first reads lookup values in the args and hash.  Then it tries to figure out\n\t// if a helper is being called or a value is being read.  Finally, depending on\n\t// if it's a helper, or not, and which mode the expression is in, it returns\n\t// a function that can quickly evaluate the expression.\n\t/**\n\t * @hide\n\t * Given a mode and expresion data, returns a function that evaluates that expression.\n\t * @param {can-view-scope} The scope in which the expression is evaluated.\n\t * @param {can.view.Options} The option helpers in which the expression is evaluated.\n\t * @param {String} mode Either null, #, ^. > is handled elsewhere\n\t * @param {Object} exprData Data about what was in the mustache expression\n\t * @param {renderer} [truthyRenderer] Used to render a subsection\n\t * @param {renderer} [falseyRenderer] Used to render the inverse subsection\n\t * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.\n\t * @return {Function} An 'evaluator' function that evaluates the expression.\n\t */\n\tmakeEvaluator: function (scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {\n\n\t\tif(mode === \"^\") {\n\t\t\tvar temp = truthyRenderer;\n\t\t\ttruthyRenderer = falseyRenderer;\n\t\t\tfalseyRenderer = temp;\n\t\t}\n\n\t\tvar value,\n\t\t\thelperOptionArg;\n\n\t\tif(exprData instanceof expression.Call) {\n\t\t\thelperOptionArg =  {\n\t\t\t\tfn: function () {},\n\t\t\t\tinverse: function () {},\n\t\t\t\tcontext: scope.peek(\".\"),\n\t\t\t\tscope: scope,\n\t\t\t\tnodeList: nodeList,\n\t\t\t\texprData: exprData,\n\t\t\t\thelpersScope: helperOptions\n\t\t\t};\n\t\t\tutils.convertToScopes(helperOptionArg, scope,helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\n\t\t\tvalue = exprData.value(scope, helperOptions, helperOptionArg);\n\t\t\tif(exprData.isHelper) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t} else if (exprData instanceof expression.Bracket) {\n\t\t\tvalue = exprData.value(scope);\n\t\t\tif(exprData.isHelper) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t} else if (exprData instanceof expression.Lookup) {\n\t\t\tvalue = exprData.value(scope);\n\t\t\tif(exprData.isHelper) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t} else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {\n\t\t\t// Brackets get wrapped in Helpers when used in attributes\n\t\t\t// like `<p class=\"{{ foo[bar] }}\" />`\n\t\t\tvalue = exprData.methodExpr.value(scope);\n\t\t\tif(exprData.isHelper) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t} else {\n\t\t\tvar readOptions = {\n\t\t\t\t// will return a function instead of calling it.\n\t\t\t\t// allowing it to be turned into a compute if necessary.\n\t\t\t\tisArgument: true,\n\t\t\t\targs: [scope.peek('.'), scope],\n\t\t\t\tasCompute: true\n\t\t\t};\n\t\t\tvar helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\t\t\tvar helper = helperAndValue.helper;\n\t\t\tvalue = helperAndValue.value;\n\n\t\t\tif(helper) {\n\t\t\t\treturn exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\t\t\t}\n\t\t}\n\n\t\t// Return evaluators for no mode.\n\t\tif(!mode) {\n\t\t\t// If it's computed, return a function that just reads the compute.\n\t\t\tif(value && value.isComputed) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t// Just return value as the value\n\t\t\telse {\n\n\t\t\t\treturn function(){\n\t\t\t\t\treturn '' + (value != null ? value : '');\n\t\t\t\t};\n\t\t\t}\n\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\t\t\t// Setup renderers.\n\t\t\thelperOptionArg = {\n\t\t\t\tfn: function () {},\n\t\t\t\tinverse: function () {}\n\t\t\t};\n\t\t\tutils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\t\t\treturn function(){\n\t\t\t\t// Get the value\n\t\t\t\tvar finalValue;\n\t\t\t\tif (types.isCompute(value)) {\n\t\t\t\t\tfinalValue = value();\n\t\t\t\t} else {\n\t\t\t\t\tfinalValue = value;\n\t\t\t\t}\n\t\t\t\tif(typeof finalValue === \"function\") {\n\t\t\t\t\treturn finalValue;\n\t\t\t\t}\n\t\t\t\t// If it's an array, render.\n\t\t\t\telse if ( typeof finalValue !== \"string\" && utils.isArrayLike(finalValue) ) {\n\t\t\t\t\tvar isObserveList = types.isMapLike(finalValue);\n\n\t\t\t\t\tif(isObserveList ? finalValue.attr(\"length\") : finalValue.length) {\n\t\t\t\t\t\tif (stringOnly) {\n\t\t\t\t\t\t\treturn utils.getItemsStringContent(finalValue, isObserveList, helperOptionArg, helperOptions);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn frag(utils.getItemsFragContent(finalValue, helperOptionArg, scope));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn helperOptionArg.inverse(scope, helperOptions);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If truthy, render fn, otherwise, inverse.\n\t\t\t\telse {\n\t\t\t\t\treturn finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\t// not supported!\n\t\t}\n\t},\n\t// ## mustacheCore.makeLiveBindingPartialRenderer\n\t// Returns a renderer function that live binds a partial.\n\t/**\n\t * @hide\n\t * Returns a renderer function that live binds a partial.\n\t * @param {String} expressionString\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(this:HTMLElement,can-view-scope,can.view.Options)} A renderer function\n\t * live binds a partial.\n\t */\n\tmakeLiveBindingPartialRenderer: function(expressionString, state){\n\t\texpressionString = expressionString.trim();\n\t\tvar exprData,\n\t\t\t\tpartialName = expressionString.split(/\\s+/).shift();\n\n\t\tif(partialName !== expressionString) {\n\t\t\texprData = core.expression.parse(expressionString);\n\t\t}\n\n\t\treturn function(scope, options, parentSectionNodeList){\n\t\t\tvar nodeList = [this];\n\t\t\tnodeList.expression = \">\" + partialName;\n\t\t\tnodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);\n\n\t\t\tvar partialFrag = compute(function(){\n\t\t\t\tvar localPartialName = partialName;\n\t\t\t\t// If the second parameter of a partial is a custom context\n\t\t\t\tif(exprData && exprData.argExprs.length === 1) {\n\t\t\t\t\tvar newContext = exprData.argExprs[0].value(scope, options)();\n\t\t\t\t\tif(typeof newContext === \"undefined\") {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tdev.warn('The context ('+ exprData.argExprs[0].key +') you passed into the' +\n\t\t\t\t\t\t\t'partial ('+ partialName +') is not defined in the scope!');\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}else{\n\t\t\t\t\t\tscope = scope.add(newContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Look up partials in options first.\n\t\t\t\tvar partial = options.peek(\"partials.\" + localPartialName), renderer;\n\t\t\t\tif (partial) {\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\treturn partial.render ? partial.render(scope, options, nodeList)\n\t\t\t\t\t\t\t: partial(scope, options);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Use can.view to get and render the partial.\n\t\t\t\telse {\n\t\t\t\t\tvar scopePartialName = scope.read(localPartialName, {\n\t\t\t\t\t\tisArgument: true\n\t\t\t\t\t}).value;\n\n\t\t\t\t\tif (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {\n\t\t\t\t\t\treturn frag(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (scopePartialName) {\n\t\t\t\t\t\tlocalPartialName = scopePartialName;\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\tif(typeof localPartialName === \"function\"){\n\t\t\t\t\t\t\treturn localPartialName(scope, options, nodeList);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn core.getTemplateById(localPartialName)(scope, options, nodeList);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar res = Observation.ignore(renderer)();\n\t\t\t\treturn frag(res);\n\t\t\t});\n\n\t\t\tpartialFrag.computeInstance.setPrimaryDepth(nodeList.nesting);\n\n\t\t\tlive.html(this, partialFrag, this.parentNode, nodeList);\n\t\t};\n\t},\n\t// ## mustacheCore.makeStringBranchRenderer\n\t// Return a renderer function that evalutes to a string and caches\n\t// the evaluator on the scope.\n\t/**\n\t * @hide\n\t * Return a renderer function that evaluates to a string.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @return {function(can.view.Scope,can.view.Options, can-stache.renderer, can.view.renderer)}\n\t */\n\tmakeStringBranchRenderer: function(mode, expressionString){\n\t\tvar exprData = core.expression.parse(expressionString),\n\t\t\t// Use the full mustache expression as the cache key.\n\t\t\tfullExpression = mode+expressionString;\n\n\t\t// convert a lookup like `{{value}}` to still be called as a helper if necessary.\n\t\tif(!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call)) {\n\t\t\texprData = new expression.Helper(exprData,[],{});\n\t\t}\n\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, options, truthyRenderer, falseyRenderer){\n\t\t\t// Check the scope's cache if the evaluator already exists for performance.\n\t\t\tvar evaluator = scope.__cache[fullExpression];\n\t\t\tif(mode || !evaluator) {\n\t\t\t\tevaluator = makeEvaluator( scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);\n\t\t\t\tif(!mode) {\n\t\t\t\t\tscope.__cache[fullExpression] = evaluator;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the evaluator and return the result.\n\t\t\tvar res = evaluator();\n\t\t\treturn res == null ? \"\" : \"\"+res;\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.makeLiveBindingBranchRenderer\n\t// Return a renderer function that evaluates the mustache expression and\n\t// sets up live binding if a compute with dependencies is found. Otherwise,\n\t// the element's value is set.\n\t//\n\t// This function works by creating a `can.compute` from the mustache expression.\n\t// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,\n\t// it updates the element's property based on the compute's value.\n\t/**\n\t * @hide\n\t * Returns a renderer function that evaluates the mustache expression.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t */\n\tmakeLiveBindingBranchRenderer: function(mode, expressionString, state){\n\n\t\t// Pre-process the expression.\n\t\tvar exprData = core.expression.parse(expressionString);\n\t\tif(!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {\n\t\t\texprData = new expression.Helper(exprData,[],{});\n\t\t}\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer){\n\n\t\t\tvar nodeList = [this];\n\t\t\tnodeList.expression = expressionString;\n\t\t\t// register this nodeList.\n\t\t\t// Regsiter it with its parent ONLY if this is directly nested.  Otherwise, it's unencessary.\n\t\t\tnodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);\n\n\n\t\t\t// Get the evaluator. This does not need to be cached (probably) because if there\n\t\t\t// an observable value, it will be handled by `can.view.live`.\n\t\t\tvar evaluator = makeEvaluator( scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer,\n\t\t\t\t// If this is within a tag, make sure we only get string values.\n\t\t\t\tstate.tag );\n\n\t\t\t// Create a compute that can not be observed by other\n\t\t\t// comptues. This is important because this renderer is likely called by\n\t\t\t// parent expresions.  If this value changes, the parent expressions should\n\t\t\t// not re-evaluate. We prevent that by making sure this compute is ignored by\n\t\t\t// everyone else.\n\t\t\t//var compute = can.compute(evaluator, null, false);\n\t\t\tvar gotCompute = evaluator.isComputed,\n\t\t\t\tcomputeValue;\n\t\t\tif(gotCompute) {\n\t\t\t\tcomputeValue = evaluator;\n\t\t\t} else {\n\t\t\t\tcomputeValue = compute(evaluator, null, false);\n\t\t\t}\n\n\t\t\tcomputeValue.computeInstance.setPrimaryDepth(nodeList.nesting);\n\n\t\t\t// Bind on the computeValue to set the cached value. This helps performance\n\t\t\t// so live binding can read a cached value instead of re-calculating.\n\t\t\tcomputeValue.computeInstance.bind(\"change\", k);\n\n\t\t\tvar value = computeValue();\n\n\t\t\t// If value is a function, it's a helper that returned a function.\n\t\t\tif(typeof value === \"function\") {\n\n\t\t\t\t// A helper function should do it's own binding.  Similar to how\n\t\t\t\t// we prevented this function's compute from being noticed by parent expressions,\n\t\t\t\t// we hide any observables read in the function by saving any observables that\n\t\t\t\t// have been read and then setting them back which overwrites any `can.__observe` calls\n\t\t\t\t// performed in value.\n\t\t\t\tObservation.ignore(value)(this);\n\n\t\t\t}\n\t\t\t// If the computeValue has observable dependencies, setup live binding.\n\t\t\telse if(gotCompute || computeValue.computeInstance.hasDependencies ) {\n\n\t\t\t\t// Depending on where the template is, setup live-binding differently.\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, computeValue);\n\t\t\t\t}\n\t\t\t\telse if( state.tag )  {\n\t\t\t\t\tlive.attrs( this, computeValue );\n\t\t\t\t}\n\t\t\t\telse if(state.text && typeof value !== \"object\"){\n\t\t\t\t\tlive.text(this, computeValue, this.parentNode, nodeList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.html(this, computeValue, this.parentNode, nodeList);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the computeValue has no observable dependencies, just set the value on the element.\n\t\t\telse {\n\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tattr.set(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse if(state.tag) {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t\telse if(state.text && typeof value === \"string\") {\n\t\t\t\t\tthis.nodeValue = value;\n\t\t\t\t}\n\t\t\t\telse if( value != null ){\n\t\t\t\t\tnodeLists.replace([this], frag(value, this.ownerDocument));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Unbind the compute.\n\t\t\tcomputeValue.computeInstance.unbind(\"change\", k);\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.splitModeFromExpression\n\t// Returns the mustache mode split from the rest of the expression.\n\t/**\n\t * @hide\n\t * Returns the mustache mode split from the rest of the expression.\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The state of HTML where the expression was found.\n\t */\n\tsplitModeFromExpression: function(expression, state){\n\t\texpression = expression.trim();\n\t\tvar mode = expression.charAt(0);\n\n\t\tif( \"#/{&^>!\".indexOf(mode) >= 0 ) {\n\t\t\texpression =  expression.substr(1).trim();\n\t\t} else {\n\t\t\tmode = null;\n\t\t}\n\t\t// Triple braces do nothing within a tag.\n\t\tif(mode === \"{\" && state.node) {\n\t\t\tmode = null;\n\t\t}\n\t\treturn {\n\t\t\tmode: mode,\n\t\t\texpression: expression\n\t\t};\n\t},\n\t// ## mustacheCore.cleanLineEndings\n\t// Removes line breaks accoding to the mustache specification.\n\t/**\n\t * @hide\n\t * Prunes line breaks accoding to the mustache specification.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanLineEndings: function(template){\n\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\treturn special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\n\t\t});\n\t},\n\tOptions: utils.Options,\n\tgetTemplateById: function(){}\n};\n\n// ## Local Variable Cache\n//\n// The following creates slightly more quickly accessible references of the following\n// core functions.\nvar makeEvaluator = core.makeEvaluator,\n\tsplitModeFromExpression = core.splitModeFromExpression;\n\nmodule.exports = core;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/src/mustache_core.js\n// module id = 28\n// module chunks = 0","var Scope = require('can-view-scope');\nvar Observation = require('can-observation');\nvar observationReader = require('can-observation/reader/reader');\nvar compute = require('can-compute');\nvar types = require('can-types');\n\nvar isArrayLike = require('can-util/js/is-array-like/is-array-like');\n\t// ## can.view.Options\n\t//\n\t// This contains the local helpers, partials, and tags available to a template.\n\t/**\n\t * @hide\n\t * The Options scope.\n\t */\nvar Options = Scope.Options; // jshint ignore:line\n\nmodule.exports = {\n\t// Returns if something looks like an array.  This works for can.List\n\tisArrayLike: isArrayLike,\n\t// A generic empty function\n\temptyHandler: function(){},\n\t// Converts a string like \"1\" into 1. \"null\" into null, etc.\n\t// This doesn't have to do full JSON, so removing eval would be good.\n\tjsonParse: function(str){\n\t\t// if it starts with a quote, assume a string.\n\t\tif(str[0] === \"'\") {\n\t\t\treturn str.substr(1, str.length -2);\n\t\t} else if(str === \"undefined\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn JSON.parse(str);\n\t\t}\n\t},\n\tmixins: {\n\t\tlast: function(){\n\t\t\treturn this.stack[this.stack.length - 1];\n\t\t},\n\t\tadd: function(chars){\n\t\t\tthis.last().add(chars);\n\t\t},\n\t\tsubSectionDepth: function(){\n\t\t\treturn this.stack.length - 1;\n\t\t}\n\t},\n\t// Sets .fn and .inverse on a helperOptions object and makes sure\n\t// they can reference the current scope and options.\n\tconvertToScopes: function(helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer, isStringOnly){\n\t\t// overwrite fn and inverse to always convert to scopes\n\t\tif(truthyRenderer) {\n\t\t\thelperOptions.fn = this.makeRendererConvertScopes(truthyRenderer, scope, options, nodeList, isStringOnly);\n\t\t}\n\t\tif(falseyRenderer) {\n\t\t\thelperOptions.inverse = this.makeRendererConvertScopes(falseyRenderer, scope, options, nodeList, isStringOnly);\n\t\t}\n\t},\n\t// Returns a new renderer function that makes sure any data or helpers passed\n\t// to it are converted to a can.view.Scope and a can.view.Options.\n\tmakeRendererConvertScopes: function (renderer, parentScope, parentOptions, nodeList, observeObservables) {\n\t\tvar rendererWithScope = function(ctx, opts, parentNodeList){\n\t\t\treturn renderer(ctx || parentScope, opts, parentNodeList);\n\t\t};\n\t\tvar convertedRenderer = function (newScope, newOptions, parentNodeList) {\n\t\t\t// prevent binding on fn.\n\t\t\t// If a non-scope value is passed, add that to the parent scope.\n\t\t\tif (newScope !== undefined && !(newScope instanceof Scope)) {\n\t\t\t\tnewScope = parentScope.add(newScope);\n\t\t\t}\n\t\t\tif (newOptions !== undefined && !(newOptions instanceof Options)) {\n\t\t\t\tnewOptions = parentOptions.add(newOptions);\n\t\t\t}\n\t\t\tvar result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList|| nodeList );\n\t\t\treturn result;\n\t\t};\n\t\treturn observeObservables ?  convertedRenderer : Observation.ignore(convertedRenderer);\n\t},\n\t// Calls the truthy subsection for each item in a list and returning them in a string.\n\tgetItemsStringContent: function(items, isObserveList, helperOptions, options){\n\t\tvar txt = \"\",\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = types.isMapLike(items) || types.isListLike(items);\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar item = isObservable ? compute(items, '' + i) :items[i];\n\t\t\ttxt += helperOptions.fn(item, options);\n\t\t}\n\t\treturn txt;\n\t},\n\t// Calls the truthy subsection for each item in a list and returns them in a document Fragment.\n\tgetItemsFragContent: function(items, helperOptions, scope, asVariable) {\n\t\tvar result = [],\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = types.isMapLike(items) || types.isListLike(items);\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar aliases = {\n\t\t\t\t\"%index\": i,\n\t\t\t\t\"@index\": i\n\t\t\t};\n\t\t\tvar item = isObservable ? compute(items, '' + i) :items[i];\n\n\t\t\tif (asVariable) {\n\t\t\t\taliases[asVariable] = item;\n\t\t\t}\n\t\t\tresult.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add(item)));\n\t\t}\n\t\treturn result;\n\t},\n\tOptions: Options\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/src/utils.js\n// module id = 29\n// module chunks = 0","'use strict';\n\n// # can/util/inserted\n// Used to alert interested parties of when an element is inserted into the DOM.\n// Given a list of elements, check if the first is in the DOM, and if so triggers the `inserted` event on all elements and their descendants.\n\nvar makeArray = require(\"../../js/make-array/make-array\");\nvar setImmediate = require(\"../../js/set-immediate/set-immediate\");\nvar CID = require(\"can-cid\");\n\nvar getMutationObserver = require(\"../mutation-observer/mutation-observer\");\nvar childNodes = require(\"../child-nodes/child-nodes\");\nvar domContains = require(\"../contains/contains\");\nvar domDispatch = require(\"../dispatch/dispatch\");\nvar DOCUMENT = require(\"../document/document\");\nvar domData = require(\"../data/data\");\n\nvar mutatedElements;\nvar checks = {\n\tinserted: function(root, elem){\n\t\treturn domContains.call(root, elem);\n\t},\n\tremoved: function(root, elem){\n\t\treturn !domContains.call(root, elem);\n\t}\n};\n\nvar fireOn = function(elems, root, check, event, dispatched) {\n\tif (!elems.length) {\n\t\treturn;\n\t}\n\tvar children, cid;\n\n\t// Go through `elems` and trigger the `inserted` event.\n\t// If the first element is not in the document (a Document Fragment) it will exit the function.\n\t// If it is in the document it sets the `inDocument` flag to true. This means that we only check\n\t// for the first element and either exit the function or start triggering \"inserted\" for child elements.\n\tfor (var i = 0, elem; (elem = elems[i]) !== undefined; i++) {\n\t\tcid = CID(elem);\n\t\t// If we've found an element in the document then we can now trigger **\"inserted\"** for `elem` and all of its children. We are using `getElementsByTagName(\"*\")` so that we grab all of the descendant nodes.\n\t\tif (elem.getElementsByTagName && check(root, elem) && !dispatched[cid]) {\n\t\t\t// mark as being dispatched\n\t\t\tdispatched[cid] = true;\n\t\t\tchildren = makeArray(elem.getElementsByTagName(\"*\"));\n\t\t\tdomDispatch.call(elem, event, [], false);\n\t\t\tif (event === \"removed\") {\n\t\t\t\tdomData.delete.call(elem);\n\t\t\t}\n\n\t\t\tfor (var j = 0, child;\n\t\t\t\t(child = children[j]) !== undefined; j++) {\n\t\t\t\t// fire the event only if this hasn't already been fired on.\n\t\t\t\tcid = CID(child);\n\t\t\t\tif(!dispatched[cid]) {\n\t\t\t\t\tdomDispatch.call(child, event, [], false);\n\t\t\t\t\t// jshint maxdepth:5\n\t\t\t\t\tif (event === \"removed\") {\n\t\t\t\t\t\tdomData.delete.call(child);\n\t\t\t\t\t}\n\t\t\t\t\tdispatched[cid] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n//\nvar fireMutations = function(){\n\tvar mutations = mutatedElements;\n\tmutatedElements = null;\n\n\tvar firstElement = mutations[0][1][0];\n\tvar doc = DOCUMENT() || firstElement.ownerDocument || firstElement;\n\tvar root = doc.contains ? doc : doc.documentElement;\n\tvar dispatched = {inserted: {}, removed: {}};\n\tmutations.forEach(function(mutation){\n\t\tfireOn(mutation[1], root, checks[mutation[0]], mutation[0], dispatched[mutation[0]]);\n\t});\n};\nvar mutated = function(elements, type) {\n\tif(!getMutationObserver() && elements.length) {\n\t\t// make sure this element is in the page (mutated called before something is removed)\n\t\tvar firstElement = elements[0];\n\t\tvar doc = DOCUMENT() || firstElement.ownerDocument || firstElement;\n\t\tvar root = doc.contains ? doc : doc.documentElement;\n\t\tif( checks.inserted(root, firstElement) ) {\n\n\t\t\t// if it is, schedule a mutation fire\n\t\t\tif(!mutatedElements) {\n\t\t\t\tmutatedElements = [];\n\t\t\t\tsetImmediate(fireMutations);\n\t\t\t}\n\t\t\tmutatedElements.push([type, elements]);\n\t\t}\n\t}\n};\n\n/**\n * @module {{}} can-util/dom/mutate/mutate mutate\n * @parent can-util/dom\n * @description Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired.\n *\n * ```js\n * var mutate = require(\"can-util/dom/mutate/mutate\");\n *\n * var el = document.createElement(\"div\");\n *\n * el.addEventListener(\"inserted\", function(){\n *   console.log(\"Inserted was fired!\");\n * });\n *\n * mutate.appendChild.call(document.body, el);\n * ```\n */\nmodule.exports = {\n\t/**\n\t * @function can-util/dom/mutate/mutate.appendChild appendChild\n\t * @signature `mutate.appendChild.call(el, child)`\n\t * Used to append a node to an element and trigger the \"inserted\" event on all of the newly inserted children. Since `mutated` takes an array we convert the child to an array, or in the case of a DocumentFragment we first convert the childNodes to an array and call inserted on those.\n\t */\n\tappendChild: function(child) {\n\t\tif(getMutationObserver()) {\n\t\t\tthis.appendChild(child);\n\t\t} else {\n\t\t\tvar children;\n\t\t\tif (child.nodeType === 11) {\n\t\t\t\tchildren = makeArray(childNodes(child));\n\t\t\t} else {\n\t\t\t\tchildren = [child];\n\t\t\t}\n\t\t\tthis.appendChild(child);\n\t\t\tmutated(children,\"inserted\");\n\t\t}\n\t},\n\t/**\n\t * @function can-util/dom/mutate/mutate.insertBefore insertBefore\n\t * @signature `mutate.insertBefore.call(el, ref, child)`\n\t * Like mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"inserted\" event.\n\t */\n\tinsertBefore: function(child, ref, document) {\n\t\tif(getMutationObserver()) {\n\t\t\tthis.insertBefore(child, ref);\n\t\t} else {\n\t\t\tvar children;\n\t\t\tif (child.nodeType === 11) {\n\t\t\t\tchildren = makeArray(childNodes(child));\n\t\t\t} else {\n\t\t\t\tchildren = [child];\n\t\t\t}\n\t\t\tthis.insertBefore(child, ref);\n\t\t\tmutated(children,\"inserted\");\n\t\t}\n\t},\n\t/**\n\t * @function can-util/dom/mutate/mutate.removeChild removeChild\n\t * @signature `mutate.removeChild.call(el, child)`\n\t * Like mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"removed\" event.\n\t */\n\tremoveChild: function(child){\n\t\tif(getMutationObserver()) {\n\t\t\tthis.removeChild(child);\n\t\t} else {\n\t\t\tmutated([child],\"removed\");\n\t\t\tthis.removeChild(child);\n\t\t}\n\t},\n\t/**\n\t * @function can-util/dom/mutate/mutate.replaceChild replaceChild\n\t * @signature `mutate.replaceChild.call(el, child)`\n\t * Like mutate.appendChild and mutate.removeChild, used to replace a node with another node and trigger \"removed\" on the removed element and \"inserted\" on the inserted elements.\n\t */\n\treplaceChild: function(newChild, oldChild){\n\t\tif(getMutationObserver()) {\n\t\t\tthis.replaceChild(newChild, oldChild);\n\t\t} else {\n\t\t\tvar children;\n\t\t\tif (newChild.nodeType === 11) {\n\t\t\t\tchildren = makeArray(childNodes(newChild));\n\t\t\t} else {\n\t\t\t\tchildren = [newChild];\n\t\t\t}\n\t\t\tmutated([oldChild],\"removed\");\n\t\t\tthis.replaceChild(newChild, oldChild);\n\t\t\tmutated(children,\"inserted\");\n\t\t}\n\t},\n\t// called with elements that might have been inserted\n\tinserted: function(elements){\n\t\tmutated(elements,\"inserted\");\n\t},\n\t// called with elements that have been removed\n\tremoved: function(elements){\n\t\tmutated(elements,\"removed\");\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/mutate/mutate.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nmodule.exports = function(arr) {\n\treturn Array.isArray(arr);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-array/is-array.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nmodule.exports = function(arr){\n\treturn arr && arr[arr.length - 1];\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/last/last.js\n// module id = 32\n// module chunks = 0","import { Promise } from 'es6-promise';\r\n\r\nfunction isLoaded(): boolean {\r\n    return typeof window['require'] !== 'undefined';\r\n}\r\n\r\nfunction dojoPromise(modules: string[]): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n        // If something goes wrong loading the esri/dojo scripts, reject with the error.\r\n        window['require'].on(\"error\", reject);\r\n        window['require'](modules, (...args) => {\r\n            // Resolve with the parameters from dojo require as an array.\r\n            resolve(args);\r\n        });\r\n    });\r\n}\r\n\r\nexport function esriBootstrap(url?: string): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n        if (isLoaded()) {\r\n            // If the API is already loaded, reject with an error message.\r\n            reject('The ArcGIS API for JavaScript has already been loaded!');\r\n        }\r\n\r\n        if (!url) {\r\n            url = 'https://js.arcgis.com/4.3/';\r\n        }\r\n\r\n        let script = document.createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.src = url;\r\n        script.onload = () => {\r\n            // Resolve after the script is loaded.\r\n            resolve();\r\n        };\r\n        // Reject if something goes wrong loading the script.\r\n        script.onerror = reject;\r\n        document.body.appendChild(script);\r\n    });\r\n}\r\n\r\nexport function esriPromise(modules: string[]): Promise<any> {\r\n    if (!isLoaded()) {\r\n        return esriBootstrap().then(() => dojoPromise(modules))\r\n    }\r\n    else {\r\n        return dojoPromise(modules);\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./~/esri-promise/index.ts","/* jshint undef: false */\n\nvar parser = require('can-view-parser');\nvar viewCallbacks = require('can-view-callbacks');\n\nvar HTMLSectionBuilder = require('./src/html_section');\nvar TextSectionBuilder = require('./src/text_section');\nvar mustacheCore = require('./src/mustache_core');\nvar mustacheHelpers = require('./helpers/core');\nrequire('./helpers/converter');\nvar getIntermediateAndImports = require('./src/intermediate_and_imports');\n\nvar dev = require('can-util/js/dev/dev');\nvar namespace = require('can-namespace');\nvar DOCUMENT = require('can-util/dom/document/document');\nvar assign = require('can-util/js/assign/assign');\nvar last = require('can-util/js/last/last');\nvar importer = require('can-util/js/import/import');\n// Make sure that we can also use our modules with Stache as a plugin\n\nrequire('can-view-target');\nrequire('can-view-nodelist');\n\n\n// This was moved from the legacy view/scanner.js to here.\n// This makes sure content elements will be able to have a callback.\nviewCallbacks.tag(\"content\", function(el, tagData) {\n\treturn tagData.scope;\n});\n\nvar svgNamespace = \"http://www.w3.org/2000/svg\";\nvar namespaces = {\n\t\"svg\": svgNamespace,\n\t// this allows a partial to start with g.\n\t\"g\": svgNamespace\n},\n\ttextContentOnlyTag = {style: true, script: true};\n\nfunction stache(template){\n\n\t// Remove line breaks according to mustache's specs.\n\tif(typeof template === \"string\") {\n\t\ttemplate = mustacheCore.cleanLineEndings(template);\n\t}\n\n\t// The HTML section that is the root section for the entire template.\n\tvar section = new HTMLSectionBuilder(),\n\t\t// Tracks the state of the parser.\n\t\tstate = {\n\t\t\tnode: null,\n\t\t\tattr: null,\n\t\t\t// A stack of which node / section we are in.\n\t\t\t// There is probably a better way of doing this.\n\t\t\tsectionElementStack: [],\n\t\t\t// If text should be inserted and HTML escaped\n\t\t\ttext: false,\n\t\t\t// which namespace we are in\n\t\t\tnamespaceStack: [],\n\t\t\t// for style and script tags\n\t\t\t// we create a special TextSectionBuilder and add things to that\n\t\t\t// when the element is done, we compile the text section and\n\t\t\t// add it as a callback to `section`.\n\t\t\ttextContentOnly: null\n\n\t\t},\n\t\t// This function is a catch all for taking a section and figuring out\n\t\t// how to create a \"renderer\" that handles the functionality for a\n\t\t// given section and modify the section to use that renderer.\n\t\t// For example, if an HTMLSection is passed with mode `#` it knows to\n\t\t// create a liveBindingBranchRenderer and pass that to section.add.\n\t\tmakeRendererAndUpdateSection = function(section, mode, stache){\n\n\t\t\tif(mode === \">\") {\n\t\t\t\t// Partials use liveBindingPartialRenderers\n\t\t\t\tsection.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState()));\n\n\t\t\t} else if(mode === \"/\") {\n\n\t\t\t\tsection.endSection();\n\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tvar last = state.sectionElementStack[state.sectionElementStack.length - 1].tag;\n\t\t\t\t\tif (stache !== \"\" && stache !== last) {\n\t\t\t\t\t\tdev.warn(\"unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last + \"}}\");\n\t\t\t\t\t\t// throw new Error(\"unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last + \"}}\");\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tstate.sectionElementStack.pop();\n\t\t\t\t}\n\t\t\t} else if(mode === \"else\") {\n\n\t\t\t\tsection.inverse();\n\n\t\t\t} else {\n\n\t\t\t\t// If we are an HTMLSection, we will generate a\n\t\t\t\t// a LiveBindingBranchRenderer; otherwise, a StringBranchRenderer.\n\t\t\t\t// A LiveBindingBranchRenderer function processes\n\t\t\t\t// the mustache text, and sets up live binding if an observable is read.\n\t\t\t\t// A StringBranchRenderer function processes the mustache text and returns a\n\t\t\t\t// text value.\n\t\t\t\tvar makeRenderer = section instanceof HTMLSectionBuilder ?\n\n\t\t\t\t\tmustacheCore.makeLiveBindingBranchRenderer:\n\t\t\t\t\tmustacheCore.makeStringBranchRenderer;\n\n\n\t\t\t\tif(mode === \"{\" || mode === \"&\") {\n\n\t\t\t\t\t// Adds a renderer function that just reads a value or calls a helper.\n\t\t\t\t\tsection.add( makeRenderer(null,stache, copyState() ));\n\n\t\t\t\t} else if(mode === \"#\" || mode === \"^\") {\n\t\t\t\t\t// Adds a renderer function and starts a section.\n\t\t\t\t\tvar renderer = makeRenderer(mode,stache, copyState()  );\n\t\t\t\t\tsection.startSection(renderer);\n\n\t\t\t\t\t// If we are a directly nested section, count how many we are within\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tvar tag = typeof renderer.exprData.closingTag === 'function' ?\n\t\t\t\t\t\t\trenderer.exprData.closingTag() : '';\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\tstate.sectionElementStack.push({\n\t\t\t\t\t\t\ttype: \"section\",\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\ttag: tag\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Adds a renderer function that only updates text.\n\t\t\t\t\tsection.add( makeRenderer(null,stache, copyState({text: true}) ));\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\t// Copys the state object for use in renderers.\n\t\tcopyState = function(overwrites){\n\t\t\tvar lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\tvar cur = {\n\t\t\t\ttag: state.node && state.node.tag,\n\t\t\t\tattr: state.attr && state.attr.name,\n\t\t\t\t// <content> elements should be considered direclty nested\n\t\t\t\tdirectlyNested: state.sectionElementStack.length ?\n\t\t\t\t\tlastElement.type === \"section\" || lastElement.type === \"custom\": true,\n\t\t\t\ttextContentOnly: !!state.textContentOnly\n\t\t\t};\n\t\t\treturn overwrites ? assign(cur, overwrites) : cur;\n\t\t},\n\t\taddAttributesCallback = function(node, callback){\n\t\t\tif( !node.attributes ) {\n\t\t\t\tnode.attributes = [];\n\t\t\t}\n\t\t\tnode.attributes.unshift(callback);\n\t\t};\n\n\tparser(template,{\n\t\tstart: function(tagName, unary){\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace && !unary ) {\n\t\t\t\tstate.namespaceStack.push(matchedNamespace);\n\t\t\t}\n\n\t\t\tstate.node = {\n\t\t\t\ttag: tagName,\n\t\t\t\tchildren: [],\n\t\t\t\tnamespace: matchedNamespace || last(state.namespaceStack)\n\t\t\t};\n\t\t},\n\t\tend: function(tagName, unary){\n\t\t\tvar isCustomTag =  viewCallbacks.tag(tagName);\n\n\t\t\tif(unary){\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tsection.add(state.node);\n\t\t\t\tif(isCustomTag) {\n\t\t\t\t\taddAttributesCallback(state.node, function(scope, options, parentNodeList){\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\toptions: options,\n\t\t\t\t\t\t\tsubtemplate: null,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\tparentNodeList: parentNodeList\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsection.push(state.node);\n\n\t\t\t\tstate.sectionElementStack.push({\n\t\t\t\t\ttype: isCustomTag ? \"custom\" : null,\n\t\t\t\t\ttag: isCustomTag ? null : tagName\n\t\t\t\t});\n\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tif( isCustomTag ) {\n\t\t\t\t\tsection.startSubSection();\n\t\t\t\t} else if(textContentOnlyTag[tagName]) {\n\t\t\t\t\tstate.textContentOnly = new TextSectionBuilder();\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tstate.node =null;\n\n\t\t},\n\t\tclose: function( tagName ) {\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace  ) {\n\t\t\t\tstate.namespaceStack.pop();\n\t\t\t}\n\n\t\t\tvar isCustomTag = viewCallbacks.tag(tagName),\n\t\t\t\trenderer;\n\n\t\t\tif( isCustomTag ) {\n\t\t\t\trenderer = section.endSubSectionAndReturnRenderer();\n\t\t\t}\n\t\t\tif(textContentOnlyTag[tagName]) {\n\t\t\t\tsection.last().add(state.textContentOnly.compile(copyState()));\n\t\t\t\tstate.textContentOnly = null;\n\t\t\t}\n\n\t\t\tvar oldNode = section.pop();\n\t\t\tif( isCustomTag ) {\n\t\t\t\taddAttributesCallback(oldNode, function(scope, options, parentNodeList){\n\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\toptions: options,\n\t\t\t\t\t\tsubtemplate: renderer,\n\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\tparentNodeList: parentNodeList\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tstate.sectionElementStack.pop();\n\t\t},\n\t\tattrStart: function(attrName){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(attrName+\"=\\\"\");\n\t\t\t} else {\n\t\t\t\tstate.attr = {\n\t\t\t\t\tname: attrName,\n\t\t\t\t\tvalue: \"\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t},\n\t\tattrEnd: function(attrName){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(\"\\\" \");\n\t\t\t} else {\n\t\t\t\tif(!state.node.attrs) {\n\t\t\t\t\tstate.node.attrs = {};\n\t\t\t\t}\n\n\t\t\t\tstate.node.attrs[state.attr.name] =\n\t\t\t\t\tstate.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;\n\n\t\t\t\tvar attrCallback = viewCallbacks.attr(attrName);\n\t\t\t\tif(attrCallback) {\n\t\t\t\t\tif( !state.node.attributes ) {\n\t\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t\t}\n\t\t\t\t\tstate.node.attributes.push(function(scope, options, nodeList){\n\t\t\t\t\t\tattrCallback(this,{\n\t\t\t\t\t\t\tattributeName: attrName,\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\toptions: options,\n\t\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\n\n\t\t\t\tstate.attr = null;\n\t\t\t}\n\t\t},\n\t\tattrValue: function(value){\n\t\t\tvar section = state.node.section || state.attr.section;\n\t\t\tif(section){\n\t\t\t\tsection.add(value);\n\t\t\t} else {\n\t\t\t\tstate.attr.value += value;\n\t\t\t}\n\t\t},\n\t\tchars: function( text ) {\n\t\t\t(state.textContentOnly || section).add(text);\n\t\t},\n\t\tspecial: function( text ){\n\n\t\t\tvar firstAndText = mustacheCore.splitModeFromExpression(text, state),\n\t\t\t\tmode = firstAndText.mode,\n\t\t\t\texpression = firstAndText.expression;\n\n\n\t\t\tif(expression === \"else\") {\n\t\t\t\tvar inverseSection;\n\t\t\t\tif(state.attr && state.attr.section) {\n\t\t\t\t\tinverseSection = state.attr.section;\n\t\t\t\t} else if(state.node && state.node.section ) {\n\t\t\t\t\tinverseSection = state.node.section;\n\t\t\t\t} else {\n\t\t\t\t\tinverseSection = state.textContentOnly || section;\n\t\t\t\t}\n\t\t\t\tinverseSection.inverse();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(mode === \"!\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(state.node && state.node.section) {\n\n\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression);\n\n\t\t\t\tif(state.node.section.subSectionDepth() === 0){\n\t\t\t\t\tstate.node.attributes.push( state.node.section.compile(copyState()) );\n\t\t\t\t\tdelete state.node.section;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// `{{}}` in an attribute like `class=\"{{}}\"`\n\t\t\telse if(state.attr) {\n\n\t\t\t\tif(!state.attr.section) {\n\t\t\t\t\tstate.attr.section = new TextSectionBuilder();\n\t\t\t\t\tif(state.attr.value) {\n\t\t\t\t\t\tstate.attr.section.add(state.attr.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmakeRendererAndUpdateSection(state.attr.section, mode, expression );\n\n\t\t\t}\n\t\t\t// `{{}}` in a tag like `<div {{}}>`\n\t\t\telse if(state.node) {\n\n\t\t\t\tif(!state.node.attributes) {\n\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t}\n\t\t\t\tif(!mode) {\n\t\t\t\t\tstate.node.attributes.push( mustacheCore.makeLiveBindingBranchRenderer( null,expression, copyState() ) );\n\t\t\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\t\t\t\t\tif(!state.node.section) {\n\t\t\t\t\t\tstate.node.section = new TextSectionBuilder();\n\t\t\t\t\t}\n\t\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(mode+\" is currently not supported within a tag.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmakeRendererAndUpdateSection( state.textContentOnly || section, mode, expression );\n\t\t\t}\n\t\t},\n\t\tcomment: function( text ) {\n\t\t\t// create comment node\n\t\t\tsection.add({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t},\n\t\tdone: function(){}\n\t});\n\n\treturn section.compile();\n}\n\n// At this point, can.stache has been created\nassign(stache, mustacheHelpers);\n\nstache.safeString = function(text){\n\treturn {\n\t\t\ttoString: function () {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t};\n};\nstache.async = function(source){\n\tvar iAi = getIntermediateAndImports(source);\n\tvar importPromises = iAi.imports.map(function(moduleName){\n\t\treturn importer(moduleName);\n\t});\n\treturn Promise.all(importPromises).then(function(){\n\t\treturn stache(iAi.intermediate);\n\t});\n};\nvar templates = {};\nstache.from = mustacheCore.getTemplateById = function(id){\n\tif(!templates[id]) {\n\t\tvar el = DOCUMENT().getElementById(id);\n\t\ttemplates[id] = stache(el.innerHTML);\n\t}\n\treturn templates[id];\n};\n\nstache.registerPartial = function(id, partial) {\n\ttemplates[id] = (typeof partial === \"string\" ? stache(partial) : partial);\n};\n\nmodule.exports = namespace.stache = stache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/can-stache.js\n// module id = 34\n// module chunks = 0","var live = require('can-view-live');\nvar nodeLists = require('can-view-nodelist');\nvar compute = require('can-compute');\n\nvar utils = require('../src/utils');\n\nvar types = require('can-types');\nvar isFunction = require('can-util/js/is-function/is-function');\n\nvar getBaseURL = require('can-util/js/base-url/base-url');\nvar joinURIs = require('can-util/js/join-uris/join-uris');\n\nvar each = require('can-util/js/each/each');\nvar assign = require('can-util/js/assign/assign');\nvar isIterable = require(\"can-util/js/is-iterable/is-iterable\");\nvar dev = require('can-util/js/dev/dev');\n\n\nvar domData = require('can-util/dom/data/data');\n\nvar looksLikeOptions = function(options){\n\treturn options && typeof options.fn === \"function\" && typeof options.inverse === \"function\";\n};\n\nvar resolve = function (value) {\n\tif (value && value.isComputed) {\n\t\treturn value();\n\t} else {\n\t\treturn value;\n\t}\n};\nvar resolveHash = function(hash){\n\tvar params = {};\n\tfor(var prop in hash) {\n\t\tvar value = hash[prop];\n\t\tif(value && value.isComputed) {\n\t\t\tparams[prop] = value();\n\t\t} else {\n\t\t\tparams[prop] = value;\n\t\t}\n\t}\n\treturn params;\n};\n\n\nvar helpers = {\n\t\"each\": function(items) {\n\t\tvar args = [].slice.call(arguments),\n\t\t\toptions = args.pop(),\n\t\t\targsLen = args.length,\n\t\t\targExprs = options.exprData.argExprs,\n\t\t\tresolved = resolve(items),\n\t\t\tasVariable,\n\t\t\taliases,\n\t\t\tkey;\n\n\t\tif (argsLen === 2 || (argsLen === 3 && argExprs[1].key === 'as')) {\n\t\t\tasVariable = args[argsLen - 1];\n\n\t\t\tif (typeof asVariable !== 'string') {\n\t\t\t\tasVariable = argExprs[argsLen - 1].key;\n\t\t\t}\n\t\t}\n\n\t\tif ((\n\t\t\t\ttypes.isListLike(resolved) ||\n\t\t\t\t( utils.isArrayLike(resolved) && items.isComputed )\n\t\t\t) && !options.stringOnly) {\n\t\t\treturn function(el){\n\t\t\t\t// make a child nodeList inside the can.view.live.html nodeList\n\t\t\t\t// so that if the html is re\n\t\t\t\tvar nodeList = [el];\n\t\t\t\tnodeList.expression = \"live.list\";\n\t\t\t\tnodeLists.register(nodeList, null, options.nodeList, true);\n\t\t\t\t// runs nest replacements\n\t\t\t\tnodeLists.update(options.nodeList, [el]);\n\n\t\t\t\tvar cb = function (item, index, parentNodeList) {\n\t\t\t\t\tvar aliases = {\n\t\t\t\t\t\t\"%index\": index,\n\t\t\t\t\t\t\"@index\": index\n\t\t\t\t\t};\n\n\t\t\t\t\tif (asVariable) {\n\t\t\t\t\t\taliases[asVariable] = item;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn options.fn(options.scope.add(aliases, { notContext: true }).add(item), options.options, parentNodeList);\n\t\t\t\t};\n\n\t\t\t\tlive.list(el, items, cb, options.context, el.parentNode, nodeList, function(list, parentNodeList){\n\t\t\t\t\treturn options.inverse(options.scope.add(list), options.options, parentNodeList);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\n\t\tvar expr = resolved,\n\t\t\tresult;\n\n\t\tif ( !! expr && utils.isArrayLike(expr)) {\n\t\t\tresult = utils.getItemsFragContent(expr, options, options.scope, asVariable);\n\t\t\treturn options.stringOnly ? result.join('') : result;\n\t\t}\n\t\telse if(isIterable(expr)) {\n\t\t\tresult = [];\n\t\t\teach(expr, function(value, key){\n\t\t\t\taliases = {\n\t\t\t\t\t\"%key\": key\n\t\t\t\t};\n\t\t\t\tif (asVariable) {\n\t\t\t\t\taliases[asVariable] = value;\n\t\t\t\t}\n\t\t\t\tresult.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));\n\t\t\t});\n\t\t\treturn options.stringOnly ? result.join('') : result;\n\t\t}\n\t\telse if (types.isMapLike(expr)) {\n\t\t\tresult = [];\n\n\t\t\t(expr.forEach || expr.each).call(expr, function(val, key){\n\t\t\t\tvar value = compute(expr, key);\n\t\t\t\taliases = {\n\t\t\t\t\t\"%key\": key,\n\t\t\t\t\t\"@key\": key\n\t\t\t\t};\n\t\t\t\tif (asVariable) {\n\t\t\t\t\taliases[asVariable] = expr[key];\n\t\t\t\t}\n\t\t\t\tresult.push(options.fn(options.scope.add(aliases, { notContext: true }).add(value)));\n\t\t\t});\n\n\t\t\treturn options.stringOnly ? result.join('') : result;\n\t\t}\n\t\telse if (expr instanceof Object) {\n\t\t\tresult = [];\n\t\t\tfor (key in expr) {\n\t\t\t\taliases = {\n\t\t\t\t\t\"%key\": key,\n\t\t\t\t\t\"@key\": key\n\t\t\t\t};\n\t\t\t\tif (asVariable) {\n\t\t\t\t\taliases[asVariable] = expr[key];\n\t\t\t\t}\n\t\t\t\tresult.push(options.fn(options.scope.add(aliases, { notContext: true }).add(expr[key])));\n\t\t\t}\n\t\t\treturn options.stringOnly ? result.join('') : result;\n\t\t}\n\t},\n\t\"@index\": function(offset, options) {\n\t\tif (!options) {\n\t\t\toptions = offset;\n\t\t\toffset = 0;\n\t\t}\n\t\tvar index = options.scope.peek(\"@index\");\n\t\treturn \"\"+((isFunction(index) ? index() : index) + offset);\n\t},\n\t'if': function (expr, options) {\n\t\tvar value;\n\t\t// if it's a function, wrap its value in a compute\n\t\t// that will only change values from true to false\n\t\tif (expr && expr.isComputed) {\n\t\t\tvalue = compute.truthy(expr)();\n\t\t} else {\n\t\t\tvalue = !! resolve(expr);\n\t\t}\n\n\t\tif (value) {\n\t\t\treturn options.fn(options.scope || this);\n\t\t} else {\n\t\t\treturn options.inverse(options.scope || this);\n\t\t}\n\t},\n\t'is': function() {\n\t\tvar lastValue, curValue,\n\t\toptions = arguments[arguments.length - 1];\n\n\t\tif (arguments.length - 2 <= 0) {\n\t\t\treturn options.inverse();\n\t\t}\n\n\t\tvar args = arguments;\n\t\tvar callFn = compute(function(){\n\t\t\tfor (var i = 0; i < args.length - 1; i++) {\n\t\t\t\tcurValue = resolve(args[i]);\n\t\t\t\tcurValue = isFunction(curValue) ? curValue() : curValue;\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tif (curValue !== lastValue) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastValue = curValue;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn callFn() ? options.fn() : options.inverse();\n\t},\n\t'eq': function() {\n\t\treturn helpers.is.apply(this, arguments);\n\t},\n\t'unless': function (expr, options) {\n\t\treturn helpers['if'].apply(this, [expr, assign(assign({}, options), {\n\t\t\tfn: options.inverse,\n\t\t\tinverse: options.fn\n\t\t})]);\n\t},\n\t'with': function (expr, options) {\n\t\tvar ctx = expr;\n\t\texpr = resolve(expr);\n\t\tif ( !! expr) {\n\t\t\treturn options.fn(ctx);\n\t\t}\n\t},\n\t'log': function (options) {\n\t\t// go through the arguments\n\t\tvar logs = [];\n\t\teach(arguments, function(val){\n\t\t\tif(!looksLikeOptions(val)) {\n\t\t\t\tlogs.push(val);\n\t\t\t}\n\t\t});\n\n\n\t\tif (typeof console !== \"undefined\" && console.log) {\n\t\t\tif (!logs.length) {\n\t\t\t\tconsole.log(options.context);\n\t\t\t} else {\n\t\t\t\tconsole.log.apply(console, logs);\n\t\t\t}\n\t\t}\n\t},\n\t'data': function(attr){\n\t\t// options will either be the second or third argument.\n\t\t// Get the argument before that.\n\t\tvar data = arguments.length === 2 ? this : arguments[1];\n\t\treturn function(el){\n\t\t\tdomData.set.call( el, attr, data || this.context );\n\t\t};\n\t},\n\t'switch': function(expression, options){\n\t\tresolve(expression);\n\t\tvar found = false;\n\t\tvar newOptions = options.helpers.add({\n\t\t\t\"case\": function(value, options){\n\t\t\t\tif(!found && resolve(expression) === resolve(value)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn options.fn(options.scope || this);\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"default\": function(options){\n\t\t\t\tif(!found) {\n\t\t\t\t\treturn options.fn(options.scope || this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn options.fn(options.scope, newOptions);\n\t},\n\t'joinBase': function(firstExpr/* , expr... */){\n\t\tvar args = [].slice.call(arguments);\n\t\tvar options = args.pop();\n\n\t\tvar moduleReference = args.map( function(expr){\n\t\t\tvar value = resolve(expr);\n\t\t\treturn isFunction(value) ? value() : value;\n\t\t}).join(\"\");\n\n\t\tvar templateModule = options.helpers.peek(\"helpers.module\");\n\t\tvar parentAddress = templateModule ? templateModule.uri: undefined;\n\n\t\tvar isRelative = moduleReference[0] === \".\";\n\n\t\tif(isRelative && parentAddress) {\n\t\t\treturn joinURIs(parentAddress, moduleReference);\n\t\t} else {\n\t\t\tvar baseURL = (typeof System !== \"undefined\" &&\n\t\t\t\t(System.renderingBaseURL || System.baseURL)) ||\tgetBaseURL();\n\n\t\t\t// Make sure one of them has a needed /\n\t\t\tif(moduleReference[0] !== \"/\" && baseURL[baseURL.length - 1] !== \"/\") {\n\t\t\t\tbaseURL += \"/\";\n\t\t\t}\n\n\t\t\treturn joinURIs(baseURL, moduleReference);\n\t\t}\n\t}\n};\n\nhelpers.eachOf = helpers.each;\n\nvar registerHelper = function(name, callback){\n\t//!steal-remove-start\n\tif (helpers[name]) {\n\t\tdev.warn('The helper ' + name + ' has already been registered.');\n\t}\n\t//!steal-remove-end\n\n\thelpers[name] = callback;\n};\n\nvar makeSimpleHelper = function(fn) {\n\treturn function() {\n\t\tvar realArgs = [];\n\t\teach(arguments, function(val, i) {\n\t\t\tif (i <= arguments.length) {\n\t\t\t\twhile (val && val.isComputed) {\n\t\t\t\t\tval = val();\n\t\t\t\t}\n\t\t\t\trealArgs.push(val);\n\t\t\t}\n\t\t});\n\t\treturn fn.apply(this, realArgs);\n\t};\n};\n\nmodule.exports = {\n\tregisterHelper: registerHelper,\n\tregisterSimpleHelper: function(name, callback) {\n\t\tregisterHelper(name, makeSimpleHelper(callback));\n\t},\n\tgetHelper: function(name, options){\n\n\t\tvar helper = options && options.get && options.get(\"helpers.\" + name,{proxyMethods: false});\n\t\tif(!helper) {\n\t\t\thelper = helpers[name];\n\t\t}\n\t\tif(helper) {\n\t\t\treturn {fn: helper};\n\t\t}\n\t},\n\tresolve: resolve,\n\tresolveHash: resolveHash,\n\tlooksLikeOptions: looksLikeOptions\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/helpers/core.js\n// module id = 35\n// module chunks = 0","'use strict';\n\nvar getDocument = require('../document/document');\nvar fragment = require('../fragment/fragment');\nvar each = require('../../js/each/each');\nvar childNodes = require('../child-nodes/child-nodes');\n\n/**\n@module {function} can-util/dom/frag/frag frag\n@parent can-util/dom\n\nConvert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n\n@signature `frag: function(item, doc)`\n\n@param {String|HTMLElement|documentFragment|contentArray} item\n@param {Document} doc   an optional DOM document in which to build the fragment\n\n@return {documentFragment}\n\n@body\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var frag = require(\"can-util/dom/frag/frag\");\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = frag( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n */\n\nvar makeFrag = function(item, doc){\n\tvar document = doc || getDocument();\n\tvar frag;\n\tif(!item || typeof item === \"string\"){\n\t\tfrag = fragment(item == null ? \"\" : \"\"+item, document);\n\t\t// If we have an empty frag...\n\t\tif (!frag.childNodes.length) {\n\t\t\tfrag.appendChild(document.createTextNode(''));\n\t\t}\n\t\treturn frag;\n\t} else if(item.nodeType === 11) {\n\t\treturn item;\n\t} else if(typeof item.nodeType === \"number\") {\n\t\tfrag = document.createDocumentFragment();\n\t\tfrag.appendChild(item);\n\t\treturn frag;\n\t} else if(typeof item.length === \"number\") {\n\t\tfrag = document.createDocumentFragment();\n\t\teach(item, function(item){\n\t\t\tfrag.appendChild( makeFrag(item) );\n\t\t});\n\t\tif (!childNodes(frag).length) {\n\t\t\tfrag.appendChild(document.createTextNode(''));\n\t\t}\n\t\treturn frag;\n\t} else {\n\t\tfrag = fragment( \"\"+item, document);\n\t\t// If we have an empty frag...\n\t\tif (!childNodes(frag).length) {\n\t\t\tfrag.appendChild(document.createTextNode(''));\n\t\t}\n\t\treturn frag;\n\t}\n};\n\nmodule.exports = makeFrag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/frag/frag.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nvar CID = require(\"can-cid\");\nvar domDataCore = require(\"../../dom/data/core\");\n\nmodule.exports = function(obj){\n\tif(typeof obj.nodeType === \"number\") {\n\t\treturn domDataCore.cid.call(obj);\n\t} else {\n\t\tvar type = typeof obj;\n\t\tvar isObject = type !== null && (type === \"object\" || type === \"function\");\n\t\treturn type+\":\"+( isObject ? CID(obj) : obj );\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/cid/get-cid.js\n// module id = 37\n// module chunks = 0","'use strict';\n\n// The following is from jQuery\nfunction isArrayLike(obj){\n\tvar type = typeof obj;\n\tif(type === \"string\") {\n\t\treturn true;\n\t}\n\telse if(type === \"number\") {\n\t\treturn false;\n\t}\n\t// The `in` check is from jQuery’s fix for an iOS 8 64-bit JIT object length bug:\n\t// https://github.com/jquery/jquery/pull/2185\n\tvar length = obj && type !== 'boolean' &&\n\t\ttypeof obj !== 'number' &&\n\t\t\"length\" in obj && obj.length;\n\n\t// var length = \"length\" in obj && obj.length;\n\treturn typeof obj !== \"function\" &&\n\t\t( length === 0 || typeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\nmodule.exports = isArrayLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-array-like/is-array-like.js\n// module id = 38\n// module chunks = 0","'use strict';\n\nvar core_hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isWindow(obj) {\n\t// In IE8 window.window !== window.window, so we allow == here.\n\t/*jshint eqeqeq:false*/\n\treturn obj !== null && obj == obj.window;\n}\n\nfunction isPlainObject(obj) {\n\t// Must be an Object.\n\t// Because of IE, we also have to check the presence of the constructor property.\n\t// Make sure that DOM nodes and window objects don't pass through, as well\n\tif (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj)) {\n\t\treturn false;\n\t}\n\ttry {\n\t\t// Not own constructor property must be Object\n\t\tif (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {\n\t\t\treturn false;\n\t\t}\n\t} catch (e) {\n\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\treturn false;\n\t}\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {}\n\treturn key === undefined || core_hasOwn.call(obj, key);\n}\n\nmodule.exports = isPlainObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-plain-object/is-plain-object.js\n// module id = 39\n// module chunks = 0","var Observation = require('can-observation');\n\nvar dev = require('can-util/js/dev/dev');\nvar getGlobal = require('can-util/js/global/global');\nvar domMutate = require('can-util/dom/mutate/mutate');\nvar namespace = require('can-namespace');\n\nvar attr = function (attributeName, attrHandler) {\n\tif(attrHandler) {\n\t\tif (typeof attributeName === \"string\") {\n\t\t\tattributes[attributeName] = attrHandler;\n\t\t} else {\n\t\t\tregExpAttributes.push({\n\t\t\t\tmatch: attributeName,\n\t\t\t\thandler: attrHandler\n\t\t\t});\n\t\t}\n\t} else {\n\t\tvar cb = attributes[attributeName];\n\t\tif( !cb ) {\n\n\t\t\tfor( var i = 0, len = regExpAttributes.length; i < len; i++) {\n\t\t\t\tvar attrMatcher = regExpAttributes[i];\n\t\t\t\tif(attrMatcher.match.test(attributeName)) {\n\t\t\t\t\tcb = attrMatcher.handler;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cb;\n\t}\n};\n\nvar attributes = {},\n\tregExpAttributes = [],\n\tautomaticCustomElementCharacters = /[-\\:]/;\n\nvar tag = function (tagName, tagHandler) {\n\tif(tagHandler) {\n\t\t//!steal-remove-start\n\t\tif (typeof tags[tagName.toLowerCase()] !== 'undefined') {\n\t\t\tdev.warn(\"Custom tag: \" + tagName.toLowerCase() + \" is already defined\");\n\t\t}\n\t\tif (!automaticCustomElementCharacters.test(tagName) && tagName !== \"content\") {\n\t\t\tdev.warn(\"Custom tag: \" + tagName.toLowerCase() + \" hyphen missed\");\n\t\t}\n\t\t//!steal-remove-end\n\t\t// if we have html5shiv ... re-generate\n\t\tif (getGlobal().html5) {\n\t\t\tgetGlobal().html5.elements += \" \" + tagName;\n\t\t\tgetGlobal().html5.shivDocument();\n\t\t}\n\n\t\ttags[tagName.toLowerCase()] = tagHandler;\n\t} else {\n\t\tvar cb;\n\n\t\t// if null is passed as tagHandler, remove tag\n\t\tif (tagHandler === null) {\n\t\t\tdelete tags[tagName.toLowerCase()];\n\t\t} else {\n\t\t\tcb = tags[tagName.toLowerCase()];\n\t\t}\n\n\t\tif(!cb && automaticCustomElementCharacters.test(tagName)) {\n\t\t\t// empty callback for things that look like special tags\n\t\t\tcb = function(){};\n\t\t}\n\t\treturn cb;\n\t}\n\n};\nvar tags = {};\n\nvar callbacks = {\n\t_tags: tags,\n\t_attributes: attributes,\n\t_regExpAttributes: regExpAttributes,\n\ttag: tag,\n\tattr: attr,\n\t// handles calling back a tag callback\n\ttagHandler: function(el, tagName, tagData){\n\t\tvar helperTagCallback = tagData.options.get('tags.' + tagName,{proxyMethods: false}),\n\t\t\ttagCallback = helperTagCallback || tags[tagName];\n\n\t\t// If this was an element like <foo-bar> that doesn't have a component, just render its content\n\t\tvar scope = tagData.scope,\n\t\t\tres;\n\n\t\tif(tagCallback) {\n\t\t\tres = Observation.ignore(tagCallback)(el, tagData);\n\t\t} else {\n\t\t\tres = scope;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (!tagCallback) {\n\t\t\tdev.warn('can/view/scanner.js: No custom element found for ' + tagName);\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// If the tagCallback gave us something to render with, and there is content within that element\n\t\t// render it!\n\t\tif (res && tagData.subtemplate) {\n\n\t\t\tif (scope !== res) {\n\t\t\t\tscope = scope.add(res);\n\t\t\t}\n\t\t\tvar result = tagData.subtemplate(scope, tagData.options);\n\t\t\tvar frag = typeof result === \"string\" ? can.view.frag(result) : result;\n\t\t\tdomMutate.appendChild.call(el, frag);\n\t\t}\n\t}\n};\n\nnamespace.view = namespace.view || {};\n\nif (namespace.view.callbacks) {\n\tthrow new Error(\"You can't have two versions of can-view-callbacks, check your dependencies\");\n} else {\n\tmodule.exports = namespace.view.callbacks = callbacks;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-callbacks/can-view-callbacks.js\n// module id = 40\n// module chunks = 0","var live = require(\"./lib/core\");\nrequire(\"./lib/attr\");\nrequire(\"./lib/attrs\");\nrequire(\"./lib/html\");\nrequire(\"./lib/list\");\nrequire(\"./lib/text\");\n\n\nmodule.exports = live;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/can-view-live.js\n// module id = 41\n// module chunks = 0","// # can/view/scope/scope.js\n//\n// This allows you to define a lookup context and parent contexts that a key's value can be retrieved from.\n// If no parent scope is provided, only the scope's context will be explored for values.\nvar observeReader = require('can-observation/reader/reader');\nvar Observation = require('can-observation');\nvar ReferenceMap = require('./reference-map');\nvar makeComputeData = require('./compute_data');\nvar assign = require('can-util/js/assign/assign');\nvar each = require('can-util/js/each/each');\nvar namespace = require('can-namespace');\nvar dev = require('can-util/js/dev/dev');\n\n/**\n * @add can.view.Scope\n */\nfunction Scope(context, parent, meta) {\n\t// The obj that will be looked on for values.\n\tthis._context = context;\n\t// The next Scope object whose context should be looked on for values.\n\tthis._parent = parent;\n\t// If this is a special context, it can be labeled here.\n\t// Options are:\n\t// - viewModel - This is a viewModel\n\t// - notContext - This can't be looked within using `./` and `../`. It will be skipped.  This is\n\t//   for virtual contexts like those used by `%index`.\n\tthis._meta = meta || {};\n\n\t// A cache that can be used to store computes used to look up within this scope.\n\t// For example if someone creates a compute to lookup `name`, another compute does not\n\t// need to be created.\n\tthis.__cache = {};\n}\n\n/**\n * @static\n */\nassign(Scope, {\n\t// ## Scope.read\n\t// Scope.read was moved to can.compute.read\n\t// can.compute.read reads properties from a parent.  A much more complex version of getObject.\n\tread: observeReader.read,\n\t// ## Scope.Refs\n\t// A Map-like object used for the references scope.\n\tRefs: ReferenceMap,\n\n\t// ## Scope.refsScope\n\t// A scope with a references scope in it and no parent.\n\trefsScope: function() {\n\t\treturn new Scope(new this.Refs());\n\t}\n});\n/**\n * @prototype\n */\nassign(Scope.prototype, {\n\n\t// ## Scope.prototype.add\n\t// Creates a new scope and sets the current scope to be the parent.\n\t// ```\n\t// var scope = new can.view.Scope([\n\t//   {name:\"Chris\"},\n\t//   {name: \"Justin\"}\n\t// ]).add({name: \"Brian\"});\n\t// scope.attr(\"name\") //-> \"Brian\"\n\t// ```\n\tadd: function(context, meta) {\n\t\tif (context !== this._context) {\n\t\t\treturn new this.constructor(context, this, meta);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// ## Scope.prototype.read\n\t// Reads from the scope chain and returns the first non-`undefined` value.\n\t// `read` deals mostly with setting up \"context based\" keys to start reading\n\t// from the right scope.  Once the right scope is located, `_read` is called.\n\t/**\n\t * @hide\n\t * @param {can.stache.key} attr A dot seperated path.  Use `\"\\.\"` if you have a property name that includes a dot.\n\t * @param {can.view.Scope.readOptions} options that configure how this gets read.\n\t * @return {{}}\n\t *   @option {Object} parent the value's immediate parent\n\t *   @option {can.Map|can.compute} rootObserve the first observable to read from.\n\t *   @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.\n\t *   @option {*} value the found value\n\t */\n\tread: function(attr, options) {\n\t\t// If it's the root, jump right to it.\n\t\tif (attr === \"%root\") {\n\t\t\treturn {\n\t\t\t\tvalue: this.getRoot()\n\t\t\t};\n\t\t}\n\n\t\t// return a reference to itself when looking up \"%scope\"\n\t\tif (attr === \"%scope\") {\n\t\t\treturn {\n\t\t\t\tvalue: this\n\t\t\t};\n\t\t}\n\n\t\t// Identify context based keys.  Context based keys try to\n\t\t// specify a particular context a key should be within.\n\t\tvar isDotSlash = attr.substr(0, 2) === './',\n\t\t\tisThisDot = attr.substr(0,5) === \"this.\",\n\t\t    isInCurrentContext = isDotSlash || isThisDot,\n\t\t\tisInParentContext = attr.substr(0, 3) === \"../\",\n\t\t\tisCurrentContext = attr === \".\" || attr === \"this\",\n\t\t\tisParentContext = attr === \"..\",\n\t\t\tisContextBased = isInCurrentContext ||\n\t\t\tisInParentContext ||\n\t\t\tisCurrentContext ||\n\t\t\tisParentContext;\n\n\t\t// `notContext` contexts should be skipped if the key is \"context based\".\n\t\t// For example, the context that holds `%index`.\n\t\tif (isContextBased && this._meta.notContext) {\n\t\t\treturn this._parent.read(attr, options);\n\t\t}\n\n\t\t// If true, lookup stops after the current context.\n\t\tvar currentScopeOnly;\n\n\t\tif (isInCurrentContext) {\n\t\t\t// Stop lookup from checking parent scopes.\n\t\t\t// Set flag to halt lookup from walking up scope.\n\t\t\tcurrentScopeOnly = true;\n\t\t\tattr = isDotSlash ? attr.substr(2) : attr.substr(5);\n\t\t} else if (isInParentContext || isParentContext) {\n\t\t\t// walk up until we find a parent that can have context.\n\t\t\t// the `isContextBased` check above won't catch it when you go from\n\t\t\t// `../foo` to `foo` because `foo` isn't context based.\n\t\t\tvar parent = this._parent;\n\t\t\twhile (parent._meta.notContext) {\n\t\t\t\tparent = parent._parent;\n\t\t\t}\n\n\t\t\tif (isParentContext) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: parent._context\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn parent.read(attr.substr(3) || \".\", options);\n\t\t} else if (isCurrentContext) {\n\t\t\treturn {\n\t\t\t\tvalue: this._context\n\t\t\t};\n\t\t}\n\t\t// if it's a reference scope, read from there.\n\t\tvar keyReads = observeReader.reads(attr);\n\t\tif (keyReads[0].key.charAt(0) === \"*\") {\n\t\t\treturn this.getRefs()._read(keyReads, options, true);\n\t\t} else {\n\t\t\treturn this._read(keyReads, options, currentScopeOnly);\n\t\t}\n\t},\n\t// ## Scope.prototype._read\n\t//\n\t_read: function(keyReads, options, currentScopeOnly) {\n\n\t\t// The current scope and context we are trying to find \"keyReads\" within.\n\t\tvar currentScope = this,\n\t\t\tcurrentContext,\n\n\t\t\t// If no value can be found, this is a list of of every observed\n\t\t\t// object and property name to observe.\n\t\t\tundefinedObserves = [],\n\n\t\t\t// Tracks the first found observe.\n\t\t\tcurrentObserve,\n\t\t\t// Tracks the reads to get the value from `currentObserve`.\n\t\t\tcurrentReads,\n\n\t\t\t// Tracks the most likely observable to use as a setter.\n\t\t\tsetObserveDepth = -1,\n\t\t\tcurrentSetReads,\n\t\t\tcurrentSetObserve,\n\n\t\t\treadOptions = assign({\n\t\t\t\t/* Store found observable, incase we want to set it as the rootObserve. */\n\t\t\t\tfoundObservable: function(observe, nameIndex) {\n\t\t\t\t\tcurrentObserve = observe;\n\t\t\t\t\tcurrentReads = keyReads.slice(nameIndex);\n\t\t\t\t},\n\t\t\t\tearlyExit: function(parentValue, nameIndex) {\n\t\t\t\t\tif (nameIndex > setObserveDepth || (nameIndex === setObserveDepth && (typeof parentValue === \"object\" && keyReads[nameIndex].key in parentValue))) {\n\t\t\t\t\t\tcurrentSetObserve = currentObserve;\n\t\t\t\t\t\tcurrentSetReads = currentReads;\n\t\t\t\t\t\tsetObserveDepth = nameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, options);\n\n\t\t// Goes through each scope context provided until it finds the key (attr).  Once the key is found\n\t\t// then it's value is returned along with an observe, the current scope and reads.\n\t\t// While going through each scope context searching for the key, each observable found is returned and\n\t\t// saved so that either the observable the key is found in can be returned, or in the case the key is not\n\t\t// found in an observable the closest observable can be returned.\n\n\t\twhile (currentScope) {\n\t\t\tcurrentContext = currentScope._context;\n\n\n\n\t\t\tif (currentContext !== null &&\n\t\t\t\t// if its a primitive type, keep looking up the scope, since there won't be any properties\n\t\t\t\t(typeof currentContext === \"object\" || typeof currentContext === \"function\")\n\t\t\t) {\n\n\t\t\t\t// Prevent computes from temporarily observing the reading of observables.\n\t\t\t\tvar getObserves = Observation.trap();\n\n\t\t\t\tvar data = observeReader.read(currentContext, keyReads, readOptions);\n\n\t\t\t\t// Retrieve the observes that were read.\n\t\t\t\tvar observes = getObserves();\n\t\t\t\t// If a **value was was found**, return value and location data.\n\t\t\t\tif (data.value !== undefined) {\n\t\t\t\t\tObservation.addAll(observes);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tscope: currentScope,\n\t\t\t\t\t\trootObserve: currentObserve,\n\t\t\t\t\t\tvalue: data.value,\n\t\t\t\t\t\treads: currentReads\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Otherwise, save all observables that were read.  If no value\n\t\t\t\t// is found, we will observe on all of them.\n\t\t\t\telse {\n\t\t\t\t\tundefinedObserves.push.apply(undefinedObserves, observes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tif (currentScopeOnly) {\n\t\t\t\tcurrentScope = null;\n\t\t\t} else {\n\t\t\t\t// Move up to the next scope.\n\t\t\t\tcurrentScope = currentScope._parent;\n\t\t\t}\n\t\t}\n\n\t\t// The **value was not found**, return `undefined` for the value.\n\t\t// Make sure we listen to everything we checked for when the value becomes defined.\n\t\t// Once it becomes defined, we won't have to listen to so many things.\n\t\tObservation.addAll(undefinedObserves);\n\t\treturn {\n\t\t\tsetRoot: currentSetObserve,\n\t\t\treads: currentSetReads,\n\t\t\tvalue: undefined\n\t\t};\n\t},\n\n\t// ## Scope.prototype.get\n\t// Gets a value from the scope without being observable.\n\tget: function(key, options) {\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\tvar res = this.read(key, options);\n\t\treturn res.value;\n\t},\n\tpeek: Observation.ignore(function(key, options) {\n\t\treturn this.get(key, options);\n\t}),\n\tpeak: Observation.ignore(function(key, options) {\n\t\t//!steal-remove-start\n\t\tdev.warn('peak is deprecated, please use peek instead');\n\t\t//!steal-remove-end\n\t\treturn this.peek(key, options);\n\t}),\n\t// ## Scope.prototype.getScope\n\t// Returns the first scope that passes the `tester` function.\n\tgetScope: function(tester) {\n\t\tvar scope = this;\n\t\twhile (scope) {\n\t\t\tif (tester(scope)) {\n\t\t\t\treturn scope;\n\t\t\t}\n\t\t\tscope = scope._parent;\n\t\t}\n\t},\n\t// ## Scope.prototype.getContext\n\t// Returns the first context whose scope passes the `tester` function.\n\tgetContext: function(tester) {\n\t\tvar res = this.getScope(tester);\n\t\treturn res && res._context;\n\t},\n\t// ## Scope.prototype.getRefs\n\t// Returns the first references scope.\n\t// Used by `.read` when looking up `*key` and by the references\n\t// view binding.\n\tgetRefs: function() {\n\t\treturn this.getScope(function(scope) {\n\t\t\treturn scope._context instanceof Scope.Refs;\n\t\t});\n\t},\n\t// ## Scope.prototype.getRoot\n\t// Returns the top most context that is not a references scope.\n\t// Used by `.read` to provide `%root`.\n\tgetRoot: function() {\n\t\tvar cur = this,\n\t\t\tchild = this;\n\n\t\twhile (cur._parent) {\n\t\t\tchild = cur;\n\t\t\tcur = cur._parent;\n\t\t}\n\n\t\tif (cur._context instanceof Scope.Refs) {\n\t\t\tcur = child;\n\t\t}\n\t\treturn cur._context;\n\t},\n\tset: function(key, value, options) {\n\t\t// Use `.read` to read everything upto, but not including the last property name\n\t\t// to find the object we want to set some property on.\n\t\t// For example:\n\t\t//  - `foo.bar` -> `foo`\n\t\t//  - `../foo.bar` -> `../foo`\n\t\t//  - `../foo` -> `..`\n\t\t//  - `foo` -> `.`\n\t\tvar dotIndex = key.lastIndexOf('.'),\n\t\t\tslashIndex = key.lastIndexOf('/'),\n\t\t\tcontextPath,\n\t\t\tpropName;\n\n\t\tif (slashIndex > dotIndex) {\n\t\t\tcontextPath = key.substring(0, slashIndex);\n\t\t\tpropName = key.substring(slashIndex + 1, key.length);\n\t\t} else {\n\t\t\tif (dotIndex !== -1) {\n\t\t\t\tcontextPath = key.substring(0, dotIndex);\n\t\t\t\tpropName = key.substring(dotIndex + 1, key.length);\n\t\t\t} else {\n\t\t\t\tcontextPath = \".\";\n\t\t\t\tpropName = key;\n\t\t\t}\n\t\t}\n\n\t\tif (key.charAt(0) === \"*\") {\n\t\t\tobserveReader.write(this.getRefs()._context, key, value, options);\n\t\t} else {\n\t\t\tvar context = this.read(contextPath, options).value;\n\t\t\tobserveReader.write(context, propName, value, options);\n\t\t}\n\t},\n\n\t// ## Scope.prototype.attr\n\t// Gets or sets a value in the scope without being observable.\n\tattr: Observation.ignore(function(key, value, options) {\n\t\tconsole.warn(\"can-view-scope::attr is deprecated, please use peek, get or set\");\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\t// Allow setting a value on the context\n\t\tif (arguments.length === 2) {\n\t\t\treturn this.set(key, value, options);\n\n\t\t} else {\n\t\t\treturn this.get(key, options);\n\t\t}\n\n\t}),\n\n\n\n\t// ## Scope.prototype.computeData\n\t// Finds the first location of the key in the scope and then provides a get-set compute that represents the key's value\n\t// and other information about where the value was found.\n\tcomputeData: function(key, options) {\n\t\treturn makeComputeData(this, key, options);\n\t},\n\n\t// ## Scope.prototype.compute\n\t// Provides a get-set compute that represents a key's value.\n\tcompute: function(key, options) {\n\t\treturn this.computeData(key, options)\n\t\t\t.compute;\n\t},\n\t// ## Scope.prototype.cloneFromRef\n\t//\n\t// This takes a scope and essentially copies its chain from\n\t// right before the last Refs.  And it does not include the ref.\n\t// this is a helper function to provide lexical semantics for refs.\n\t// This will not be needed for leakScope: false.\n\tcloneFromRef: function() {\n\t\tvar contexts = [];\n\t\tvar scope = this,\n\t\t\tcontext,\n\t\t\tparent;\n\t\twhile (scope) {\n\t\t\tcontext = scope._context;\n\t\t\tif (context instanceof Scope.Refs) {\n\t\t\t\tparent = scope._parent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontexts.unshift(context);\n\t\t\tscope = scope._parent;\n\t\t}\n\t\tif (parent) {\n\t\t\teach(contexts, function(context) {\n\t\t\t\tparent = parent.add(context);\n\t\t\t});\n\t\t\treturn parent;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n});\n\nfunction Options(data, parent, meta) {\n\tif (!data.helpers && !data.partials && !data.tags) {\n\t\tdata = {\n\t\t\thelpers: data\n\t\t};\n\t}\n\tScope.call(this, data, parent, meta);\n}\nOptions.prototype = new Scope();\nOptions.prototype.constructor = Options;\n\nScope.Options = Options;\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.Scope = Scope;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-scope/can-view-scope.js\n// module id = 42\n// module chunks = 0","\"use strict\";\r\n\"format cjs\";\r\n\r\n\r\nvar event = require(\"can-event\");\r\nvar eventLifecycle = require(\"can-event/lifecycle/lifecycle\");\r\nvar canBatch = require(\"can-event/batch/batch\");\r\nvar canEvent = require(\"can-event\");\r\n\r\nvar compute = require(\"can-compute\");\r\nvar Observation = require(\"can-observation\");\r\n\r\nvar isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\r\nvar assign = require(\"can-util/js/assign/assign\");\r\nvar dev = require(\"can-util/js/dev/dev\");\r\nvar CID = require(\"can-cid\");\r\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\r\nvar isArray = require(\"can-util/js/is-array/is-array\");\r\nvar types = require(\"can-types\");\r\nvar each = require(\"can-util/js/each/each\");\r\nvar defaults = require(\"can-util/js/defaults/defaults\");\r\nvar stringToAny = require(\"can-util/js/string-to-any/string-to-any\");\r\nvar ns = require(\"can-namespace\");\r\n\r\nvar eventsProto, define,\r\n\tmake, makeDefinition, replaceWith, getDefinitionsAndMethods,\r\n\tisDefineType, getDefinitionOrMethod;\r\n\r\nvar defineConfigurableAndNotEnumerable = function(obj, prop, value) {\r\n\tObject.defineProperty(obj, prop, {\r\n\t\tconfigurable: true,\r\n\t\tenumerable: false,\r\n\t\twritable: true,\r\n\t\tvalue: value\r\n\t});\r\n};\r\n\r\nvar defineNotWritable = function(obj, prop, value) {\r\n\tObject.defineProperty(obj, prop, {\r\n\t\tconfigurable: true,\r\n\t\tenumerable: false,\r\n\t\twritable: false,\r\n\t\tvalue: value\r\n\t});\r\n};\r\n\r\nvar eachPropertyDescriptor = function(map, cb){\r\n\tfor(var prop in map) {\r\n\t\tif(map.hasOwnProperty(prop)) {\r\n\t\t\tcb(prop, Object.getOwnPropertyDescriptor(map,prop));\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\nmodule.exports = define = ns.define = function(objPrototype, defines, baseDefine) {\r\n\t// default property definitions on _data\r\n\tvar dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),\r\n\t\t// computed property definitions on _computed\r\n\t\tcomputedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);\r\n\r\n\tvar result = getDefinitionsAndMethods(defines, baseDefine);\r\n\tresult.dataInitializers = dataInitializers;\r\n\tresult.computedInitializers = computedInitializers;\r\n\r\n\r\n\t// Goes through each property definition and creates\r\n\t// a `getter` and `setter` function for `Object.defineProperty`.\r\n\teach(result.definitions, function(definition, property){\r\n\t\tdefine.property(objPrototype, property, definition, dataInitializers, computedInitializers);\r\n\t});\r\n\r\n\t// Places a `_data` on the prototype that when first called replaces itself\r\n\t// with a `_data` object local to the instance.  It also defines getters\r\n\t// for any value that has a default value.\r\n\treplaceWith(objPrototype, \"_data\", function() {\r\n\t\tvar map = this;\r\n\t\tvar data = {};\r\n\t\tfor (var prop in dataInitializers) {\r\n\t\t\treplaceWith(data, prop, dataInitializers[prop].bind(map), true);\r\n\t\t}\r\n\t\treturn data;\r\n\t});\r\n\r\n\t// Places a `_computed` on the prototype that when first called replaces itself\r\n\t// with a `_computed` object local to the instance.  It also defines getters\r\n\t// that will create the property's compute when read.\r\n\treplaceWith(objPrototype, \"_computed\", function() {\r\n\t\tvar map = this;\r\n\t\tvar data = Object.create(null);\r\n\t\tfor (var prop in computedInitializers) {\r\n\t\t\treplaceWith(data, prop, computedInitializers[prop].bind(map));\r\n\t\t}\r\n\t\treturn data;\r\n\t});\r\n\r\n\r\n\t// Add necessary event methods to this object.\r\n\tfor (var prop in eventsProto) {\r\n\t\tObject.defineProperty(objPrototype, prop, {\r\n\t\t\tenumerable: false,\r\n\t\t\tvalue: eventsProto[prop],\r\n\t\t\tconfigurable: true,\r\n\t\t\twritable: true\r\n\t\t});\r\n\t}\r\n\t// add so instance defs can be dynamically added\r\n\tObject.defineProperty(objPrototype,\"_define\",{\r\n\t\tenumerable: false,\r\n\t\tvalue: result,\r\n\t\tconfigurable: true,\r\n\t\twritable: true\r\n\t});\r\n\r\n\t// Places Symbol.iterator or @@iterator on the prototype\r\n\t// so that this can be iterated with for/of and can-util/js/each/each\r\n\tif(!objPrototype[types.iterator]) {\r\n\t\tdefineConfigurableAndNotEnumerable(objPrototype, types.iterator, function(){\r\n\t\t\treturn new define.Iterator(this);\r\n\t\t});\r\n\t}\r\n\r\n\treturn result;\r\n};\r\n\r\ndefine.extensions = function () {};\r\n\r\nvar onlyType = function(obj){\r\n\tfor(var prop in obj) {\r\n\t\tif(prop !== \"type\") {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n};\r\n\r\ndefine.property = function(objPrototype, prop, definition, dataInitializers, computedInitializers) {\r\n\tvar propertyDefinition = define.extensions.apply(this, arguments);\r\n\r\n\tif (propertyDefinition) {\r\n\t\tdefinition = propertyDefinition;\r\n\t}\r\n\r\n\tvar type = definition.type;\r\n\r\n\t// Special case definitions that have only `type: \"*\"`.\r\n\tif (type && onlyType(definition) && type === define.types[\"*\"]) {\r\n\t\tObject.defineProperty(objPrototype, prop, {\r\n\t\t\tget: make.get.data(prop),\r\n\t\t\tset: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: true\r\n\t\t});\r\n\t\treturn;\r\n\t}\r\n\tdefinition.type = type;\r\n\r\n\t// Where the value is stored.  If there is a `get` the source of the value\r\n\t// will be a compute in `this._computed[prop]`.  If not, the source of the\r\n\t// value will be in `this._data[prop]`.\r\n\tvar dataProperty = definition.get ? \"computed\" : \"data\",\r\n\r\n\t\t// simple functions that all read/get/set to the right place.\r\n\t\t// - reader - reads the value but does not observe.\r\n\t\t// - getter - reads the value and notifies observers.\r\n\t\t// - setter - sets the value.\r\n\t\treader = make.read[dataProperty](prop),\r\n\t\tgetter = make.get[dataProperty](prop),\r\n\t\tsetter = make.set[dataProperty](prop),\r\n\t\tgetInitialValue;\r\n\r\n\r\n\t// Determine the type converter\r\n\tvar typeConvert = function(val) {\r\n\t\treturn val;\r\n\t};\r\n\r\n\tif (definition.Type) {\r\n\t\ttypeConvert = make.set.Type(prop, definition.Type, typeConvert);\r\n\t}\r\n\tif (type) {\r\n\t\ttypeConvert = make.set.type(prop, type, typeConvert);\r\n\t}\r\n\r\n\t// make a setter that's going to fire of events\r\n\tvar eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));\r\n\r\n\t// Determine a function that will provide the initial property value.\r\n\tif ((definition.value !== undefined || definition.Value !== undefined)) {\r\n\t\tgetInitialValue = Observation.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));\r\n\t}\r\n\r\n\t// If property has a getter, create the compute that stores its data.\r\n\tif (definition.get) {\r\n\t\tcomputedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);\r\n\t}\r\n\t// If the property isn't a getter, but has an initial value, setup a\r\n\t// default value on `this._data[prop]`.\r\n\telse if (getInitialValue) {\r\n\t\tdataInitializers[prop] = getInitialValue;\r\n\t}\r\n\r\n\r\n\t// Define setter behavior.\r\n\r\n\t// If there's a `get` and `set`, make the setter get the `lastSetValue` on the\r\n\t// `get`'s compute.\r\n\tif (definition.get && definition.set) {\r\n\t\t// the compute will set off events, so we can use the basic setter\r\n\t\tsetter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);\r\n\t}\r\n\t// If there's a `set` and no `get`,\r\n\telse if (definition.set) {\r\n\t\t// Add `set` functionality to the eventSetter.\r\n\t\tsetter = make.set.setter(prop, definition.set, reader, eventsSetter, false);\r\n\t}\r\n\t// If there's niether `set` or `get`,\r\n\telse if (!definition.get) {\r\n\t\t// make a set that produces events.\r\n\t\tsetter = eventsSetter;\r\n\t}\r\n\r\n\t// Add type behavior to the setter.\r\n\tif (type) {\r\n\t\tsetter = make.set.type(prop, type, setter);\r\n\t}\r\n\tif (definition.Type) {\r\n\t\tsetter = make.set.Type(prop, definition.Type, setter);\r\n\t}\r\n\r\n\t// Define the property.\r\n\tObject.defineProperty(objPrototype, prop, {\r\n\t\tget: getter,\r\n\t\tset: setter,\r\n\t\tenumerable: \"serialize\" in definition ? !!definition.serialize : !definition.get,\r\n\t\tconfigurable: true\r\n\t});\r\n};\r\n\r\n\r\n// Makes a simple constructor function.\r\ndefine.Constructor = function(defines) {\r\n\tvar constructor = function(props) {\r\n\t\tdefine.setup.call(this, props);\r\n\t};\r\n\tdefine(constructor.prototype, defines);\r\n\treturn constructor;\r\n};\r\n\r\n// A bunch of helper functions that are used to create various behaviors.\r\nmake = {\r\n\t// Returns a function that creates the `_computed` prop.\r\n\tcompute: function(prop, get, defaultValueFn) {\r\n\t\treturn function() {\r\n\t\t\tvar map = this,\r\n\t\t\t\tdefaultValue = defaultValueFn && defaultValueFn.call(this),\r\n\t\t\t\tcomputeFn;\r\n\r\n\t\t\tif (defaultValue) {\r\n\t\t\t\tcomputeFn = defaultValue.isComputed ?\r\n\t\t\t\t\tdefaultValue :\r\n\t\t\t\t\tcompute.async(defaultValue, get, map);\r\n\t\t\t} else {\r\n\t\t\t\tcomputeFn = compute.async(defaultValue, get, map);\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcompute: computeFn,\r\n\t\t\t\tcount: 0,\r\n\t\t\t\thandler: function(ev, newVal, oldVal) {\r\n\t\t\t\t\tcanEvent.dispatch.call(map, {\r\n\t\t\t\t\t\ttype: prop,\r\n\t\t\t\t\t\ttarget: map\r\n\t\t\t\t\t}, [newVal, oldVal]);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t};\r\n\t},\r\n\t// Set related helpers.\r\n\tset: {\r\n\t\tdata: function(prop) {\r\n\t\t\treturn function(newVal) {\r\n\t\t\t\tthis._data[prop] = newVal;\r\n\t\t\t};\r\n\t\t},\r\n\t\tcomputed: function(prop) {\r\n\t\t\treturn function(val) {\r\n\t\t\t\tthis._computed[prop].compute(val);\r\n\t\t\t};\r\n\t\t},\r\n\t\tevents: function(prop, getCurrent, setData, eventType) {\r\n\t\t\treturn function(newVal) {\r\n\t\t\t\tif (this.__inSetup) {\r\n\t\t\t\t\tsetData.call(this, newVal);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar current = getCurrent.call(this);\r\n\t\t\t\t\tif (newVal !== current) {\r\n\t\t\t\t\t\tsetData.call(this, newVal);\r\n\r\n\t\t\t\t\t\tcanEvent.dispatch.call(this, {\r\n\t\t\t\t\t\t\ttype: prop,\r\n\t\t\t\t\t\t\ttarget: this\r\n\t\t\t\t\t\t}, [newVal, current]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tsetter: function(prop, setter, getCurrent, setEvents, hasGetter) {\r\n\t\t\treturn function(value) {\r\n\t\t\t\t//!steal-remove-start\r\n\t\t\t\tvar asyncTimer;\r\n\t\t\t\t//!steal-remove-end\r\n\r\n\t\t\t\tvar self = this;\r\n\r\n\t\t\t\t// call the setter, if returned value is undefined,\r\n\t\t\t\t// this means the setter is async so we\r\n\t\t\t\t// do not call update property and return right away\r\n\r\n\t\t\t\tcanBatch.start();\r\n\t\t\t\tvar setterCalled = false,\r\n\t\t\t\t\tcurrent = getCurrent.call(this),\r\n\t\t\t\t\tsetValue = setter.call(this, value, function(value) {\r\n\t\t\t\t\t\tsetEvents.call(self, value);\r\n\r\n\t\t\t\t\t\tsetterCalled = true;\r\n\t\t\t\t\t\t//!steal-remove-start\r\n\t\t\t\t\t\tclearTimeout(asyncTimer);\r\n\t\t\t\t\t\t//!steal-remove-end\r\n\t\t\t\t\t}, current);\r\n\r\n\t\t\t\tif (setterCalled) {\r\n\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (hasGetter) {\r\n\t\t\t\t\t\t// we got a return value\r\n\t\t\t\t\t\tif (setValue !== undefined) {\r\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\r\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\r\n\t\t\t\t\t\t\tif (current !== setValue) {\r\n\t\t\t\t\t\t\t\tsetEvents.call(this, setValue);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\r\n\t\t\t\t\t\t// so use the original set value\r\n\t\t\t\t\t\telse if (setter.length === 0) {\r\n\t\t\t\t\t\t\tsetEvents.call(this, value);\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// it took a value\r\n\t\t\t\t\t\telse if (setter.length === 1) {\r\n\t\t\t\t\t\t\t// if we have a getter, and undefined was returned,\r\n\t\t\t\t\t\t\t// we should assume this is setting the getters properties\r\n\t\t\t\t\t\t\t// and we shouldn't do anything.\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// we are expecting something\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t//!steal-remove-start\r\n\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\r\n\t\t\t\t\t\t\t\tdev.warn('can/map/setter.js: Setter \"' + prop + '\" did not return a value or call the setter callback.');\r\n\t\t\t\t\t\t\t}, dev.warnTimeout);\r\n\t\t\t\t\t\t\t//!steal-remove-end\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// we got a return value\r\n\t\t\t\t\t\tif (setValue !== undefined) {\r\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\r\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\r\n\t\t\t\t\t\t\tsetEvents.call(this, setValue);\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\r\n\t\t\t\t\t\t// so use the original set value\r\n\t\t\t\t\t\telse if (setter.length === 0) {\r\n\t\t\t\t\t\t\tsetEvents.call(this, value);\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// it took a value\r\n\t\t\t\t\t\telse if (setter.length === 1) {\r\n\t\t\t\t\t\t\t// if we don't have a getter, we should probably be setting the\r\n\t\t\t\t\t\t\t// value to undefined\r\n\t\t\t\t\t\t\tsetEvents.call(this, undefined);\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// we are expecting something\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t//!steal-remove-start\r\n\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\r\n\t\t\t\t\t\t\t\tdev.warn('can/map/setter.js: Setter \"' + prop + '\" did not return a value or call the setter callback.');\r\n\t\t\t\t\t\t\t}, dev.warnTimeout);\r\n\t\t\t\t\t\t\t//!steal-remove-end\r\n\t\t\t\t\t\t\tcanBatch.stop();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\ttype: function(prop, type, set) {\r\n\r\n\t\t\tif (typeof type === \"object\") {\r\n\r\n\t\t\t\treturn make.set.Type(prop, type, set);\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn function(newValue) {\r\n\t\t\t\t\treturn set.call(this, type.call(this, newValue, prop));\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\tType: function(prop, Type, set) {\r\n\t\t\t// `type`: {foo: \"string\"}\r\n\t\t\tif(isArray(Type) && types.DefineList) {\r\n\t\t\t\tType = types.DefineList.extend({\r\n\t\t\t\t\t\"#\": Type[0]\r\n\t\t\t\t});\r\n\t\t\t} else if (typeof Type === \"object\") {\r\n\t\t\t\tif(types.DefineMap) {\r\n\t\t\t\t\tType = types.DefineMap.extend(Type);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tType = define.constructor(Type);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn function(newValue) {\r\n\t\t\t\tif (newValue instanceof Type || newValue == null) {\r\n\t\t\t\t\treturn set.call(this, newValue);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn set.call(this, new Type(newValue));\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t},\r\n\t// Helpes that indicate what the event type should be.  These probably aren't needed.\r\n\teventType: {\r\n\t\tdata: function(prop) {\r\n\t\t\treturn function(newVal, oldVal) {\r\n\t\t\t\treturn oldVal !== undefined || this._data.hasOwnProperty(prop) ? \"set\" : \"add\";\r\n\t\t\t};\r\n\t\t},\r\n\t\tcomputed: function() {\r\n\t\t\treturn function() {\r\n\t\t\t\treturn \"set\";\r\n\t\t\t};\r\n\t\t}\r\n\t},\r\n\t// Helpers that read the data in a non-observable way.\r\n\tread: {\r\n\t\tdata: function(prop) {\r\n\t\t\treturn function() {\r\n\t\t\t\treturn this._data[prop];\r\n\t\t\t};\r\n\t\t},\r\n\t\tcomputed: function(prop) {\r\n\t\t\t// might want to protect this\r\n\t\t\treturn function() {\r\n\t\t\t\treturn this._computed[prop].compute();\r\n\t\t\t};\r\n\t\t},\r\n\t\tlastSet: function(prop) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar lastSetValue = this._computed[prop].compute.computeInstance.lastSetValue;\r\n\t\t\t\treturn lastSetValue && lastSetValue.get();\r\n\t\t\t};\r\n\t\t}\r\n\t},\r\n\t// Helpers that read the data in an observable way.\r\n\tget: {\r\n\t\t// uses the default value\r\n\t\tdefaultValue: function(prop, definition, typeConvert, callSetter) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar value = definition.value;\r\n\t\t\t\tif (value !== undefined) {\r\n\t\t\t\t\tif (typeof value === \"function\") {\r\n\t\t\t\t\t\tvalue = value.call(this);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = typeConvert(value);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar Value = definition.Value;\r\n\t\t\t\t\tif (Value) {\r\n\t\t\t\t\t\tvalue = typeConvert(new Value());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(definition.set) {\r\n\t\t\t\t\t// TODO: there's almost certainly a faster way of making this happen\r\n\t\t\t\t\t// But this is maintainable.\r\n\r\n\t\t\t\t\tvar VALUE;\r\n\t\t\t\t\tvar sync = true;\r\n\r\n\t\t\t\t\tvar setter = make.set.setter(prop, definition.set, function(){}, function(value){\r\n\t\t\t\t\t\tif(sync) {\r\n\t\t\t\t\t\t\tVALUE = value;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcallSetter.call(this, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, definition.get);\r\n\r\n\t\t\t\t\tsetter.call(this,value);\r\n\t\t\t\t\tsync= false;\r\n\r\n\t\t\t\t\t// VALUE will be undefined if the callback is never called.\r\n\t\t\t\t\treturn VALUE;\r\n\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t};\r\n\t\t},\r\n\t\tdata: function(prop) {\r\n\t\t\treturn function() {\r\n\t\t\t\tif (!this.__inSetup) {\r\n\t\t\t\t\tObservation.add(this, prop);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this._data[prop];\r\n\t\t\t};\r\n\t\t},\r\n\t\tcomputed: function(prop) {\r\n\t\t\treturn function() {\r\n\t\t\t\treturn this._computed[prop].compute();\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n};\r\n\r\ndefine.behaviors = [\"get\", \"set\", \"value\", \"Value\", \"type\", \"Type\", \"serialize\"];\r\n\r\nvar addDefinition = function(definition, behavior, value) {\r\n\tif(behavior === \"type\") {\r\n\t\tvar behaviorDef = value;\r\n\t\tif(typeof behaviorDef === \"string\") {\r\n\t\t\tbehaviorDef = define.types[behaviorDef];\r\n\t\t\tif(typeof behaviorDef === \"object\") {\r\n\t\t\t\tassign(definition, behaviorDef);\r\n\t\t\t\tbehaviorDef = behaviorDef[behavior];\r\n\t\t\t}\r\n\t\t}\r\n\t\tdefinition[behavior] = behaviorDef;\r\n\t}\r\n\telse {\r\n\t\tdefinition[behavior] = value;\r\n\t}\r\n};\r\n\r\nmakeDefinition = function(prop, def, defaultDefinition) {\r\n\tvar definition = {};\r\n\r\n\teach(def, function(value, behavior) {\r\n\t\taddDefinition(definition, behavior, value);\r\n\t});\r\n\t// only add default if it doesn't exist\r\n\teach(defaultDefinition, function(value, prop){\r\n\t\tif(definition[prop] === undefined) {\r\n\t\t\tif(prop !== \"type\" && prop !== \"Type\") {\r\n\t\t\t\tdefinition[prop] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t// if there's no type definition, take it from the defaultDefinition\r\n\tif(!definition.type && !definition.Type) {\r\n\t\tdefaults(definition, defaultDefinition);\r\n\t}\r\n\r\n\r\n\tif( isEmptyObject(definition) ) {\r\n\t\tdefinition.type = define.types[\"*\"];\r\n\t}\r\n\treturn definition;\r\n};\r\n\r\ngetDefinitionOrMethod = function(prop, value, defaultDefinition){\r\n\tvar definition;\r\n\tif(typeof value === \"string\") {\r\n\t\tdefinition = {type: value};\r\n\t}\r\n\telse if(typeof value === \"function\") {\r\n\t\tif(types.isConstructor(value)) {\r\n\t\t\tdefinition = {Type: value};\r\n\t\t} else if(isDefineType(value)) {\r\n\t\t\tdefinition = {type: value};\r\n\t\t}\r\n\t\t// or leaves as a function\r\n\t} else if( isArray(value) ) {\r\n\t\tdefinition = {Type: value};\r\n\t} else if( isPlainObject(value) ){\r\n\t\tdefinition = value;\r\n\t}\r\n\r\n\tif(definition) {\r\n\t\treturn makeDefinition(prop, definition, defaultDefinition);\r\n\t} else {\r\n\t\treturn value;\r\n\t}\r\n};\r\ngetDefinitionsAndMethods = function(defines, baseDefines) {\r\n\t// make it so the definitions include base definitions on the proto\r\n\tvar definitions = Object.create(baseDefines ? baseDefines.definitions : null);\r\n\tvar methods = {};\r\n\t// first lets get a default if it exists\r\n\tvar defaults = defines[\"*\"],\r\n\t\tdefaultDefinition;\r\n\tif(defaults) {\r\n\t\tdelete defines[\"*\"];\r\n\t\tdefaultDefinition = getDefinitionOrMethod(\"*\", defaults, {});\r\n\t} else {\r\n\t\tdefaultDefinition = Object.create(null);\r\n\t}\r\n\r\n\teachPropertyDescriptor(defines, function( prop, propertyDescriptor ) {\r\n\r\n\t\tvar value;\r\n\t\tif(propertyDescriptor.get || propertyDescriptor.set) {\r\n\t\t\tvalue = {get: propertyDescriptor.get, set: propertyDescriptor.set};\r\n\t\t} else {\r\n\t\t\tvalue = propertyDescriptor.value;\r\n\t\t}\r\n\r\n\t\tif(prop === \"constructor\") {\r\n\t\t\tmethods[prop] = value;\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\tvar result = getDefinitionOrMethod(prop, value, defaultDefinition);\r\n\t\t\tif(result && typeof result === \"object\") {\r\n\t\t\t\tdefinitions[prop] = result;\r\n\t\t\t} else {\r\n\t\t\t\tmethods[prop] = result;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tif(defaults) {\r\n\t\tdefines[\"*\"] = defaults;\r\n\t}\r\n\treturn {definitions: definitions, methods: methods, defaultDefinition: defaultDefinition};\r\n};\r\n\r\nreplaceWith = function(obj, prop, cb, writable) {\r\n\tObject.defineProperty(obj, prop, {\r\n\t\tconfigurable: true,\r\n\t\tget: function() {\r\n\t\t\tObject.defineProperty(this, prop, {\r\n\t\t\t\tvalue: undefined,\r\n\t\t\t\twritable: true\r\n\t\t\t});\r\n\t\t\tvar value = cb.call(this, obj, prop);\r\n\t\t\tObject.defineProperty(this, prop, {\r\n\t\t\t\tvalue: value,\r\n\t\t\t\twritable: !!writable\r\n\t\t\t});\r\n\t\t\treturn value;\r\n\t\t},\r\n\t\tset: function(value){\r\n\t\t\tObject.defineProperty(this, prop, {\r\n\t\t\t\tvalue: value,\r\n\t\t\t\twritable: !!writable\r\n\t\t\t});\r\n\t\t\treturn value;\r\n\t\t}\r\n\t});\r\n};\r\n\r\neventsProto = assign({}, event);\r\nassign(eventsProto, {\r\n\t_eventSetup: function() {},\r\n\t_eventTeardown: function() {},\r\n\taddEventListener: function(eventName, handler) {\r\n\r\n\t\tvar computedBinding = this._computed && this._computed[eventName];\r\n\t\tif (computedBinding && computedBinding.compute) {\r\n\t\t\tif (!computedBinding.count) {\r\n\t\t\t\tcomputedBinding.count = 1;\r\n\t\t\t\tcomputedBinding.compute.addEventListener(\"change\", computedBinding.handler);\r\n\t\t\t} else {\r\n\t\t\t\tcomputedBinding.count++;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn eventLifecycle.addAndSetup.apply(this, arguments);\r\n\t},\r\n\r\n\t// ### unbind\r\n\t// Stops listening to an event.\r\n\t// If this is the last listener of a computed property,\r\n\t// stop forwarding events of the computed property to this map.\r\n\tremoveEventListener: function(eventName, handler) {\r\n\t\tvar computedBinding = this._computed && this._computed[eventName];\r\n\t\tif (computedBinding) {\r\n\t\t\tif (computedBinding.count === 1) {\r\n\t\t\t\tcomputedBinding.count = 0;\r\n\t\t\t\tcomputedBinding.compute.removeEventListener(\"change\", computedBinding.handler);\r\n\t\t\t} else {\r\n\t\t\t\tcomputedBinding.count--;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn eventLifecycle.removeAndTeardown.apply(this, arguments);\r\n\r\n\t}\r\n});\r\neventsProto.on = eventsProto.bind = eventsProto.addEventListener;\r\neventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;\r\n\r\ndelete eventsProto.one;\r\n\r\ndefine.setup = function(props, sealed) {\r\n\tdefineNotWritable(this, \"__bindEvents\", Object.create(null));\r\n\tdefineNotWritable(this, \"constructor\", this.constructor);\r\n\t/* jshint -W030 */\r\n\tCID(this);\r\n\tdefineNotWritable(this, \"_cid\", this._cid);\r\n\tvar definitions = this._define.definitions;\r\n\tvar instanceDefinitions = Object.create(null);\r\n\tvar map = this;\r\n\teach(props, function(value, prop){\r\n\t\tif(definitions[prop]) {\r\n\t\t\tmap[prop] = value;\r\n\t\t} else {\r\n\t\t\tvar def = define.makeSimpleGetterSetter(prop);\r\n\t\t\tinstanceDefinitions[prop] = {};\r\n\t\t\tObject.defineProperty(map, prop, def);\r\n\t\t\t// possibly convert value to List or DefineMap\r\n\t\t\tmap[prop] = define.types.observable(value);\r\n\t\t}\r\n\t});\r\n\tif(!isEmptyObject(instanceDefinitions)) {\r\n\t\tdefineConfigurableAndNotEnumerable(this, \"_instanceDefinitions\", instanceDefinitions);\r\n\t}\r\n\t// only seal in dev mode for performance reasons.\r\n\t//!steal-remove-start\r\n\tthis._data;\r\n\tthis._computed;\r\n\tif(sealed !== false) {\r\n\t\tObject.seal(this);\r\n\t}\r\n\t//!steal-remove-end\r\n};\r\ndefine.replaceWith = replaceWith;\r\ndefine.eventsProto = eventsProto;\r\ndefine.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;\r\ndefine.make = make;\r\ndefine.getDefinitionOrMethod = getDefinitionOrMethod;\r\nvar simpleGetterSetters = {};\r\ndefine.makeSimpleGetterSetter = function(prop){\r\n\tif(!simpleGetterSetters[prop]) {\r\n\r\n\t\tvar setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop) );\r\n\r\n\t\tsimpleGetterSetters[prop] = {\r\n\t\t\tget: make.get.data(prop),\r\n\t\t\tset: function(newVal){\r\n\t\t\t\treturn setter.call(this, define.types.observable(newVal));\r\n\t\t\t},\r\n\t\t\tenumerable: true\r\n\t\t};\r\n\t}\r\n\treturn simpleGetterSetters[prop];\r\n};\r\n\r\ndefine.Iterator = function(obj){\r\n  this.obj = obj;\r\n  this.definitions = Object.keys(obj._define.definitions);\r\n  this.instanceDefinitions = obj._instanceDefinitions ?\r\n    Object.keys(obj._instanceDefinitions) :\r\n    Object.keys(obj);\r\n  this.hasGet = typeof obj.get === \"function\";\r\n};\r\n\r\ndefine.Iterator.prototype.next = function(){\r\n  var key;\r\n  if(this.definitions.length) {\r\n    key = this.definitions.shift();\r\n\r\n    // Getters should not be enumerable\r\n    var def = this.obj._define.definitions[key];\r\n    if(def.get) {\r\n      return this.next();\r\n    }\r\n  } else if(this.instanceDefinitions.length) {\r\n    key = this.instanceDefinitions.shift();\r\n  } else {\r\n    return {\r\n      value: undefined,\r\n      done: true\r\n    };\r\n  }\r\n\r\n  return {\r\n    value: [\r\n      key,\r\n      this.hasGet ? this.obj.get(key) : this.obj[key]\r\n    ],\r\n    done: false\r\n  };\r\n};\r\n\r\nisDefineType = function(func){\r\n\treturn func && func.canDefineType === true;\r\n};\r\n\r\ndefine.types = {\r\n\t'date': function(str) {\r\n\t\tvar type = typeof str;\r\n\t\tif (type === 'string') {\r\n\t\t\tstr = Date.parse(str);\r\n\t\t\treturn isNaN(str) ? null : new Date(str);\r\n\t\t} else if (type === 'number') {\r\n\t\t\treturn new Date(str);\r\n\t\t} else {\r\n\t\t\treturn str;\r\n\t\t}\r\n\t},\r\n\t'number': function(val) {\r\n\t\tif (val == null) {\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\treturn +(val);\r\n\t},\r\n\t'boolean': function(val) {\r\n\t\tif(val == null) {\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\tif (val === 'false' || val === '0' || !val) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\t'observable': function(newVal) {\r\n\t\t\t\tif(isArray(newVal) && types.DefineList) {\r\n\t\t\t\t\t\tnewVal = new types.DefineList(newVal);\r\n\t\t\t\t}\r\n\t\t\t\telse if(isPlainObject(newVal) &&  types.DefineMap) {\r\n\t\t\t\t\t\tnewVal = new types.DefineMap(newVal);\r\n\t\t\t\t}\r\n\t\t\t\treturn newVal;\r\n\t\t},\r\n\t'stringOrObservable': function(newVal) {\r\n\t\tif(isArray(newVal)) {\r\n\t\t\treturn new types.DefaultList(newVal);\r\n\t\t}\r\n\t\telse if(isPlainObject(newVal)) {\r\n\t\t\treturn new types.DefaultMap(newVal);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn define.types.string(newVal);\r\n\t\t}\r\n\t},\r\n\t/**\r\n\t * Implements HTML-style boolean logic for attribute strings, where\r\n\t * any string, including \"\", is truthy.\r\n\t */\r\n\t'htmlbool': function(val) {\r\n\t\tif (val === '') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn !!stringToAny(val);\r\n\t},\r\n\t'*': function(val) {\r\n\t\treturn val;\r\n\t},\r\n\t'any': function(val) {\r\n\t\treturn val;\r\n\t},\r\n\t'string': function(val) {\r\n\t\tif (val == null) {\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\treturn '' + val;\r\n\t},\r\n\r\n\t'compute': {\r\n\t\tset: function(newValue, setVal, setErr, oldValue) {\r\n\t\t\tif (newValue && newValue.isComputed) {\r\n\t\t\t\treturn newValue;\r\n\t\t\t}\r\n\t\t\tif (oldValue && oldValue.isComputed) {\r\n\t\t\t\toldValue(newValue);\r\n\t\t\t\treturn oldValue;\r\n\t\t\t}\r\n\t\t\treturn newValue;\r\n\t\t},\r\n\t\tget: function(value) {\r\n\t\t\treturn value && value.isComputed ? value() : value;\r\n\t\t}\r\n\t}\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-define/can-define.js\n// module id = 43\n// module chunks = 0","var Construct = require(\"can-construct\");\r\nvar define = require(\"can-define\");\r\nvar assign = require(\"can-util/js/assign/assign\");\r\nvar isArray = require(\"can-util/js/is-array/is-array\");\r\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\r\nvar defineHelpers = require(\"../define-helpers/define-helpers\");\r\nvar Observation = require(\"can-observation\");\r\nvar types = require(\"can-types\");\r\nvar canBatch = require(\"can-event/batch/batch\");\r\nvar ns = require(\"can-namespace\");\r\nvar canLog = require(\"can-util/js/log/log\");\r\n\r\nvar readWithoutObserve = Observation.ignore(function(map, prop){\r\n    return map[prop];\r\n});\r\n\r\nvar eachDefinition = function(map, cb, thisarg, definitions, observe) {\r\n\r\n    for(var prop in definitions) {\r\n        var definition = definitions[prop];\r\n        if(typeof definition !== \"object\" || (\"serialize\" in definition ? !!definition.serialize : !definition.get)) {\r\n\r\n            var item = observe === false ? readWithoutObserve(map, prop) : map[prop];\r\n\r\n            if (cb.call(thisarg || item, item, prop, map) === false) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar setProps = function(props, remove) {\r\n\tprops = defineHelpers.removeSpecialKeys(assign({}, props));\r\n    var prop,\r\n        self = this,\r\n        newVal;\r\n\r\n    // Batch all of the change events until we are done.\r\n    canBatch.start();\r\n    // Merge current properties with the new ones.\r\n    this.each(function(curVal, prop) {\r\n        // You can not have a _cid property; abort.\r\n        if (prop === \"_cid\") {\r\n            return;\r\n        }\r\n        newVal = props[prop];\r\n\r\n        // If we are merging, remove the property if it has no value.\r\n        if (newVal === undefined) {\r\n            if (remove) {\r\n                self[prop] = undefined;\r\n            }\r\n            return;\r\n        }\r\n        if( typeof curVal !== \"object\" || curVal === null ) {\r\n            self.set(prop, newVal);\r\n        }\r\n        else if( (\"replace\" in curVal) && isArray(newVal)) {\r\n            curVal.replace(newVal);\r\n        }        \r\n        else if( (\"set\" in curVal) && (isPlainObject(newVal) || isArray(newVal))) {\r\n            curVal.set(newVal, remove);\r\n        }\r\n        else if( (\"attr\" in curVal) && (isPlainObject(newVal) || isArray(newVal)) ) {\r\n            curVal.attr(newVal, remove);\r\n        }\r\n        else if(curVal !== newVal) {\r\n            self.set(prop, newVal);\r\n        }\r\n        delete props[prop];\r\n    }, this, false);\r\n    // Add remaining props.\r\n    for (prop in props) {\r\n        // Ignore _cid.\r\n        if (prop !== \"_cid\") {\r\n            newVal = props[prop];\r\n            this.set(prop, newVal);\r\n        }\r\n\r\n    }\r\n    canBatch.stop();\r\n    return this;\r\n};\r\n\r\nvar DefineMap = Construct.extend(\"DefineMap\",{\r\n    setup: function(base){\r\n\t\tvar key,\r\n\t\t\tprototype = this.prototype;\r\n        if(DefineMap) {\r\n            define(prototype, prototype, base.prototype._define);\r\n\t\t\tfor(key in DefineMap.prototype) {\r\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);\r\n\t\t\t}\r\n\r\n            this.prototype.setup = function(props){\r\n\t\t\t\tdefine.setup.call(\r\n\t\t\t\t\tthis, \r\n\t\t\t\t\tdefineHelpers.removeSpecialKeys(defineHelpers.toObject(this, props,{}, DefineMap)),\r\n\t\t\t\t\tthis.constructor.seal\r\n\t\t\t\t);\r\n            };\r\n\t\t} else {\r\n\t\t\tfor(key in prototype) {\r\n\t\t\t\tdefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);\r\n        }\r\n    }\r\n\t\tdefine.defineConfigurableAndNotEnumerable(prototype, \"constructor\", this);\r\n\t}\r\n},{\r\n    // setup for only dynamic DefineMap instances\r\n    setup: function(props, sealed){\r\n        if(!this._define) {\r\n            Object.defineProperty(this,\"_define\",{\r\n                enumerable: false,\r\n                value: {\r\n                    definitions: {}\r\n                }\r\n            });\r\n            Object.defineProperty(this,\"_data\",{\r\n                enumerable: false,\r\n                value: {}\r\n            });\r\n        }\r\n\t\tdefine.setup.call(\r\n\t\t\tthis,\r\n\t\t\tdefineHelpers.removeSpecialKeys(defineHelpers.toObject(this, props,{}, DefineMap)),\r\n\t\t\tsealed === true\r\n\t\t);\r\n    },\r\n    /**\r\n     * @function can-define/map/map.prototype.get get\r\n     * @parent can-define/map/map.prototype\r\n     *\r\n     * @description Get a value or all values from a DefineMap.\r\n     *\r\n     * @signature `map.get()`\r\n     *\r\n     * Returns a plain JavaScript object that contains the properties and values of the map instance.  Any property values\r\n     * that also have a `get` method will have their `get` method called and the resulting value will be used as\r\n     * the property value.  This can be used to recursively convert a map instance to an object of other plain\r\n     * JavaScript objects.  Cycles are supported and only create one object.\r\n     *\r\n     * `.get()` can still return other non plain JS objects like Date.\r\n     * Use [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\r\n     *\r\n     * ```js\r\n     * var map = new DefineMap({foo: new DefineMap({bar: \"zed\"})});\r\n     * map.get() //-> {foo: {bar: \"zed\"}};\r\n     * ```\r\n     *\r\n     *   @return {Object} A plain JavaScript `Object` that contains all the properties and values of the map instance.\r\n     *\r\n     * @signature `map.get(propName)`\r\n     *\r\n     * Get a single property on a DefineMap instance.\r\n     *\r\n     * `.get(propName)` only should be used when reading properties that might not have been defined yet, but\r\n     * will be later via [can-define/map/map.prototype.set].\r\n     *\r\n     * ```js\r\n     * var map = new DefineMap();\r\n     * map.get(\"name\") //-> undefined;\r\n     * ```\r\n     *\r\n     *   @param {String} propName The property name of a property that may not have been defined yet.\r\n     *   @return {*} The value of that property.\r\n     */\r\n    get: function(prop){\r\n        if(prop) {\r\n            var value = this[prop];\r\n            if(value !== undefined || prop in this || Object.isSealed(this)) {\r\n                return value;\r\n            } else {\r\n                Observation.add(this, prop);\r\n                return this[prop];\r\n            }\r\n\r\n        } else {\r\n            return defineHelpers.serialize(this, 'get', {});\r\n        }\r\n    },\r\n    /**\r\n     * @function can-define/map/map.prototype.set set\r\n     * @parent can-define/map/map.prototype\r\n     *\r\n     * @description Sets multiple properties on a map instance or a property that wasn't predefined.\r\n     *\r\n     * @signature `map.set(props [,removeProps])`\r\n     *\r\n     * Assigns each value in `props` to a property on this map instance named after the\r\n     * corresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in\r\n     * `props` will be set to `undefined`.\r\n     *\r\n     *   @param {Object} props A collection of key-value pairs to set.\r\n     *   If any properties already exist on the map, they will be overwritten.\r\n     *\r\n     *   @param {Boolean} [removeProps=false] Whether to set keys not present in `props` to `undefined`.\r\n     *\r\n     *   @return {can-define/map/map} The map instance for chaining.\r\n     *\r\n     * @signature `map.set(propName, value)`\r\n     *\r\n     * Assigns _value_ to a property on this map instance called _propName_.  This will define\r\n     * the property if it hasn't already been predefined.\r\n     *\r\n     *   @param {String} propName The property to set.\r\n     *   @param {*} value The value to assign to `propName`.\r\n     *   @return {can-define/map/map} This map instance, for chaining.\r\n     */\r\n    set: function(prop, value){\r\n        if(typeof prop === \"object\") {\r\n            return setProps.call(this, prop, value);\r\n        }\r\n        var defined = defineHelpers.defineExpando(this, prop, value);\r\n        if(!defined) {\r\n            this[prop] = value;\r\n        }\r\n        return this;\r\n    },\r\n    /**\r\n     * @function can-define/map/map.prototype.serialize serialize\r\n     * @parent can-define/map/map.prototype\r\n     *\r\n     * @description Get a serialized representation of the map instance and its children.\r\n     *\r\n     * @signature `map.serialize()`\r\n     *\r\n     * Get the serialized Object form of the map.  Serialized\r\n     * data is typically used to send back to a server.  Use [can-define.types.serialize]\r\n     * to customize a property's serialized value or if the property should be added to\r\n     * the result or not.\r\n     *\r\n     * `undefined` serialized values are not added to the result.\r\n     *\r\n     * ```js\r\n     * var MyMap = DefineMap.extend({\r\n     *   date: {\r\n     *     type: \"date\",\r\n     *     serialize: function(date){\r\n     *       return date.getTime()\r\n     *     }\r\n     *   }\r\n     * });\r\n     *\r\n     * var myMap = new MyMap({date: new Date(), count: 5});\r\n     * myMap.serialize() //-> {date: 1469566698504, count: 5}\r\n     * ```\r\n     *\r\n     *   @return {Object} A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\r\n     *\r\n     */\r\n    serialize: function () {\r\n        return defineHelpers.serialize(this, 'serialize', {});\r\n    },\r\n\r\n    forEach: function(cb, thisarg, observe){\r\n        if(observe !== false) {\r\n            Observation.add(this, '__keys');\r\n        }\r\n        var res;\r\n        var constructorDefinitions = this._define.definitions;\r\n        if(constructorDefinitions) {\r\n            res = eachDefinition(this, cb, thisarg, constructorDefinitions, observe);\r\n        }\r\n        if(res === false) {\r\n            return this;\r\n        }\r\n        if(this._instanceDefinitions) {\r\n            eachDefinition(this, cb, thisarg, this._instanceDefinitions, observe);\r\n        }\r\n\r\n        return this;\r\n    },\r\n    \"*\": {\r\n        type: define.types.observable\r\n    }\r\n});\r\n\r\n// Add necessary event methods to this object.\r\nfor(var prop in define.eventsProto) {\r\n\tDefineMap[prop] = define.eventsProto[prop];\r\n    Object.defineProperty(DefineMap.prototype, prop, {\r\n        enumerable:false,\r\n        value: define.eventsProto[prop],\r\n        writable: true\r\n    });\r\n}\r\ntypes.DefineMap = DefineMap;\r\ntypes.DefaultMap = DefineMap;\r\n\r\nDefineMap.prototype.toObject = function(){\r\n    canLog.warn(\"Use DefineMap::get instead of DefineMap::toObject\");\r\n    return this.get();\r\n};\r\nDefineMap.prototype.each = DefineMap.prototype.forEach;\r\n\r\nvar oldIsMapLike = types.isMapLike;\r\ntypes.isMapLike = function(obj){\r\n\treturn obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\r\n};\r\n\r\nmodule.exports = ns.DefineMap = DefineMap;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-define/map/map.js\n// module id = 44\n// module chunks = 0","var compute = require('can-compute');\nvar observeReader = require('can-observation/reader/reader');\n\nvar utils = require('./utils');\nvar mustacheHelpers = require('../helpers/core');\n\nvar each = require('can-util/js/each/each');\nvar isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');\nvar dev = require('can-util/js/dev/dev');\nvar assign = require('can-util/js/assign/assign');\nvar last = require('can-util/js/last/last');\n// ## Helpers\n\n// Helper for getting a bound compute in the scope.\nvar getKeyComputeData = function (key, scope, readOptions) {\n\n\t\tvar data = scope.computeData(key, readOptions);\n\n\t\tcompute.temporarilyBind(data.compute);\n\n\t\treturn data;\n\t},\n\t// Looks up a value in the scope and returns a compute if the value is\n\t// observable and the value if not.\n\tlookupValue = function(key, scope, helperOptions, readOptions){\n\t\tvar prop = getValueOfComputeOrFunction(key);\n\t\tvar computeData = getKeyComputeData(prop, scope, readOptions);\n\t\t// If there are no dependencies, just return the value.\n\t\tif (!computeData.compute.computeInstance.hasDependencies) {\n\t\t\treturn {value: computeData.initialValue, computeData: computeData};\n\t\t} else {\n\t\t\treturn {value: computeData.compute, computeData: computeData};\n\t\t}\n\t},\n\t// Looks up a value in the scope, and if it is `undefined`, looks up\n\t// the value as a helper.\n\tlookupValueOrHelper = function(key, scope, helperOptions, readOptions){\n\t\tvar res = lookupValue(key, scope, helperOptions, readOptions);\n\n\t\t// If it doesn't look like a helper and there is no value, check helpers\n\t\t// anyway. This is for when foo is a helper in `{{foo}}`.\n\t\tif( res.computeData.initialValue === undefined ) {\n\t\t\tif(key.charAt(0) === \"@\" && key !== \"@index\") {\n\t\t\t\tkey = key.substr(1);\n\t\t\t}\n\t\t\tvar helper = mustacheHelpers.getHelper(key, helperOptions);\n\t\t\tres.helper = helper && helper.fn;\n\t\t}\n\t\treturn res;\n\t},\n\t// Looks up a value in the result of a Lookup or Call expression\n\tlookupValueInResult = function(keyOrCompute, lookupOrCall, scope, helperOptions, readOptions) {\n\t\tvar result = lookupOrCall.value(scope, {}, {});\n\n\t\tvar c = compute(function(newVal) {\n\t\t\tvar key = getValueOfComputeOrFunction(keyOrCompute);\n\t\t\tif (arguments.length) {\n\t\t\t\tobserveReader.write(result, observeReader.reads(key), newVal);\n\t\t\t} else {\n\t\t\t\t// Convert possibly numeric key to string, because observeReader.get will do a charAt test on it.\n\t\t\t\t// also escape `.` so that things like [\"bar.baz\"] will work correctly\n\t\t\t\treturn observeReader.get(result, (\"\" + key).replace(\".\", \"\\\\.\"));\n\t\t\t}\n\t\t});\n\n\t\treturn { value: c };\n\t},\n\t// gets the value of a compute or function\n\tgetValueOfComputeOrFunction = function (computeOrFunction) {\n\t\tif (typeof computeOrFunction.value === 'function') {\n\t\t\treturn computeOrFunction.value();\n\t\t}\n\n\t\tif (typeof computeOrFunction === 'function') {\n\t\t\treturn computeOrFunction();\n\t\t}\n\n\t\treturn computeOrFunction;\n\t},\n\t// If not a Literal or an Arg, convert to an arg for caching.\n\tconvertToArgExpression = function(expr){\n\t\tif(!(expr instanceof Arg) && !(expr instanceof Literal)) {\n\t\t\treturn new Arg(expr);\n\t\t} else {\n\t\t\treturn expr;\n\t\t}\n\n\t};\n\n// ## Expression Types\n//\n// These expression types return a value. They are assembled by `expression.parse`.\n\n// ### Bracket\n// For accessing properties using bracket notation like `foo[bar]`\nvar Bracket = function (key, root) {\n\tthis.root = root;\n\tthis.key = key;\n};\nBracket.prototype.value = function (scope) {\n\tvar prop = this.key;\n\tvar obj = this.root;\n\n\tif (prop instanceof Lookup) {\n\t\tprop = lookupValue(prop.key, scope, {}, {}).value;\n\t} else if (prop instanceof Call) {\n\t\tprop = prop.value(scope, {}, {});\n\t}\n\n\tif (!obj) {\n\t\treturn lookupValue(prop, scope, {}, {}).value;\n\t} else {\n\t\treturn lookupValueInResult(prop, obj, scope, {}, {}).value;\n\t}\n};\n\n// ### Literal\n// For inline static values like `{{\"Hello World\"}}`\nvar Literal = function(value){\n\tthis._value = value;\n};\nLiteral.prototype.value = function(){\n\treturn this._value;\n};\n\n// ### Lookup\n// `new Lookup(String, [Expression])`\n// Finds a value in the scope or a helper.\nvar Lookup = function(key, root) {\n\tthis.key = key;\n\tthis.rootExpr = root;\n};\nLookup.prototype.value = function(scope, helperOptions){\n\tvar result = {};\n\n\tif (this.rootExpr) {\n\t\tresult = lookupValueInResult(this.key, this.rootExpr, scope, {}, {});\n\t} else {\n\t\tresult = lookupValueOrHelper(this.key, scope, helperOptions);\n\t}\n\t// TODO: remove this.  This is hacky.\n\tthis.isHelper = result.helper && !result.helper.callAsMethod;\n\treturn result.helper || result.value;\n};\n\n// ### ScopeLookup\n// Looks up a value in the scope, returns a compute for the value it finds.\n// If passed an expression, that is used to lookup data\nvar ScopeLookup = function(key, root) {\n\tLookup.apply(this, arguments);\n};\nScopeLookup.prototype.value = function(scope, helperOptions){\n\tif (this.rootExpr) {\n\t\treturn lookupValueInResult(this.key, this.rootExpr, scope, {}, {}).value;\n\t}\n\n\treturn lookupValue(this.key, scope, helperOptions).value;\n};\n\n// ### Arg\n// `new Arg(Expression [,modifierOptions] )`\n// Used to identify an expression that should return a value.\nvar Arg = function(expression, modifiers){\n\tthis.expr = expression;\n\tthis.modifiers = modifiers || {};\n\tthis.isCompute = false;\n};\nArg.prototype.value = function(){\n\treturn this.expr.value.apply(this.expr, arguments);\n};\n\n// ### Hash\n// A placeholder. This isn't actually used.\nvar Hash = function(){ }; // jshint ignore:line\n\nvar Hashes = function(hashes){\n\tthis.hashExprs = hashes;\n};\nHashes.prototype.value = function(scope, helperOptions){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = convertToArgExpression(this.hashExprs[prop]),\n\t\t\tvalue = val.value.apply(val, arguments);\n\n\t\thash[prop] = {\n\t\t\tcall: value && value.isComputed && !val.modifiers.compute,\n\t\t\tvalue: value\n\t\t};\n\t}\n\treturn compute(function(){\n\t\tvar finalHash = {};\n\t\tfor(var prop in hash) {\n\t\t\tfinalHash[prop] = hash[prop].call ? hash[prop].value() : hash[prop].value;\n\t\t}\n\t\treturn finalHash;\n\t});\n};\n// ### Call\n// `new Call( new Lookup(\"method\"), [new ScopeExpr(\"name\")], {})`\n// A call expression like `method(arg1, arg2)` that, by default,\n// calls `method` with non compute values.\nvar Call = function(methodExpression, argExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions.map(convertToArgExpression);\n};\nCall.prototype.args = function(scope, helperOptions){\n\tvar args = [];\n\tfor(var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\tvar value = arg.value.apply(arg, arguments);\n\t\targs.push({\n\t\t\tcall: value && value.isComputed && !arg.modifiers.compute,\n\t\t\tvalue: value\n\t\t});\n\t}\n\treturn function(){\n\t\tvar finalArgs = [];\n\t\tfor(var i = 0, len = args.length; i < len; i++) {\n\t\t\tfinalArgs[i] = args[i].call ? args[i].value() : args[i].value;\n\t\t}\n\t\treturn finalArgs;\n\t};\n};\n\nCall.prototype.value = function(scope, helperScope, helperOptions){\n\n\tvar method = this.methodExpr.value(scope, helperScope);\n\t// TODO: remove this hack\n\tvar isHelper = this.isHelper = this.methodExpr.isHelper;\n\n\tvar getArgs = this.args(scope, helperScope);\n\n\treturn compute(function(newVal){\n\t\tvar func = method;\n\t\tif(func && func.isComputed) {\n\t\t\tfunc = func();\n\t\t}\n\t\tif(typeof func === \"function\") {\n\t\t\tvar args = getArgs();\n\n\t\t\t// if fn/inverse is needed, add after this\n\n\t\t\tif(isHelper && helperOptions) {\n\t\t\t\targs.push(helperOptions);\n\t\t\t}\n\t\t\tif(arguments.length) {\n\t\t\t\targs.unshift(new expression.SetIdentifier(newVal));\n\t\t\t}\n\n\t\t\treturn func.apply(null, args);\n\t\t}\n\n\t});\n\n};\n\nCall.prototype.closingTag = function() {\n\treturn this.methodExpr.key.slice(1);\n};\n\n// ### HelperLookup\n// An expression that looks up a value in the helper or scope.\n// Any functions found prior to the last one are called with\n// the context and scope.\nvar HelperLookup = function(){\n\tLookup.apply(this, arguments);\n};\nHelperLookup.prototype.value = function(scope, helperOptions){\n\tvar result = lookupValueOrHelper(this.key, scope, helperOptions, {isArgument: true, args: [scope.peek('.'), scope]});\n\treturn result.helper || result.value;\n};\n\n// ### HelperScopeLookup\n// An expression that looks up a value in the scope.\n// Any functions found prior to the last one are called with\n// the context and scope.\nvar HelperScopeLookup = function(){\n\tLookup.apply(this, arguments);\n};\nHelperScopeLookup.prototype.value = function(scope, helperOptions){\n\treturn lookupValue(this.key, scope, helperOptions, {\n\t\tcallMethodsOnObservables: true,\n\t\tisArgument: true,\n\t\targs: [ scope.peek('.'), scope ]\n\t}).value;\n};\n\nvar Helper = function(methodExpression, argExpressions, hashExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions;\n\tthis.hashExprs = hashExpressions;\n\tthis.mode = null;\n};\nHelper.prototype.args = function(scope, helperOptions){\n\tvar args = [];\n\tfor(var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\targs.push( arg.value.apply(arg, arguments) );\n\t}\n\treturn args;\n};\nHelper.prototype.hash = function(scope, helperOptions){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = this.hashExprs[prop];\n\t\thash[prop] = val.value.apply(val, arguments);\n\t}\n\treturn hash;\n};\n// looks up the name key in the scope\n// returns a `helper` property if there is a helper for the key.\n// returns a `value` property if the value is looked up.\nHelper.prototype.helperAndValue = function(scope, helperOptions){\n\n\t//{{foo bar}}\n\tvar looksLikeAHelper = this.argExprs.length || !isEmptyObject(this.hashExprs),\n\t\thelper,\n\t\tvalue,\n\t\t// If a literal, this means it should be treated as a key. But helpers work this way for some reason.\n\t\t// TODO: fix parsing so numbers will also be assumed to be keys.\n\t\tmethodKey = this.methodExpr instanceof Literal ?\n\t\t\t\"\"+this.methodExpr._value : this.methodExpr.key,\n\t\tinitialValue,\n\t\targs;\n\n\t// If the expression looks like a helper, try to get a helper right away.\n\tif (looksLikeAHelper) {\n\t\t// Try to find a registered helper.\n\t\thelper = mustacheHelpers.getHelper(methodKey, helperOptions);\n\n\t\t// If a function is on top of the context, call that as a helper.\n\t\tvar context = scope.peek(\".\");\n\t\tif(!helper && typeof context[methodKey] === \"function\") {\n\t\t\t//!steal-remove-start\n\t\t\tdev.warn('can-stache/src/expression.js: In 3.0, method \"' + methodKey + '\" will not be called as a helper, but as a method.');\n\t\t\t//!steal-remove-end\n\t\t\thelper = {fn: context[methodKey]};\n\t\t}\n\n\t}\n\tif(!helper) {\n\t\targs = this.args(scope, helperOptions);\n\t\t// Get info about the compute that represents this lookup.\n\t\t// This way, we can get the initial value without \"reading\" the compute.\n\t\tvar computeData = getKeyComputeData(methodKey, scope, {\n\t\t\tisArgument: false,\n\t\t\targs: args && args.length ? args : [scope.peek('.'), scope]\n\t\t}),\n\t\t\tcompute = computeData.compute;\n\n\t\tinitialValue = computeData.initialValue;\n\n\t\t// Set name to be the compute if the compute reads observables,\n\t\t// or the value of the value of the compute if no observables are found.\n\t\tif(computeData.compute.computeInstance.hasDependencies) {\n\t\t\tvalue = compute;\n\t\t} else {\n\t\t\tvalue = initialValue;\n\t\t}\n\n\t\t// If it doesn't look like a helper and there is no value, check helpers\n\t\t// anyway. This is for when foo is a helper in `{{foo}}`.\n\t\tif( !looksLikeAHelper && initialValue === undefined ) {\n\t\t\thelper = mustacheHelpers.getHelper(methodKey, helperOptions);\n\t\t}\n\n\t}\n\n\t//!steal-remove-start\n\tif ( !helper && initialValue === undefined) {\n\t\tif(looksLikeAHelper) {\n\t\t\tdev.warn('can-stache/src/expression.js: Unable to find helper \"' + methodKey + '\".');\n\t\t} else {\n\t\t\tdev.warn('can-stache/src/expression.js: Unable to find key or helper \"' + methodKey + '\".');\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\treturn {\n\t\tvalue: value,\n\t\targs: args,\n\t\thelper: helper && helper.fn\n\t};\n};\nHelper.prototype.evaluator = function(helper, scope, helperOptions, /*REMOVE*/readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly){\n\n\tvar helperOptionArg = {\n\t\tfn: function () {},\n\t\tinverse: function () {},\n\t\tstringOnly: stringOnly\n\t},\n\t\tcontext = scope.peek(\".\"),\n\t\targs = this.args(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly),\n\t\thash = this.hash(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\n\t// Add additional data to be used by helper functions\n\tutils.convertToScopes(helperOptionArg, scope,helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\n\tassign(helperOptionArg, {\n\t\tcontext: context,\n\t\tscope: scope,\n\t\tcontexts: scope,\n\t\thash: hash,\n\t\tnodeList: nodeList,\n\t\texprData: this,\n\t\thelperOptions: helperOptions,\n\t\thelpers: helperOptions\n\t});\n\n\targs.push(helperOptionArg);\n\t// Call the helper.\n\treturn function () {\n\t\treturn helper.apply(context, args);\n\t};\n};\n\nHelper.prototype.value = function(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly){\n\n\tvar helperAndValue = this.helperAndValue(scope, helperOptions);\n\n\tvar helper = helperAndValue.helper;\n\t// a method could have been called, resulting in a value\n\tif(!helper) {\n\t\treturn helperAndValue.value;\n\t}\n\n\tvar fn = this.evaluator(helper, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\n\tvar computeValue = compute(fn);\n\n\tcompute.temporarilyBind(computeValue);\n\n\tif (!computeValue.computeInstance.hasDependencies) {\n\t\treturn computeValue();\n\t} else {\n\t\treturn computeValue;\n\t}\n};\n\nHelper.prototype.closingTag = function() {\n\treturn this.methodExpr.key;\n};\n\n\n// NAME - \\w\n// KEY - foo, foo.bar, foo@bar, %foo (special), &foo (references), ../foo, ./foo\n// ARG - ~KEY, KEY, CALLEXPRESSION, PRIMITIVE\n// CALLEXPRESSION = KEY(ARG,ARG, NAME=ARG)\n// HELPEREXPRESSION = KEY ARG ARG NAME=ARG\n// DOT .NAME\n// AT @NAME\n//\nvar keyRegExp = /[\\w\\.\\\\\\-_@\\/\\&%]+/,\n\ttokensRegExp = /('.*?'|\".*?\"|=|[\\w\\.\\\\\\-_@\\/*%\\$]+|[\\(\\)]|,|\\~|\\[|\\]\\s*|\\s*(?=\\[))/g,\n\tbracketSpaceRegExp = /\\]\\s+/,\n\tliteralRegExp = /^('.*?'|\".*?\"|[0-9]+\\.?[0-9]*|true|false|null|undefined)$/;\n\nvar isTokenKey = function(token){\n\treturn keyRegExp.test(token);\n};\n\nvar testDot = /^[\\.@]\\w/;\nvar isAddingToExpression = function(token) {\n\n\treturn isTokenKey(token) && testDot.test(token);\n};\n\nvar ensureChildren = function(type) {\n\tif(!type.children) {\n\t\ttype.children = [];\n\t}\n\treturn type;\n};\n\nvar Stack = function(){\n\n\tthis.root = {children: [], type: \"Root\"};\n\tthis.current = this.root;\n\tthis.stack = [this.root];\n};\nassign(Stack.prototype,{\n\ttop: function(){\n\t\treturn last(this.stack);\n\t},\n\tisRootTop: function(){\n\t\treturn this.top() === this.root;\n\t},\n\tpopTo: function(types){\n\t\tthis.popUntil(types);\n\t\tthis.pop();\n\t},\n\tpop: function() {\n\t\tif(!this.isRootTop()) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t},\n\tfirst: function(types){\n\t\tvar curIndex = this.stack.length - 1;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tfirstParent: function(types){\n\t\tvar curIndex = this.stack.length - 2;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tpopUntil: function(types){\n\t\twhile( types.indexOf(this.top().type) === -1 && !this.isRootTop() ) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t\treturn this.top();\n\t},\n\taddTo: function(types, type){\n\t\tvar cur = this.popUntil(types);\n\t\tensureChildren(cur).children.push(type);\n\t},\n\taddToAndPush: function(types, type){\n\t\tthis.addTo(types, type);\n\t\tthis.stack.push(type);\n\t},\n\tpush: function(type) {\n\t\tthis.stack.push(type);\n\t},\n\ttopLastChild: function(){\n\t\treturn last(this.top().children);\n\t},\n\treplaceTopLastChild: function(type){\n\t\tvar children = ensureChildren(this.top()).children;\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\treturn type;\n\t},\n\treplaceTopLastChildAndPush: function(type) {\n\t\tthis.replaceTopLastChild(type);\n\t\tthis.stack.push(type);\n\t},\n\treplaceTopAndPush: function(type){\n\t\tvar children;\n\t\tif(this.top() === this.root) {\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t} else {\n\t\t\tthis.stack.pop();\n\t\t\t// get parent and clean\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t}\n\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\tthis.stack.push(type);\n\t\treturn type;\n\t}\n});\n\n// converts\n// - \"../foo\" -> \"../@foo\",\n// - \"foo\" -> \"@foo\",\n// - \".foo\" -> \"@foo\",\n// - \"./foo\" -> \"./@foo\"\n// - \"foo.bar\" -> \"foo@bar\"\nvar convertKeyToLookup = function(key){\n\tvar lastPath = key.lastIndexOf(\"./\");\n\tvar lastDot = key.lastIndexOf(\".\");\n\tif(lastDot > lastPath) {\n\t\treturn key.substr(0, lastDot)+\"@\"+key.substr(lastDot+1);\n\t}\n\tvar firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath+2;\n\tvar firstNonPathChar = key.charAt(firstNonPathCharIndex);\n\tif(firstNonPathChar === \".\" || firstNonPathChar === \"@\" ) {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex+1);\n\t} else {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex);\n\t}\n};\nvar convertToAtLookup = function(ast){\n\tif(ast.type === \"Lookup\") {\n\t\tast.key = convertKeyToLookup(ast.key);\n\t}\n\treturn ast;\n};\n\nvar convertToHelperIfTopIsLookup = function(stack){\n\tvar top = stack.top();\n\t// if two scopes, that means a helper\n\tif(top && top.type === \"Lookup\") {\n\n\t\tvar base = stack.stack[stack.stack.length - 2];\n\t\t// That lookup shouldn't be part of a Helper already or\n\t\tif(base.type !== \"Helper\" && base) {\n\t\t\tstack.replaceTopAndPush({\n\t\t\t\ttype: \"Helper\",\n\t\t\t\tmethod: top\n\t\t\t});\n\t\t}\n\t}\n};\n\nvar expression = {\n\tconvertKeyToLookup: convertKeyToLookup,\n\tLiteral: Literal,\n\tLookup: Lookup,\n\tScopeLookup: ScopeLookup,\n\n\tArg: Arg,\n\tHash: Hash,\n\tHashes: Hashes,\n\tCall: Call,\n\tHelper: Helper,\n\tHelperLookup: HelperLookup,\n\tHelperScopeLookup: HelperScopeLookup,\n\tBracket: Bracket,\n\n\tSetIdentifier: function(value){ this.value = value; },\n\ttokenize: function(expression){\n\t\tvar tokens = [];\n\t\t(expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {\n\t\t\tif (bracketSpaceRegExp.test(arg)) {\n\t\t\t\ttokens.push(arg[0]);\n\t\t\t\ttokens.push(arg.slice(1));\n\t\t\t} else {\n\t\t\t\ttokens.push(arg);\n\t\t\t}\n\t\t});\n\t\treturn tokens;\n\t},\n\tlookupRules: {\n\t\t\"default\": function(ast, methodType, isArg){\n\t\t\tvar name = (methodType === \"Helper\" && !ast.root ? \"Helper\" : \"\")+(isArg ? \"Scope\" : \"\")+\"Lookup\";\n\t\t\treturn expression[name];\n\t\t},\n\t\t\"method\": function(ast, methodType, isArg){\n\t\t\treturn ScopeLookup;\n\t\t}\n\t},\n\tmethodRules: {\n\t\t\"default\": function(ast){\n\n\t\t\treturn ast.type === \"Call\" ? Call : Helper;\n\t\t},\n\t\t\"call\": function(ast){\n\t\t\treturn Call;\n\t\t}\n\t},\n\t// ## expression.parse\n\t//\n\t// - {String} expressionString - A stache expression like \"abc foo()\"\n\t// - {Object} options\n\t//   - baseMethodType - Treat this like a Helper or Call.  Default to \"Helper\"\n\t//   - lookupRule - \"default\" or \"method\"\n\t//   - methodRule - \"default\" or \"call\"\n\tparse: function(expressionString, options){\n\t\toptions =  options || {};\n\t\tvar ast = this.ast(expressionString);\n\n\t\tif(!options.lookupRule) {\n\t\t\toptions.lookupRule = \"default\";\n\t\t}\n\t\tif(typeof options.lookupRule === \"string\") {\n\t\t\toptions.lookupRule = expression.lookupRules[options.lookupRule];\n\t\t}\n\t\tif(!options.methodRule) {\n\t\t\toptions.methodRule = \"default\";\n\t\t}\n\t\tif(typeof options.methodRule === \"string\") {\n\t\t\toptions.methodRule = expression.methodRules[options.methodRule];\n\t\t}\n\n\t\tvar expr = this.hydrateAst(ast, options, options.baseMethodType || \"Helper\");\n\n\t\treturn expr;\n\t},\n\thydrateAst: function(ast, options, methodType, isArg){\n\t\tvar hashes;\n\t\tif(ast.type === \"Lookup\") {\n\t\t\treturn new (options.lookupRule(ast, methodType, isArg))(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType) );\n\t\t}\n\t\telse if(ast.type === \"Literal\") {\n\t\t\treturn new Literal(ast.value);\n\t\t}\n\t\telse if(ast.type === \"Arg\") {\n\t\t\treturn new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg),{compute: true});\n\t\t}\n\t\telse if(ast.type === \"Hash\") {\n\t\t\tthrow new Error(\"\");\n\t\t}\n\t\telse if(ast.type === \"Hashes\") {\n\t\t\thashes = {};\n\t\t\teach(ast.children, function(hash){\n\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, methodType, true );\n\t\t\t}, this);\n\t\t\treturn new Hashes(hashes);\n\t\t}\n\t\telse if(ast.type === \"Call\" || ast.type === \"Helper\") {\n\t\t\t//get all arguments and hashes\n\t\t\thashes = {};\n\t\t\tvar args = [],\n\t\t\t\tchildren = ast.children,\n\t\t\t\tExpressionType = options.methodRule(ast);\n\t\t\tif(children) {\n\t\t\t\tfor(var i = 0 ; i <children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tif(child.type === \"Hashes\" && ast.type === \"Helper\" &&\n\t\t\t\t\t\t(ExpressionType !== Call)) {\n\n\t\t\t\t\t\teach(child.children, function(hash){\n\t\t\t\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, ast.type, true );\n\t\t\t\t\t\t}, this);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push( this.hydrateAst(child, options, ast.type, true) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn new ExpressionType(this.hydrateAst(ast.method, options, ast.type),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\targs, hashes);\n\t\t} else if (ast.type === \"Bracket\") {\n\t\t\treturn new Bracket(\n\t\t\t\tthis.hydrateAst(ast.children[0], options),\n\t\t\t\tast.root ? this.hydrateAst(ast.root, options) : undefined\n\t\t\t);\n\t\t}\n\t},\n\tast: function(expression){\n\t\tvar tokens = this.tokenize(expression);\n\t\treturn this.parseAst(tokens, {\n\t\t\tindex: 0\n\t\t});\n\t},\n\tparseAst: function(tokens, cursor) {\n\t\tvar stack = new Stack(),\n\t\t\ttop,\n\t\t\tfirstParent,\n\t\t\tlastToken;\n\n\t\twhile(cursor.index < tokens.length) {\n\t\t\tvar token = tokens[cursor.index],\n\t\t\t\tnextToken = tokens[cursor.index+1];\n\n\t\t\tcursor.index++;\n\n\t\t\t// Literal\n\t\t\tif(literalRegExp.test( token )) {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t// only add to hash if there's not already a child.\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\t\t\t\tif(firstParent.type === \"Hash\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else if(firstParent.type === \"Bracket\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Hash\n\t\t\telse if(nextToken === \"=\") {\n\t\t\t\t//convertToHelperIfTopIsLookup(stack);\n\t\t\t\ttop = stack.top();\n\n\t\t\t\t// If top is a Lookup, we might need to convert to a helper.\n\t\t\t\tif(top && top.type === \"Lookup\") {\n\t\t\t\t\t// Check if current Lookup is part of a Call, Helper, or Hash\n\t\t\t\t\t// If it happens to be first within a Call or Root, that means\n\t\t\t\t\t// this is helper syntax.\n\t\t\t\t\tfirstParent = stack.firstParent([\"Call\",\"Helper\",\"Hash\"]);\n\t\t\t\t\tif(firstParent.type === \"Call\" || firstParent.type === \"Root\") {\n\n\t\t\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t\t\t\ttop = stack.top();\n\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\ttype: \"Helper\",\n\t\t\t\t\t\t\tmethod: top.type === \"Root\" ? last(top.children) : top\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfirstParent = stack.firstParent([\"Call\",\"Helper\",\"Hashes\"]);\n\t\t\t\t// makes sure we are adding to Hashes if there already is one\n\t\t\t\t// otherwise we create one.\n\t\t\t\tvar hash = {type: \"Hash\", prop: token};\n\t\t\t\tif(firstParent.type === \"Hashes\") {\n\t\t\t\t\tstack.addToAndPush([\"Hashes\"], hash);\n\t\t\t\t} else {\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\"], {\n\t\t\t\t\t\ttype: \"Hashes\",\n\t\t\t\t\t\tchildren: [hash]\n\t\t\t\t\t});\n\t\t\t\t\tstack.push(hash);\n\t\t\t\t}\n\t\t\t\tcursor.index++;\n\n\t\t\t}\n\t\t\t// Lookup\n\t\t\telse if(keyRegExp.test(token)) {\n\t\t\t\tlastToken = stack.topLastChild();\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\n\t\t\t\t// if we had `foo().bar`, we need to change to a Lookup that looks up from lastToken.\n\t\t\t\tif(lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\" ) && isAddingToExpression(token)) {\n\t\t\t\t\tstack.replaceTopLastChildAndPush({\n\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\troot: lastToken,\n\t\t\t\t\t\tkey: token.slice(1) // remove leading `.`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if(firstParent.type === 'Bracket') {\n\t\t\t\t\t// a Bracket expression without children means we have\n\t\t\t\t\t// parsed `foo[` of an expression like `foo[bar]`\n\t\t\t\t\t// so we know to add the Lookup as a child of the Bracket expression\n\t\t\t\t\tif (!(firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\t\tstack.addToAndPush([\"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// check if we are adding to a helper like `eq foo[bar] baz`\n\t\t\t\t\t\t// but not at the `.baz` of `eq foo[bar].baz xyz`\n\t\t\t\t\t\tif(stack.first([\"Helper\", \"Call\", \"Hash\", \"Arg\"]).type === 'Helper' && token[0] !== '.') {\n\t\t\t\t\t\t\tstack.addToAndPush([\"Helper\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// otherwise, handle the `.baz` in expressions like `foo[bar].baz`\n\t\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\t\t\tkey: token.slice(1),\n\t\t\t\t\t\t\t\troot: firstParent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// if two scopes, that means a helper\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\", \"Arg\", \"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Arg\n\t\t\telse if(token === \"~\") {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Arg\", key: token});\n\t\t\t}\n\t\t\t// Call\n\t\t\t// foo[bar()]\n\t\t\telse if(token === \"(\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tif(top.type === \"Lookup\") {\n\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\ttype: \"Call\",\n\t\t\t\t\t\tmethod: convertToAtLookup(top)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Unable to understand expression \"+tokens.join(''));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Call\n\t\t\telse if(token === \")\") {\n\t\t\t\tstack.popTo([\"Call\"]);\n\t\t\t}\n\t\t\t// End Call argument\n\t\t\telse if(token === \",\") {\n\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t}\n\t\t\t// Bracket\n\t\t\telse if(token === \"[\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tlastToken = stack.topLastChild();\n\n\t\t\t\tif (lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\"  )  ) {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\", root: lastToken});\n\t\t\t\t} else if (top.type === \"Lookup\" || top.type === \"Bracket\") {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\", root: top});\n\t\t\t\t} else if (top.type === \"Call\") {\n\t\t\t\t\tstack.addToAndPush([\"Call\"], { type: \"Bracket\" });\n\t\t\t\t} else if (top === \" \") {\n\t\t\t\t\tstack.popUntil([\"Lookup\"]);\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Bracket\"});\n\t\t\t\t} else {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\"});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Bracket\n\t\t\telse if(token === \"]\") {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\telse if(token === \" \") {\n\t\t\t\tstack.push(token);\n\t\t\t}\n\t\t}\n\t\treturn stack.root.children[0];\n\t}\n};\n\nmodule.exports = expression;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/src/expression.js\n// module id = 45\n// module chunks = 0","var mustacheCore = require('./mustache_core');\nvar parser = require('can-view-parser');\n// require('can/view/import/import');\n\nmodule.exports = function(source){\n\n\tvar template = mustacheCore.cleanLineEndings(source);\n\tvar imports = [],\n\t\tdynamicImports = [],\n\t\tases = {},\n\t\tinImport = false,\n\t\tinFrom = false,\n\t\tinAs = false,\n\t\tisUnary = false,\n\t\tcurrentAs = \"\",\n\t\tcurrentFrom = \"\";\n\n\tvar intermediate = parser(template, {\n\t\tstart: function( tagName, unary ){\n\t\t\tisUnary = unary;\n\t\t\tif(tagName === \"can-import\") {\n\t\t\t\tinImport = true;\n\t\t\t} else if(inImport) {\n\t\t\t\tinImport = false;\n\t\t\t}\n\t\t},\n\t\tattrStart: function( attrName ){\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = true;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = true;\n\t\t\t}\n\t\t},\n\t\tattrEnd: function( attrName ){\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = false;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = false;\n\t\t\t}\n\t\t},\n\t\tattrValue: function( value ){\n\t\t\tif(inFrom && inImport) {\n\t\t\t\timports.push(value);\n\t\t\t\tif(!isUnary) {\n\t\t\t\t\tdynamicImports.push(value);\n\t\t\t\t}\n\t\t\t\tcurrentFrom = value;\n\t\t\t} else if(inAs && inImport) {\n\t\t\t\tcurrentAs = value;\n\t\t\t}\n\t\t},\n\t\tend: function(tagName){\n\t\t\tif(tagName === \"can-import\") {\n\t\t\t\t// Set the as value to the from\n\t\t\t\tif(currentAs) {\n\t\t\t\t\tases[currentAs] = currentFrom;\n\t\t\t\t\tcurrentAs = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tclose: function(tagName){\n\t\t\tif(tagName === \"can-import\") {\n\t\t\t\timports.pop();\n\t\t\t}\n\t\t}\n\t}, true);\n\n\treturn {\n\t\tintermediate: intermediate,\n\t\timports: imports,\n\t\tdynamicImports: dynamicImports,\n\t\tases: ases,\n\t\texports: ases\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/src/intermediate_and_imports.js\n// module id = 46\n// module chunks = 0","'use strict';\n\nvar isEmptyObject = require(\"../../js/is-empty-object/is-empty-object\");\n\nvar data = {};\nvar expando = \"can\" + new Date();\nvar uuid = 0;\n\n// set data for an element\n// returns true if this is the first data for this element\n// so that caller can track number of elements with data set\nvar setData = function(name, value) {\n\tvar id = this[expando] || (this[expando] = ++uuid),\n\t\tstore = data[id],\n\t\tnewStore = false;\n\n\tif (!data[id]) {\n\t\tnewStore = true;\n\t\tstore = data[id] = {};\n\t}\n\n\tif (name !== undefined) {\n\t\tstore[name] = value;\n\t}\n\treturn newStore;\n};\n\n// delete this node's `data`\n// returns true if the node was deleted.\nvar deleteNode = function() {\n\tvar id = this[expando];\n\tvar nodeDeleted = false;\n\tif(id && data[id]) {\n\t\tnodeDeleted = true;\n\t\tdelete data[id];\n\t}\n\treturn nodeDeleted;\n};\n\n/*\n * Core of domData that does not depend on mutationDocument\n * This is separated in order to prevent circular dependencies\n */\nmodule.exports = {\n\t_data: data,\n\n\tgetCid: function() {\n\t\treturn this[expando];\n\t},\n\n\tcid: function(){\n\t\treturn this[expando] || (this[expando] = ++uuid);\n\t},\n\n\texpando: expando,\n\n\tget: function(key) {\n\t\tvar id = this[expando],\n\t\t\tstore = id && data[id];\n\t\treturn key === undefined ? store || setData(this) : store && store[key];\n\t},\n\n\tset: setData,\n\n\tclean: function(prop) {\n\t\tvar id = this[expando];\n\t\tvar itemData = data[id];\n\t\tif (itemData && itemData[prop]) {\n\t\t\tdelete itemData[prop];\n\t\t}\n\t\tif(isEmptyObject(itemData)) {\n\t\t\tdeleteNode.call(this);\n\t\t}\n\t},\n\n\tdelete: deleteNode\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/data/core.js\n// module id = 47\n// module chunks = 0","'use strict';\n\nvar makeMutationEvent = require(\"../make-mutation-event/make-mutation-event\");\n\n/**\n * @module {events} can-util/dom/events/removed/removed removed\n * @parent can-util/dom/events/events\n *  \n * This event fires when the bound element is detached or destroyed.\n *\n * ```js\n * var events = require(\"can-util/dom/events/events\");\n * require(\"can-util/dom/events/removed/removed\");\n *\n * var foo = document.createElement(\"div\");\n * document.body.appendChild(foo);\n *\n * var log = function() { console.log(\"removed event fired\"); }\n * events.addEventListener.call(foo, \"removed\", log);\n *\n * document.body.removeChild(foo); // remove event fired\n */\nmakeMutationEvent(\"removed\", \"removedNodes\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/removed/removed.js\n// module id = 48\n// module chunks = 0","'use strict';\n\nvar getDocument = require('../document/document');\nmodule.exports = function(el) {\n\treturn (el.ownerDocument || el) === getDocument();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/is-of-global-document/is-of-global-document.js\n// module id = 49\n// module chunks = 0","'use strict';\n\nvar GLOBAL = require(\"../global/global\");\nvar each = require(\"../each/each\");\nvar getCID = require(\"../cid/get-cid\");\n\nvar CIDMap;\n\nif(GLOBAL().Map) {\n\tCIDMap = GLOBAL().Map;\n} else {\n\tvar CIDMap = function(){\n\t\tthis.values = {};\n\t};\n\tCIDMap.prototype.set = function(key, value){\n\t\tthis.values[getCID(key)] = {key: key, value: value};\n\t};\n\tCIDMap.prototype[\"delete\"] = function(key){\n\t\tvar has = getCID(key) in this.values;\n\t\tif(has) {\n\t\t\tdelete this.values[getCID(key)];\n\t\t}\n\t\treturn has;\n\t};\n\tCIDMap.prototype.forEach = function(cb, thisArg) {\n\t\teach(this.values, function(pair){\n\t\t\treturn cb.call(thisArg || this, pair.value, pair.key, this);\n\t\t}, this);\n\t};\n\tCIDMap.prototype.has = function(key) {\n\t\treturn getCID(key) in this.values;\n\t};\n\tCIDMap.prototype.get = function(key) {\n\t\tvar obj = this.values[getCID(key)];\n\t\treturn obj && obj.value;\n\t};\n\tCIDMap.prototype.clear = function(key) {\n\t\treturn this.values = {};\n\t};\n\tObject.defineProperty(CIDMap.prototype,\"size\",{\n\t\tget: function(){\n\t\t\tvar size = 0;\n\t\t\teach(this.values, function(){\n\t\t\t\tsize++;\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\t});\n}\n\nmodule.exports = CIDMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/cid-map/cid-map.js\n// module id = 50\n// module chunks = 0","'use strict';\n\nvar slice = [].slice;\n// a b c\n// a b c d\n// [[2,0, d]]\n\nvar defaultIdentity = function(a, b){ return a === b; };\n\n/**\n * @module {function} can-util/js/diff/diff diff\n * @parent can-util/js\n * @signature `diff( oldList, newList, [identity] )`\n * \n * @param  {ArrayLike} oldList the array to diff from\n * @param  {ArrayLike} newList the array to diff to\n * @param  {function} identity an optional identity function for comparing elements\n * @return {Array}     a list of Patch objects representing the differences\n *\n * Returns the difference between two ArrayLike objects (that have nonnegative\n * integer keys and the `length` property) as an array of patch objects.\n * \n * A patch object returned by this function has the following properties:\n * - **index**:  the index of newList where the patch begins\n * - **deleteCount**: the number of items deleted from that index in newList\n * - **insert**: an Array of items newly inserted at that index in newList\n *\n * ```js\n * var diff = require(\"can-util/js/diff/diff\");\n *\n * console.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\n * console.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n * \n * // with an optional identity function:\n * diff(\n *     [{id:1},{id:2}],\n *     [{id:1},{id:3}],\n *     (a,b) => a.id === b.id\n * ); // -> [{index: 1, deleteCount: 1, insert: [{id:3}]}]\n * ```\n */\n\n// TODO: update for a better type reference. E.g.:\n//    @typdef {function(*,*)} can-util/diff/diff/typedefs.identity identify(a, b)\n//\n//    @param {*} a This is something.\n//    @param {can-util/diff/diff/typedefs.identity} identity(a, b)\n//    @option {*} a\n\nmodule.exports = exports = function(oldList, newList, identity){\n\tidentity = identity || defaultIdentity;\n\t\n\tvar oldIndex = 0,\n\t\tnewIndex =  0,\n\t\toldLength = oldList.length,\n\t\tnewLength = newList.length,\n\t\tpatches = [];\n\n\twhile(oldIndex < oldLength && newIndex < newLength) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem ) ) {\n\t\t\toldIndex++;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single insert, does the next newList item equal the current oldList.\n\t\t// 1 2 3\n\t\t// 1 2 4 3\n\t\tif(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1] ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ]});\n\t\t\toldIndex++;\n\t\t\tnewIndex += 2;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single removal, does the next item in the oldList equal the current newList item.\n\t\t// 1 2 3\n\t\t// 1 3\n\t\telse if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 1, insert: []});\n\t\t\toldIndex += 2;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// just clean up the rest and exit\n\t\t// 1 2 3\n\t\t// 1 2 5 6 7\n\t\telse {\n\t\t\tpatches.push(\n\t\t\t\t{index: newIndex,\n\t\t\t\t deleteCount: oldLength-oldIndex,\n\t\t\t\t insert: slice.call(newList, newIndex) } );\n\t\t\treturn patches;\n\t\t}\n\t}\n\tif( (newIndex === newLength) && (oldIndex === oldLength) ) {\n\t\treturn patches;\n\t}\n\t// a b\n\t// a b c d e\n\tpatches.push(\n\t\t\t\t{index: newIndex,\n\t\t\t\t deleteCount: oldLength-oldIndex,\n\t\t\t\t insert: slice.call(newList, newIndex) } );\n\n\treturn patches;\n};\n\n// a b c\n// a d e b c\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/diff/diff.js\n// module id = 51\n// module chunks = 0","'use strict';\n\nvar isContainer = require('../is-container/is-container');\n\n/**\n * @module {function} can-util/js/get/get get\n * @parent can-util/js\n *\n * @signature `get(obj, path)`\n * @param  {Object} obj the object to use as the root for property based navigation\n * @param  {String} path a String of dot-separated keys, representing a path of properties\n * @return {*}       the value at the property path\n *\n * A *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n * 'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n *\n * ```js\n * var get = require(\"can-util/js/get/get\");\n * console.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\n * console.log(get({a: {}}, \"a.b.c\")); // -> undefined\n * console.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n * ```\n */\nfunction get(obj, name) {\n    // The parts of the name we are looking up\n    // `['App','Models','Recipe']`\n    var parts = typeof name !== 'undefined' ? (name + '').replace(/\\[/g,'.')\n    \t\t.replace(/]/g,'').split('.') : [],\n        length = parts.length,\n        current, i, container;\n\n    if (!length) {\n        return obj;\n    }\n\n    current = obj;\n\n    // Walk current to the 2nd to last object or until there\n    // is not a container.\n    for (i = 0; i < length && isContainer(current); i++) {\n        container = current;\n        current = container[parts[i]];\n    }\n\n    return current;\n}\n\nmodule.exports = get;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/get/get.js\n// module id = 52\n// module chunks = 0","'use strict';\n\nvar global = require(\"../global/global\")();\n\n/**\n * @module can-util/js/set-immediate/set-immediate set-immediate\n * @parent can-util/js\n * @signature `setImmediate(function())`\n * @param  {Function} cb\n *\n * Polyfill for setImmediate() if it doesn't exist in the global context\n */\nmodule.exports = global.setImmediate || function (cb) {\n\treturn setTimeout(cb, 0);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/set-immediate/set-immediate.js\n// module id = 53\n// module chunks = 0","/* jshint maxdepth:7,node:true, latedef:false */\nvar namespace = require('can-namespace'),\n\tdev = require('can-util/js/dev/dev');\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\nfunction handleIntermediate(intermediate, handler){\n\tfor(var i = 0, len = intermediate.length; i < len; i++) {\n\t\tvar item = intermediate[i];\n\t\thandler[item.tokenType].apply(handler, item.args);\n\t}\n\treturn intermediate;\n}\n\nvar alphaNumeric = \"A-Za-z0-9\",\n\talphaNumericHU = \"-:_\"+alphaNumeric,\n\tcamelCase = /([a-z])([A-Z])/g,\n\tdefaultMagicStart = \"{{\",\n\tendTag = new RegExp(\"^<\\\\/([\"+alphaNumericHU+\"]+)[^>]*>\"),\n\tdefaultMagicMatch = new RegExp(\"\\\\{\\\\{(![\\\\s\\\\S]*?!|[\\\\s\\\\S]*?)\\\\}\\\\}\\\\}?\",\"g\"),\n\tspace = /\\s/,\n\tspacesRegex = /\\s/g,\n\talphaRegex = new RegExp('['+ alphaNumeric + ']'),\n\tforwardSlashRegex = /\\//g;\n\n// Empty Elements - HTML 5\nvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\");\n\n// Attributes for which the case matters - shouldn’t be lowercased.\nvar caseMattersAttributes = makeMap(\"allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector\");\n\n// Elements for which tag case matters - shouldn't be lowercased.\nvar caseMattersElements = makeMap(\"altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath\");\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\");\n\n// Special Elements (can contain anything)\nvar special = makeMap(\"script\");\n\n// Callback names on `handler`.\nvar tokenTypes = \"start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done\".split(\",\");\n\n//maps end characters to start characters\nvar startOppositesMap = {\"{\": \"}\", \"(\":\")\"};\n\nvar fn = function(){};\n\nvar HTMLParser = function (html, handler, returnIntermediate) {\n\tif(typeof html === \"object\") {\n\t\treturn handleIntermediate(html, handler);\n\t}\n\tvar intermediate = [];\n\thandler = handler || {};\n\tif(returnIntermediate) {\n\t\t// overwrite handlers so they add to intermediate\n\t\teach(tokenTypes, function(name){\n\t\t\tvar callback = handler[name] || fn;\n\t\t\thandler[name] = function(){\n\t\t\t\tif( callback.apply(this, arguments) !== false ) {\n\t\t\t\t\tintermediate.push({tokenType: name, args: [].slice.call(arguments, 0) });\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\tvar magicMatch = handler.magicMatch || defaultMagicMatch,\n\t\tmagicStart = handler.magicStart || defaultMagicStart;\n\n\tfunction parseStartTag(tag, tagName, rest, unary) {\n\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\n\t\tif (closeSelf[tagName] && stack.last() === tagName) {\n\t\t\tparseEndTag(\"\", tagName);\n\t\t}\n\n\t\tunary = empty[tagName] || !!unary;\n\n\t\thandler.start(tagName, unary);\n\n\t\tif (!unary) {\n\t\t\tstack.push(tagName);\n\t\t}\n\t\t// find attribute or special\n\t\tHTMLParser.parseAttrs(rest, handler);\n\n\n\t\thandler.end(tagName,unary);\n\n\t}\n\n\tfunction parseEndTag(tag, tagName) {\n\t\t// If no tag name is provided, clean shop\n\t\tvar pos;\n\t\tif (!tagName) {\n\t\t\tpos = 0;\n\t\t}\n\t\t// Find the closest opened tag of the same type\n\t\telse {\n\t\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\tif (stack[pos] === tagName) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (typeof tag === 'undefined') {\n\t\t\tif (stack.length > 0) {\n\t\t\t\tdev.warn(\"expected closing tag </\" + stack[pos] + \">\");\n\t\t\t}\n\t\t} else if (pos < 0 || pos !== stack.length - 1) {\n\t\t\tif (stack.length > 0) {\n\t\t\t\tdev.warn(\"unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t} else {\n\t\t\t\tdev.warn(\"unexpected closing tag \" + tag);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (pos >= 0) {\n\t\t\t// Close all the open elements, up the stack\n\t\t\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\t\t\tif (handler.close) {\n\t\t\t\t\thandler.close(stack[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the open elements from the stack\n\t\t\tstack.length = pos;\n\t\t}\n\t}\n\n\tfunction parseMustache(mustache, inside){\n\t\tif(handler.special){\n\t\t\thandler.special(inside);\n\t\t}\n\t}\n\tvar callChars = function(){\n\t\tif(charsText) {\n\t\t\tif(handler.chars) {\n\t\t\t\thandler.chars(charsText);\n\t\t\t}\n\t\t}\n\t\tcharsText = \"\";\n\t};\n\n\tvar index,\n\t\tchars,\n\t\tmatch,\n\t\tstack = [],\n\t\tlast = html,\n\t\t// an accumulating text for the next .chars callback\n\t\tcharsText = \"\";\n\tstack.last = function () {\n\t\treturn this[this.length - 1];\n\t};\n\n\twhile (html) {\n\n\t\tchars = true;\n\n\t\t// Make sure we're not in a script or style element\n\t\tif (!stack.last() || !special[stack.last()]) {\n\n\t\t\t// Comment\n\t\t\tif (html.indexOf(\"<!--\") === 0) {\n\t\t\t\tindex = html.indexOf(\"-->\");\n\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tif (handler.comment) {\n\t\t\t\t\t\thandler.comment(html.substring(4, index));\n\t\t\t\t\t}\n\t\t\t\t\thtml = html.substring(index + 3);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t} else if (html.indexOf(\"</\") === 0) {\n\t\t\t\tmatch = html.match(endTag);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t\tmatch[0].replace(endTag, parseEndTag);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// start tag\n\t\t\t} else if (html.indexOf(\"<\") === 0) {\n\t\t\t\tvar res = HTMLParser.searchStartTag(html);\n\n\t\t\t\tif(res) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\thtml = res.html;\n\t\t\t\t\tparseStartTag.apply(null, res.match);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t} else if (html.indexOf(magicStart) === 0 ) {\n\t\t\t\tmatch = html.match(magicMatch);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t\tmatch[0].replace(magicMatch, parseMustache);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chars) {\n\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\tif(index === 0 && html === last) {\n\t\t\t\t\tcharsText += html.charAt(0);\n\t\t\t\t\thtml = html.substr(1);\n\t\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\t}\n\n\t\t\t\tvar text = index < 0 ? html : html.substring(0, index);\n\t\t\t\thtml = index < 0 ? \"\" : html.substring(index);\n\n\t\t\t\tif (text) {\n\t\t\t\t\tcharsText += text;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\t\t\thtml = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\n\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\n\t\t\t\tif (handler.chars) {\n\t\t\t\t\thandler.chars(text);\n\t\t\t\t}\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\tparseEndTag(\"\", stack.last());\n\t\t}\n\n\t\tif (html === last) {\n\t\t\tthrow new Error(\"Parse Error: \" + html);\n\t\t}\n\n\t\tlast = html;\n\t}\n\tcallChars();\n\t// Clean up any remaining tags\n\tparseEndTag();\n\n\n\thandler.done();\n\treturn intermediate;\n};\n\nvar callAttrStart = function(state, curIndex, handler, rest){\n\tvar attrName = rest.substring(typeof state.nameStart === \"number\" ? state.nameStart : curIndex, curIndex),\n\t\tnewAttrName = attrName,\n\t\toldAttrName = attrName;\n\tif (!caseMattersAttributes[attrName] && camelCase.test(attrName)) {\n\t\tnewAttrName = attrName.replace(camelCase, camelCaseToSpinalCase);\n\t\t//!steal-remove-start\n\t\tdev.warn(\"can-view-parser: Found attribute with name: \", oldAttrName, \". Converting to: \", newAttrName);\n\t\t//!steal-remove-end\n\t}\n\n\t//encode spaces\n\tnewAttrName = newAttrName.replace(spacesRegex, \"\\\\s\");\n\n\t//encode forward slashes\n\tnewAttrName = newAttrName.replace(forwardSlashRegex, \"\\\\f\");\n\n\tstate.attrStart = newAttrName;\n\thandler.attrStart(state.attrStart);\n\tstate.inName = false;\n};\n\nvar callAttrEnd = function(state, curIndex, handler, rest){\n\tif(state.valueStart !== undefined && state.valueStart < curIndex) {\n\t\thandler.attrValue(rest.substring(state.valueStart, curIndex));\n\t}\n\t// if this never got to be inValue, like `DISABLED` then send a attrValue\n\telse if(!state.inValue){\n\t\t//handler.attrValue(state.attrStart);\n\t}\n\thandler.attrEnd(state.attrStart);\n\tstate.attrStart = undefined;\n\tstate.valueStart = undefined;\n\tstate.inValue = false;\n\tstate.inName = false;\n\tstate.lookingForEq = false;\n\tstate.inQuote = false;\n\tstate.lookingForName = true;\n};\n\nvar findBreak = function(str, magicStart) {\n\tvar magicLength = magicStart.length;\n\tfor(var i = 0, len = str.length; i < len; i++) {\n\t\tif(str[i] === \"<\" || str.substr(i, magicLength) === magicStart) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nvar camelCaseToSpinalCase = function (match, lowerCaseChar, upperCaseChar) {\n\treturn lowerCaseChar + \"-\" + upperCaseChar.toLowerCase();\n};\n\nHTMLParser.parseAttrs = function(rest, handler){\n\tif(!rest) {\n\t\treturn;\n\t}\n\n\tvar magicMatch = handler.magicMatch || defaultMagicMatch,\n\t\tmagicStart = handler.magicStart || defaultMagicStart;\n  \n\tvar i = 0;\n\tvar curIndex;\n\tvar state = {\n\t\tinName: false,\n\t\tnameStart: undefined,\n\t\tinValue: false,\n\t\tvalueStart: undefined,\n\t\tinQuote: false,\n\t\tattrStart: undefined,\n\t\tlookingForName: true,\n\t\tlookingForValue: false,\n\t\tlookingForEq : false\n\t};\n\n\twhile(i < rest.length) {\n\t\tcurIndex = i;\n\t\tvar cur = rest.charAt(i);\n\t\ti++;\n\n\t\tif(magicStart === rest.substr(curIndex, magicStart.length) ) {\n\t\t\tif(state.inValue && curIndex > state.valueStart) {\n\t\t\t\thandler.attrValue(rest.substring(state.valueStart, curIndex));\n\t\t\t}\n\t\t\t// `{{#foo}}DISABLED{{/foo}}`\n\t\t\telse if(state.inName && state.nameStart < curIndex) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest);\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest);\n\t\t\t}\n\t\t\t// foo={{bar}}\n\t\t\telse if(state.lookingForValue){\n\t\t\t\tstate.inValue = true;\n\t\t\t}\n\t\t\t// a {{bar}}\n\t\t\telse if(state.lookingForEq && state.attrStart) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest);\n\t\t\t}\n\t\t\tmagicMatch.lastIndex = curIndex;\n\t\t\tvar match = magicMatch.exec(rest);\n\t\t\tif(match) {\n\t\t\t\thandler.special(match[1]);\n\t\t\t\t// i is already incremented\n\t\t\t\ti = curIndex + (match[0].length);\n\t\t\t\tif(state.inValue) {\n\t\t\t\t\tstate.valueStart = curIndex+match[0].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(state.inValue) {\n\t\t\tif(state.inQuote) {\n\t\t\t\tif(cur === state.inQuote) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(space.test(cur)) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest);\n\t\t\t}\n\t\t}\n\t\t// if we hit an = outside a value\n\t\telse if(cur === \"=\" && (state.lookingForEq || state.lookingForName || state.inName)) {\n\n\t\t\t// if we haven't yet started this attribute `{{}}=foo` case:\n\t\t\tif(!state.attrStart) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest);\n\t\t\t}\n\t\t\tstate.lookingForValue = true;\n\t\t\tstate.lookingForEq = false;\n\t\t\tstate.lookingForName = false;\n\t\t}\n\t\t\n\t\t// if we are currently in a name:\n\t\t//  when the name starts with `{` or `(`\n\t\t//  it isn't finished until the matching end character is found\n\t\t//  otherwise, a space finishes the name\n\t\telse if(state.inName) {\n\t\t\tvar started = rest[ state.nameStart ],\n\t\t\t\t\totherStart, otherOpposite;\n\t\t\tif(startOppositesMap[started] === cur) {\n\t\t\t\t//handle mismatched brackets: `{(})` or `({)}`\n\t\t\t\totherStart = started === \"{\" ? \"(\" : \"{\";\n\t\t\t\totherOpposite = startOppositesMap[otherStart];\n\t\t\t\t\n\t\t\t\tif(rest[curIndex+1] === otherOpposite){\n\t\t\t\t\tcallAttrStart(state, curIndex+2, handler, rest);\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tcallAttrStart(state, curIndex+1, handler, rest);\n\t\t\t\t}\n\n\t\t\t\tstate.lookingForEq = true;\n\t\t\t} \n\t\t\telse if(space.test(cur) && started !== \"{\" && started !== \"(\") {\n\t\t\t\t\tcallAttrStart(state, curIndex, handler, rest);\n\t\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForName) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\t// might have just started a name, we need to close it\n\t\t\t\tif(state.attrStart) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest);\n\t\t\t\t}\n\t\t\t\tstate.nameStart = curIndex;\n\t\t\t\tstate.inName = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForValue) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\tstate.lookingForValue = false;\n\t\t\t\tstate.inValue = true;\n\t\t\t\tif(cur === \"'\" || cur === '\"') {\n\t\t\t\t\tstate.inQuote = cur;\n\t\t\t\t\tstate.valueStart = curIndex+1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.valueStart = curIndex;\n\t\t\t\t}\n\t\t\t\t// if we are looking for a value\n\t\t\t\t// at the end of the loop we need callAttrEnd\n\t\t\t} else if (i === rest.length){\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(state.inName) {\n\t\tcallAttrStart(state, curIndex+1, handler, rest);\n\t\tcallAttrEnd(state, curIndex+1, handler, rest);\n\t} else if(state.lookingForEq || state.lookingForValue || state.inValue) {\n\t\tcallAttrEnd(state, curIndex+1, handler, rest);\n\t}\n\tmagicMatch.lastIndex = 0;\n};\n\nHTMLParser.searchStartTag = function (html) {\n\tvar closingIndex = html.indexOf('>');\n\t// if there is no closing bracket\n\t// <input class=\n\t// or if the tagName does not start with alphaNumer character\n\t// <_iaois>\n\t// it is not a startTag\n\tif(closingIndex === -1 || !(alphaRegex.test(html[1]))){\n\t\treturn null;\n\t}\n\n\tvar tagName, tagContent, match, rest = '', unary = '';\n\tvar startTag = html.substring(0, closingIndex + 1);\n\tvar isUnary = startTag[startTag.length-2] === '/';\n\tvar spaceIndex = startTag.search(space);\n\n\tif(isUnary){\n\t\tunary = '/';\n\t\ttagContent = startTag.substring(1, startTag.length-2).trim();\n\t} else {\n\t\ttagContent = startTag.substring(1, startTag.length-1).trim();\n\t}\n\n\tif(spaceIndex === -1){\n\t\ttagName = tagContent;\n\t} else {\n\t\t//spaceIndex needs to shift one to the left\n\t\tspaceIndex--;\n\t\ttagName = tagContent.substring(0, spaceIndex);\n\t\trest = tagContent.substring(spaceIndex);\n\t}\n\n\tmatch = [startTag, tagName, rest, unary];\n\n\treturn {\n\t\tmatch: match,\n\t\thtml: html.substring(startTag.length)\n\t};\n\n\n};\n\nmodule.exports = namespace.HTMLParser = HTMLParser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-parser/can-view-parser.js\n// module id = 54\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 55\n// module chunks = 0","\r\nvar assign = require(\"can-util/js/assign/assign\");\r\nvar CID = require(\"can-cid\");\r\nvar define = require(\"can-define\");\r\nvar canBatch = require(\"can-event/batch/batch\");\r\nvar canEvent = require(\"can-event\");\r\n\r\n\r\nvar hasMethod = function(obj, method){\r\n\treturn obj && typeof obj === \"object\" && (method in obj);\r\n};\r\n\r\nvar defineHelpers = {\r\n\textendedSetup: function(props){\r\n\t\tassign(this, props);\r\n\t},\r\n\ttoObject: function(map, props, where, Type){\r\n\t\tif(props instanceof Type) {\r\n\t\t\tprops.each(function(value, prop){\r\n\t\t\t\twhere[prop] = value;\r\n\t\t\t});\r\n\t\t\treturn where;\r\n\t\t} else {\r\n\t\t\treturn props;\r\n\t\t}\r\n\t},\r\n\tremoveSpecialKeys: function(map) {\r\n\t\tif(map) {\r\n\t\t\t[\"_data\", \"constructor\", \"_cid\", \"__bindEvents\"].forEach(function(key) {\r\n\t\t\t\tdelete map[key];\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn map;\r\n\t},\r\n\tdefineExpando: function(map, prop, value) {\r\n\t\t// first check if it's already a constructor define\r\n\t\tvar constructorDefines = map._define.definitions;\r\n\t\tif(constructorDefines && constructorDefines[prop]) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// next if it's already on this instances\r\n\t\tvar instanceDefines = map._instanceDefinitions;\r\n\t\tif(!instanceDefines) {\r\n\t\t\tinstanceDefines = map._instanceDefinitions = {};\r\n\t\t}\r\n\t\tif(!instanceDefines[prop]) {\r\n\t\t\tvar defaultDefinition = map._define.defaultDefinition || {type: define.types.observable};\r\n\t\t\tdefine.property(map, prop, defaultDefinition, {},{});\r\n\t\t\t// possibly convert value to List or DefineMap\r\n\t\t\tmap._data[prop] = defaultDefinition.type ? defaultDefinition.type(value) : define.types.observable(value);\r\n\t\t\tinstanceDefines[prop] = defaultDefinition;\r\n\t\t\tcanBatch.start();\r\n\t\t\tcanEvent.dispatch.call(map, {\r\n\t\t\t\ttype: \"__keys\",\r\n\t\t\t\ttarget: map\r\n\t\t\t});\r\n\t\t\tif(map._data[prop] !== undefined) {\r\n\t\t\t\tcanEvent.dispatch.call(map, {\r\n\t\t\t\t\ttype: prop,\r\n\t\t\t\t\ttarget: map\r\n\t\t\t\t},[map._data[prop], undefined]);\r\n\t\t\t}\r\n\t\t\tcanBatch.stop();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\t// ## getValue\r\n\t// If `val` is an observable, calls `how` on it; otherwise\r\n\t// returns the value of `val`.\r\n\tgetValue: function(map, name, val, how){\r\n\t\t// check if there's a serialize\r\n\t\tif(how === \"serialize\") {\r\n\t\t\tvar constructorDefinitions = map._define.definitions;\r\n\t\t\tvar propDef = constructorDefinitions[name];\r\n\t\t\tif(propDef && typeof propDef.serialize === \"function\") {\r\n\t\t\t\treturn propDef.serialize.call(map, val, name);\r\n\t\t\t}\r\n\t\t\tvar defaultDefinition = map._define.defaultDefinition;\r\n\t\t\tif(defaultDefinition && typeof defaultDefinition.serialize === \"function\") {\r\n\t\t\t\treturn defaultDefinition.serialize.call(map, val, name);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif( hasMethod(val, how) ) {\r\n\t\t\treturn val[how]();\r\n\t\t} else {\r\n\t\t\treturn val;\r\n\t\t}\r\n\t},\r\n\t// ### mapHelpers.serialize\r\n\t// Serializes a Map or Map.List by recursively calling the `how`\r\n\t// method on any child objects. This is able to handle\r\n\t// cycles.\r\n\t// `map` - the map or list to serialize.\r\n\t// `how` - the method to call recursively.\r\n\t// `where` - the target Object or Array that becomes the serialized result.\r\n\tserialize: (function(){\r\n\r\n\t\t// A temporary mapping of map cids to the serialized result.\r\n\t\tvar serializeMap = null;\r\n\r\n\t\treturn function (map, how, where) {\r\n\t\t\tvar cid = CID(map),\r\n\t\t\t\tfirstSerialize = false;\r\n\r\n\t\t\t// If there isn't an existing serializeMap, this means\r\n\t\t\t// this is the initial non-recursive call to this function.\r\n\t\t\t// We mark this  as the first call, and then setup the serializeMap.\r\n\t\t\t// The serialize map is further devided into `how` because\r\n\t\t\t// `.serialize` might call `.attr`.\r\n\t\t\tif(!serializeMap) {\r\n\t\t\t\tfirstSerialize = true;\r\n\t\t\t\tserializeMap = {\r\n\t\t\t\t\tget: {},\r\n\t\t\t\t\tserialize: {}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tserializeMap[how][cid] = where;\r\n\t\t\t// Go through each property.\r\n\t\t\tmap.each(function (val, name) {\r\n\t\t\t\t// If the value is an `object`, and has an `attr` or `serialize` function.\r\n\r\n\t\t\t\tvar result,\r\n\t\t\t\t\tisObservable =   hasMethod(val, how),\r\n\t\t\t\t\tserialized = isObservable && serializeMap[how][CID(val)];\r\n\r\n\t\t\t\tif( serialized ) {\r\n\t\t\t\t\tresult = serialized;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// special attr or serializer\r\n\t\t\t\t\tresult = defineHelpers.getValue(map, name, val, how);\r\n\t\t\t\t}\r\n\t\t\t\t// this is probably removable\r\n\t\t\t\tif(result !== undefined) {\r\n\t\t\t\t\twhere[name] = result;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t});\r\n\r\n\t\t\tif(firstSerialize) {\r\n\t\t\t\tserializeMap = null;\r\n\t\t\t}\r\n\t\t\treturn where;\r\n\t\t};\r\n\t})()\r\n};\r\nmodule.exports = defineHelpers;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-define/define-helpers/define-helpers.js\n// module id = 56\n// module chunks = 0","var Construct = require(\"can-construct\");\r\nvar define = require(\"can-define\");\r\nvar make = define.make;\r\nvar canEvent = require(\"can-event\");\r\nvar canBatch = require(\"can-event/batch/batch\");\r\nvar Observation = require(\"can-observation\");\r\nvar canLog = require(\"can-util/js/log/log\");\r\n\r\nvar defineHelpers = require(\"../define-helpers/define-helpers\");\r\n\r\nvar assign = require(\"can-util/js/assign/assign\");\r\nvar diff = require(\"can-util/js/diff/diff\");\r\nvar each = require(\"can-util/js/each/each\");\r\nvar isArray = require(\"can-util/js/is-array/is-array\");\r\nvar makeArray = require(\"can-util/js/make-array/make-array\");\r\nvar types = require(\"can-types\");\r\nvar ns = require(\"can-namespace\");\r\n\r\nvar splice = [].splice;\r\nvar runningNative = false;\r\n\r\nvar identity = function(x) {\r\n\treturn x;\r\n};\r\n\r\nvar makeFilterCallback = function(props) {\r\n\treturn function(item) {\r\n\t\tfor (var prop in props) {\r\n\t\t\tif (item[prop] !== props[prop]) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n};\r\n/** @add can-define/list/list */\r\nvar DefineList = Construct.extend(\"DefineList\",\r\n\t/** @static */\r\n\t{\r\n\t\tsetup: function(base) {\r\n\t\t\tif (DefineList) {\r\n\r\n\t\t\t\tvar prototype = this.prototype;\r\n\t\t\t\tvar result = define(prototype, prototype, base.prototype._define);\r\n\t\t\t\tvar itemsDefinition = result.definitions[\"#\"] || result.defaultDefinition;\r\n\r\n\t\t\t\tif (itemsDefinition) {\r\n\t\t\t\t\tif (itemsDefinition.Type) {\r\n\t\t\t\t\t\tthis.prototype.__type = make.set.Type(\"*\", itemsDefinition.Type, identity);\r\n\t\t\t\t\t} else if (itemsDefinition.type) {\r\n\t\t\t\t\t\tthis.prototype.__type = make.set.type(\"*\", itemsDefinition.type, identity);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t/** @prototype */\r\n\t{\r\n\t\t// setup for only dynamic DefineMap instances\r\n\t\tsetup: function(items) {\r\n\t\t\tif (!this._define) {\r\n\t\t\t\tObject.defineProperty(this, \"_define\", {\r\n\t\t\t\t\tenumerable: false,\r\n\t\t\t\t\tvalue: {\r\n\t\t\t\t\t\tdefinitions: {}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tObject.defineProperty(this, \"_data\", {\r\n\t\t\t\t\tenumerable: false,\r\n\t\t\t\t\tvalue: {}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tdefine.setup.call(this, {}, false);\r\n\t\t\tthis._length = 0;\r\n\t\t\tif (items) {\r\n\t\t\t\tthis.splice.apply(this, [ 0, 0 ].concat(defineHelpers.toObject(this, items, [], DefineList)));\r\n\t\t\t}\r\n\t\t},\r\n\t\t__type: define.types.observable,\r\n\t\t_triggerChange: function(attr, how, newVal, oldVal) {\r\n\r\n\t\t\tvar index = +attr;\r\n\t\t\t// `batchTrigger` direct add and remove events...\r\n\r\n\t\t\t// Make sure this is not nested and not an expando\r\n\t\t\tif (!~(\"\" + attr).indexOf('.') && !isNaN(index)) {\r\n\t\t\t\tvar itemsDefinition = this._define.definitions[\"#\"];\r\n\r\n\t\t\t\tif (how === 'add') {\r\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.added === 'function') {\r\n\t\t\t\t\t\tObservation.ignore(itemsDefinition.added).call(this, newVal, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcanEvent.dispatch.call(this, how, [ newVal, index ]);\r\n\t\t\t\t} else if (how === 'remove') {\r\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.removed === 'function') {\r\n\t\t\t\t\t\tObservation.ignore(itemsDefinition.removed).call(this, oldVal, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcanEvent.dispatch.call(this, how, [ oldVal, index ]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcanEvent.dispatch.call(this, how, [ newVal, index ]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcanEvent.dispatch.call(this, {\r\n\t\t\t\t\ttype: \"\" + attr,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t}, [ newVal, oldVal ]);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.get get\r\n\t\t * @parent can-define/list/list.prototype\r\n\t\t *\r\n\t\t * Gets an item or all items from a DefineList.\r\n\t\t *\r\n\t\t * @signature `list.get()`\r\n\t\t *\r\n\t\t * Returns the list converted into a plain JS array. Any items that also have a\r\n\t\t * `get` method will have their `get` method called and the resulting value will be used as item value.\r\n\t\t *\r\n\t\t * This can be used to recursively convert a list instance to an Array of other plain JavaScript objects.\r\n\t\t * Cycles are supported and only create one object.\r\n\t\t *\r\n\t\t * `get()` can still return other non-plain JS objects like Dates.\r\n\t\t * Use [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.get() //-> [\"A\",\"B\"]\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @return {Array} A plain JavaScript `Array` that contains each item in the list.\r\n\t\t *\r\n\t\t * @signature `list.get(index)`\r\n\t\t *\r\n\t\t * Gets the item at `index`. `list.get(index)` should be used instead of\r\n\t\t * `list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]\r\n\t\t * (as opposed to [can-define/list/list.prototype.splice] which is the better way).\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.get(1) //-> \"B\"\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {Number} index A numeric position in the list.\r\n\t\t *\r\n\t\t *   @return {*} The value at index.\r\n\t\t *\r\n\t\t * @signature `list.get(prop)`\r\n\t\t *\r\n\t\t * Gets the property at `prop` if it might not have already been defined.\r\n\t\t *\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.set(\"count\",1000)\r\n\t\t * list.get(\"count\") //-> 1000\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {String} prop A property on the list.\r\n\t\t *\r\n\t\t *   @return {*} The value at `prop`.\r\n\t\t */\r\n\t\tget: function(index) {\r\n\t\t\tif (arguments.length) {\r\n\t\t\t\tObservation.add(this, \"\" + index);\r\n\t\t\t\treturn this[index];\r\n\t\t\t} else {\r\n\t\t\t\treturn defineHelpers.serialize(this, 'get', []);\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.set set\r\n\t\t * @parent can-define/list/list.prototype\r\n\t\t *\r\n\t\t * Sets an item or property or items or properties on a list.\r\n\t\t *\r\n\t\t * @signature `list.set(prop, value)`\r\n\t\t *\r\n\t\t * Sets the property at `prop`. This should be used when the property\r\n\t\t * isn't already defined.\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.set(\"count\",1000);\r\n\t\t * list.get(\"count\") //-> 1000;\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {Number} prop A property name.\r\n\t\t *   @param {*} value The value to add to the list.\r\n\t\t *   @return {can-define/list/list} The list instance.\r\n\t\t *\r\n\t\t * @signature `list.set(newProps)`\r\n\t\t *\r\n\t\t * Updates the properties on the list with `newProps`.\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.set({count: 1000, skip: 2});\r\n\t\t * list.get(\"count\") //-> 1000\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {Object} newProps An object of properties and values to set on the list.\r\n\t\t *   @return {can-define/list/list} The list instance.\r\n\t\t *\r\n\t\t * @signature `list.set(index, value)`\r\n\t\t *\r\n\t\t * Sets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.set(2,\"C\");\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {Number} index A numeric position in the list.\r\n\t\t *   @param {*} value The value to add to the list.\r\n\t\t *   @return {can-define/list/list} The list instance.\r\n\t\t *\r\n\t\t * @signature `list.set(newItems [,replaceAll])`\r\n\t\t *\r\n\t\t * Replaces items in the list with `newItems`\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var list = new DefineList([\"A\",\"B\"]);\r\n\t\t * list.set([\"c\"])        //-> DefineList[\"c\",\"B\"]\r\n\t\t * list.set([\"x\"], true)  //-> DefineList[\"x\"]\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {Array} newItems Items used to replace existing items in the list.\r\n\t\t *   @param {Boolean} [replaceAll] If true, will remove items at the end of the list.\r\n\t\t *   @return {can-define/list/list} The list instance.\r\n\t\t */\r\n\t\tset: function(prop, value) {\r\n\t\t\t// if we are setting a single value\r\n\t\t\tif (typeof prop !== \"object\") {\r\n\t\t\t\t// We want change events to notify using integers if we're\r\n\t\t\t\t// setting an integer index. Note that <float> % 1 !== 0;\r\n\t\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\r\n\t\t\t\tif (typeof prop === \"number\") {\r\n\t\t\t\t\t// Check to see if we're doing a .attr() on an out of\r\n\t\t\t\t\t// bounds index property.\r\n\t\t\t\t\tif (typeof prop === \"number\" &&\r\n\t\t\t\t\t\tprop > this._length - 1) {\r\n\t\t\t\t\t\tvar newArr = new Array((prop + 1) - this._length);\r\n\t\t\t\t\t\tnewArr[newArr.length - 1] = value;\r\n\t\t\t\t\t\tthis.push.apply(this, newArr);\r\n\t\t\t\t\t\treturn newArr;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.splice(prop, 1, value);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar defined = defineHelpers.defineExpando(this, prop, value);\r\n\t\t\t\t\tif (!defined) {\r\n\t\t\t\t\t\tthis[prop] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// otherwise we are setting multiple\r\n\t\t\telse {\r\n\t\t\t\tif (isArray(prop)) {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tthis.replace(prop);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.splice.apply(this, [ 0, prop.length ].concat(prop));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\teach(prop, function(value, prop) {\r\n\t\t\t\t\t\tthis.set(prop, value);\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t_items: function() {\r\n\t\t\tvar arr = [];\r\n\t\t\tthis._each(function(item) {\r\n\t\t\t\tarr.push(item);\r\n\t\t\t});\r\n\t\t\treturn arr;\r\n\t\t},\r\n\t\t_each: function(callback) {\r\n\t\t\tfor (var i = 0, len = this._length; i < len; i++) {\r\n\t\t\t\tcallback(this[i], i);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.splice splice\r\n\t\t * @parent can-define/list/list.prototype\r\n\t\t * @description Insert and remove elements from a DefineList.\r\n\t\t * @signature `list.splice(index[, howMany[, ...newItems]])`\r\n\t\t *\r\n\t\t * Removes `howMany` items at `index` and adds `newItems` in their place.\r\n\t\t *\r\n\t\t *\r\n\t\t *\r\n\t\t * @param {Number} index Where to start removing or inserting elements.\r\n\t\t *\r\n\t\t * @param {Number} [howMany] The number of elements to remove\r\n\t\t * If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\r\n\t\t *\r\n\t\t * @param {*} newItems Items to insert into the DefineList\r\n\t\t *\r\n\t\t * @return {Array} The elements removed by `splice`.\r\n\t\t *\r\n\t\t * @body\r\n\t\t *\r\n\t\t * ## Use\r\n\t\t *\r\n\t\t * `splice` lets you remove elements from and insert elements into a DefineList.\r\n\t\t *\r\n\t\t * This example demonstrates how to do surgery on a list of numbers:\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var list = new DefineList([0, 1, 2, 3]);\r\n\t\t *\r\n\t\t * // starting at index 2, remove one element and insert 'Alice' and 'Bob':\r\n\t\t * list.splice(2, 1, 'Alice', 'Bob');\r\n\t\t * list.get(); // [0, 1, 'Alice', 'Bob', 3]\r\n\t\t * ```\r\n\t\t *\r\n\t\t * ## Events\r\n\t\t *\r\n\t\t * `splice` causes the DefineList it's called on to emit\r\n\t\t * _add_ events, _remove_ events, and _length_ events. If there are\r\n\t\t * any elements to remove, a _remove_ event, and a\r\n\t\t * _length_ event will be fired. If there are any elements to insert, a\r\n\t\t * separate _add_ event, and a separate _length_ event\r\n\t\t * will be fired.\r\n\t\t *\r\n\t\t */\r\n\t\tsplice: function(index, howMany) {\r\n\t\t\tvar args = makeArray(arguments),\r\n\t\t\t\tadded = [],\r\n\t\t\t\ti, len, listIndex,\r\n\t\t\t\tallSame = args.length > 2;\r\n\r\n\t\t\tindex = index || 0;\r\n\r\n\t\t\t// converting the arguments to the right type\r\n\t\t\tfor (i = 0, len = args.length - 2; i < len; i++) {\r\n\t\t\t\tlistIndex = i + 2;\r\n\t\t\t\targs[listIndex] = this.__type(args[listIndex], listIndex);\r\n\t\t\t\tadded.push(args[listIndex]);\r\n\r\n\t\t\t\t// Now lets check if anything will change\r\n\t\t\t\tif (this[i + index] !== args[listIndex]) {\r\n\t\t\t\t\tallSame = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if nothing has changed, then return\r\n\t\t\tif (allSame && this._length <= added.length) {\r\n\t\t\t\treturn added;\r\n\t\t\t}\r\n\r\n\t\t\t// default howMany if not provided\r\n\t\t\tif (howMany === undefined) {\r\n\t\t\t\thowMany = args[1] = this._length - index;\r\n\t\t\t}\r\n\r\n\t\t\trunningNative = true;\r\n\t\t\tvar removed = splice.apply(this, args);\r\n\t\t\trunningNative = false;\r\n\r\n\t\t\tcanBatch.start();\r\n\t\t\tif (howMany > 0) {\r\n\t\t\t\t// tears down bubbling\r\n\t\t\t\tthis._triggerChange(\"\" + index, \"remove\", undefined, removed);\r\n\t\t\t}\r\n\t\t\tif (args.length > 2) {\r\n\t\t\t\tthis._triggerChange(\"\" + index, \"add\", added, removed);\r\n\t\t\t}\r\n\r\n\t\t\tcanEvent.dispatch.call(this, 'length', [ this._length ]);\r\n\r\n\t\t\tcanBatch.stop();\r\n\t\t\treturn removed;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.serialize serialize\r\n\t\t * @parent can-define/list/list.prototype\r\n\t\t *\r\n\t\t * Returns the a serialized version of this list.\r\n\t\t *\r\n\t\t * @signature `list.serialize()`\r\n\t\t *\r\n\t\t * Goes through each item in the list and gets its serialized\r\n\t\t * value and returns them in a plain Array.\r\n\t\t *\r\n\t\t * Each items serialized value is the result of calling `.serialize()`\r\n\t\t * on the item or if the item doesn't have a `serialize` method,\r\n\t\t * the item itself.\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var list = new DefineList([\"first\", {foo: \"bar\"}]);\r\n\t\t * var serializedList = list.serialize();\r\n\t\t *\r\n\t\t * serializedList //-> [\"first\", {foo: \"bar\"}]\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @return {Array} An array with each item's serialied value.\r\n\t\t */\r\n\t\tserialize: function() {\r\n\t\t\treturn defineHelpers.serialize(this, 'serialize', []);\r\n\t\t}\r\n\t});\r\n\r\n// Converts to an `array` of arguments.\r\nvar getArgs = function(args) {\r\n\treturn args[0] && Array.isArray(args[0]) ?\r\n\t\targs[0] :\r\n\t\tmakeArray(args);\r\n};\r\n// Create `push`, `pop`, `shift`, and `unshift`\r\neach({\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.push push\r\n\t\t * @description Add elements to the end of a list.\r\n\t\t * @signature `list.push(...elements)`\r\n\t\t *\r\n\t\t * `push` adds elements onto the end of a DefineList.\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var names = new DefineList(['Alice']);\r\n\t\t * names.push('Bob', 'Eve');\r\n\t\t * names //-> DefineList['Alice','Bob', 'Eve']\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @param {*} elements the elements to add to the DefineList\r\n\t\t *\r\n\t\t *   @return {Number} the new length of the DefineList\r\n\t\t *\r\n\t\t * @body\r\n\t\t *\r\n\t\t * ## Use\r\n\t\t *\r\n\t\t * `push` adds elements onto the end of a DefineList here is an example:\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var list = new DefineList(['Alice']);\r\n\t\t *\r\n\t\t * list.push('Bob', 'Eve');\r\n\t\t * list.get(); // ['Alice', 'Bob', 'Eve']\r\n\t\t * ```\r\n\t\t *\r\n\t\t * If you have an array you want to concatenate to the end\r\n\t\t * of the DefineList, you can use `apply`:\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var names = ['Bob', 'Eve'],\r\n\t\t *     list = new DefineList(['Alice']);\r\n\t\t *\r\n\t\t * list.push.apply(list, names);\r\n\t\t * list.get(); // ['Alice', 'Bob', 'Eve']\r\n\t\t * ```\r\n\t\t *\r\n\t\t * ## Events\r\n\t\t *\r\n\t\t * `push` causes _add_, and _length_ events to be fired.\r\n\t\t *\r\n\t\t * ## See also\r\n\t\t *\r\n\t\t * `push` has a counterpart in [can-define/list/list::pop pop], or you may be\r\n\t\t * looking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\r\n\t\t */\r\n\tpush: \"length\",\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.unshift unshift\r\n\t\t * @description Add items to the beginning of a DefineList.\r\n\t\t * @signature `list.unshift(...items)`\r\n\t\t *\r\n\t\t * `unshift` adds items onto the beginning of a DefineList.\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var list = new DefineList(['Alice']);\r\n\t\t *\r\n\t\t * list.unshift('Bob', 'Eve');\r\n\t\t * list; // DefineList['Bob', 'Eve', 'Alice']\r\n\t\t * ```\r\n\t\t *\r\n\t\t * @param {*} items The items to add to the DefineList.\r\n\t\t *\r\n\t\t * @return {Number} The new length of the DefineList.\r\n\t\t *\r\n\t\t * @body\r\n\t\t *\r\n\t\t * ## Use\r\n\t\t *\r\n\t\t *\r\n\t\t *\r\n\t\t * If you have an array you want to concatenate to the beginning\r\n\t\t * of the DefineList, you can use `apply`:\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var names = ['Bob', 'Eve'],\r\n\t\t *     list = new DefineList(['Alice']);\r\n\t\t *\r\n\t\t * list.unshift.apply(list, names);\r\n\t\t * list.get(); // ['Bob', 'Eve', 'Alice']\r\n\t\t * ```\r\n\t\t *\r\n\t\t * ## Events\r\n\t\t *\r\n\t\t * `unshift` causes _add_ and _length_ events to be fired.\r\n\t\t *\r\n\t\t * ## See also\r\n\t\t *\r\n\t\t * `unshift` has a counterpart in [can-define/list/list::shift shift], or you may be\r\n\t\t * looking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\r\n\t\t */\r\n\tunshift: 0\r\n},\r\n\t// Adds a method\r\n\t// `name` - The method name.\r\n\t// `where` - Where items in the `array` should be added.\r\n\tfunction(where, name) {\r\n\t\tvar orig = [][name];\r\n\t\tDefineList.prototype[name] = function() {\r\n\t\t\t// Get the items being added.\r\n\t\t\tvar args = [],\r\n\t\t\t\t// Where we are going to add items.\r\n\t\t\t\tlen = where ? this._length : 0,\r\n\t\t\t\ti = arguments.length,\r\n\t\t\t\tres, val;\r\n\r\n\t\t\t// Go through and convert anything to a `map` that needs to be converted.\r\n\t\t\twhile (i--) {\r\n\t\t\t\tval = arguments[i];\r\n\t\t\t\targs[i] = this.__type(val, i);\r\n\t\t\t}\r\n\r\n\t\t\t// Call the original method.\r\n\t\t\trunningNative = true;\r\n\t\t\tres = orig.apply(this, args);\r\n\t\t\trunningNative = false;\r\n\r\n\t\t\tif (!this.comparator || args.length) {\r\n\t\t\t\tcanBatch.start();\r\n\t\t\t\tthis._triggerChange(\"\" + len, \"add\", args, undefined);\r\n\t\t\t\tcanEvent.dispatch.call(this, 'length', [ this._length ]);\r\n\t\t\t\tcanBatch.stop();\r\n\t\t\t}\r\n\r\n\t\t\treturn res;\r\n\t\t};\r\n\t});\r\n\r\neach({\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.pop pop\r\n\t\t * @description Remove an element from the end of a DefineList.\r\n\t\t * @signature `list.pop()`\r\n\t\t *\r\n\t\t * `pop` removes an element from the end of a DefineList.\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * var names = new DefineList(['Alice', 'Bob', 'Eve']);\r\n\t\t * names.pop() //-> 'Eve'\r\n\t\t * ```\r\n\t\t *\r\n\t\t *   @return {*} The element just popped off the DefineList, or `undefined` if the DefineList was empty\r\n\t\t *\r\n\t\t * @body\r\n\t\t *\r\n\t\t * ## Use\r\n\t\t *\r\n\t\t * `pop` is the opposite action from [can-define/list/list::push push]:\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\r\n\t\t *\r\n\t\t * list.pop(); // 'Eve'\r\n\t\t * list.pop(); // 'Bob'\r\n\t\t * list.pop(); // 'Alice'\r\n\t\t * list.pop(); // undefined\r\n\t\t * ```\r\n\t\t *\r\n\t\t * ## Events\r\n\t\t *\r\n\t\t * `pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\r\n\t\t * when it is called.\r\n\t\t *\r\n\t\t * ## See also\r\n\t\t *\r\n\t\t * `pop` has its counterpart in [can-define/list/list::push push], or you may be\r\n\t\t * looking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\r\n\t\t */\r\n\tpop: \"length\",\r\n\t\t/**\r\n\t\t * @function can-define/list/list.prototype.shift shift\r\n\t\t * @description Remove an item from the front of a list.\r\n\t\t * @signature `list.shift()`\r\n\t\t *\r\n\t\t * `shift` removes an element from the beginning of a DefineList.\r\n\t\t *\r\n\t\t * ```\r\n\t\t * var list = new DefineList(['Alice','Adam']);\r\n\t\t * list.shift(); //-> 'Alice'\r\n\t\t * list.shift(); //-> 'Adam'\r\n\t\t * list.shift(); //-> undefined\r\n\t\t * ```\r\n\t\t *\r\n\t\t * @return {*} The element just shifted off the DefineList, or `undefined` if the DefineList is empty\r\n\t\t *\r\n\t\t * @body\r\n\t\t *\r\n\t\t * ## Use\r\n\t\t *\r\n\t\t * `shift` is the opposite action from `[can-define/list/list::unshift unshift]`:\r\n\t\t *\r\n\t\t * ## Events\r\n\t\t *\r\n\t\t * `pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\r\n\t\t * when it is called.\r\n\t\t *\r\n\t\t * ## See also\r\n\t\t *\r\n\t\t * `shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be\r\n\t\t * looking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\r\n\t\t */\r\n\tshift: 0\r\n},\r\n\t// Creates a `remove` type method\r\n\tfunction(where, name) {\r\n\t\tvar orig = [][name];\r\n\t\tDefineList.prototype[name] = function() {\r\n\t\t\tif (!this._length) {\r\n\t\t\t\t// For shift and pop, we just return undefined without\r\n\t\t\t\t// triggering events.\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\r\n\t\t\tvar args = getArgs(arguments),\r\n\t\t\t\tlen = where && this._length ? this._length - 1 : 0,\r\n\t\t\t\tres;\r\n\r\n\t\t\t// Call the original method.\r\n\t\t\trunningNative = true;\r\n\t\t\tres = orig.apply(this, args);\r\n\t\t\trunningNative = false;\r\n\r\n\t\t\t// Create a change where the args are\r\n\t\t\t// `len` - Where these items were removed.\r\n\t\t\t// `remove` - Items removed.\r\n\t\t\t// `undefined` - The new values (there are none).\r\n\t\t\t// `res` - The old, removed values (should these be unbound).\r\n\t\t\tcanBatch.start();\r\n\t\t\tthis._triggerChange(\"\" + len, \"remove\", undefined, [ res ]);\r\n\t\t\tcanEvent.dispatch.call(this, 'length', [ this._length ]);\r\n\t\t\tcanBatch.stop();\r\n\r\n\t\t\treturn res;\r\n\t\t};\r\n\t});\r\n\r\neach({\r\n\t/**\r\n\t * @function can-define/list/list.prototype.map map\r\n\t * @description Map the values in this list to another list.\r\n\t *\r\n\t * @signature `list.map(callback[, thisArg])`\r\n\t *\r\n\t * Loops through the values of the list, calling `callback` for each one until the list\r\n\t * ends.  The return values of `callback` are used to populate the returned list.\r\n\t *\r\n\t * ```js\r\n\t * var todos = new DefineList([\r\n\t *   {name: \"dishes\", complete: false},\r\n\t *   {name: \"lawn\", complete: true}\r\n\t * ]);\r\n\t * var names = todos.map(function(todo){\r\n\t *   return todo.name;\r\n\t * });\r\n\t * names //-> DefineList[\"dishes\",\"lawn\"]\r\n\t * ```\r\n\t *\r\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\r\n\t * The three parameters that callback gets passed are:\r\n\t *    - item (*) - the element at index.\r\n\t *    - index (Integer) - the index of the current element of the list.\r\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\r\n\t *\r\n\t * The return value of `callback`, including `undefined` values are used to populate the resulting list.\r\n\t *\r\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\r\n\t * @return {can-define/list/list} a new `DefineList` with the results of the map transform.\r\n\t * @body\r\n\t *\r\n\t */\r\n\t\"map\": 3,\r\n\t/**\r\n\t * @function can-define/list/list.prototype.filter filter\r\n\t *\r\n\t * Filter a list to a new list of the matched items.\r\n\t *\r\n\t * @signature `list.filter( callback [,thisArg] )`\r\n\t *\r\n\t * Filters `list` based on the return value of `callback`.\r\n\t *\r\n\t * ```\r\n\t * var names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\r\n\t * var aNames = names.filter(function(name){\r\n\t *   return name[0] === \"a\"\r\n\t * });\r\n\t * aNames //-> DefineList[\"alice\",\"adam\"]\r\n\t * ```\r\n\t *\r\n\t *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A\r\n\t *   function to call with each element of the DefineList. The three parameters that callback gets passed are:\r\n\t *    - item (*) - the element at index.\r\n\t *    - index (Integer) - the index of the current element of the list.\r\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\r\n\t *\r\n\t *   If `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be\r\n\t *   excluded.\r\n\t *\r\n\t *   @param  {Object}  thisArg  What `this` should be in the `callback`.\r\n\t *   @return {can-define/list/list} A new instance of this `DefineList` (may be a subclass), containing the items that passed the filter.\r\n\t *\r\n\t * @signature `list.filter( props )`\r\n\t *\r\n\t * Filters items in `list` based on the property values in `props`.\r\n\t *\r\n\t * ```\r\n\t * var todos = new DefineList([\r\n\t *   {name: \"dishes\", complete: false},\r\n\t *   {name: \"lawn\", complete: true}\r\n\t * ]);\r\n\t * var complete = todos.filter({complete: true});\r\n\t * complete //-> DefineList[{name: \"lawn\", complete: true}]\r\n\t * ```\r\n\t *\r\n\t *    @param  {Object}  props An object of key-value properties.  Each key and value in\r\n\t *    `props` must be present on an `item` for the `item` to be in the returned list.\r\n\t *    @return {can-define/list/list} A new `DefineList` of the same type.\r\n\t */\r\n\t\"filter\": 3,\r\n\t/**\r\n\t * @function can-define/list/list.prototype.reduce reduce\r\n\t * @description Map the values in this list to a single value\r\n\t *\r\n\t * @signature `list.reduce(callback, initialValue, [, thisArg])`\r\n\t *\r\n\t * Loops through the values of the list, calling `callback` for each one until the list\r\n\t * ends.  The return value of `callback` is passed to the next iteration as the first argument, \r\n\t * and finally returned by `reduce`.\r\n\t *\r\n\t * ```js\r\n\t * var todos = new DefineList([\r\n\t *   {name: \"dishes\", complete: false},\r\n\t *   {name: \"lawn\", complete: true}\r\n\t * ]);\r\n\t * var todosAsOneObject = todos.reduce(function(todos, todo){\r\n\t *   todos[todo.name] = todo.complete;\r\n\t *   return todos;\r\n\t * }, {});\r\n\t * todosAsOneObject //-> { dishes: false, lawn: true }\r\n\t * ```\r\n\t *\r\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\r\n\t * The four parameters that callback gets passed are:\r\n\t *    - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\r\n\t *    - item (*) - the element at index.\r\n\t *    - index (Integer) - the index of the current element of the list.\r\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\r\n\t *\r\n\t * The return value of `callback` is passed to the next iteration as the first argument, and returned from \r\n\t * `reduce` if the last iteration.\r\n\t *\r\n\t * @param {*} [initialValue] The initial value to use as `current` in the first iteration\r\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\r\n\t * @return {*} The result of the final call of `callback` on the list.\r\n\t * @body\r\n\t *\r\n\t */\r\n\t\"reduce\": 4,\r\n\t/**\r\n\t * @function can-define/list/list.prototype.reduceRight reduceRight\r\n\t * @description Map the values in this list to a single value from right to left\r\n\t *\r\n\t * @signature `list.reduceRight(callback, initialValue, [, thisArg])`\r\n\t *\r\n\t * Loops through the values of the list in reverse order, calling `callback` for each one until the list\r\n\t * ends.  The return value of `callback` is passed to the next iteration as the first argument, \r\n\t * and finally returned by `reduce`.\r\n\t *\r\n\t * ```js\r\n\t * var todos = new DefineList([\r\n\t *   {name: \"dishes\", complete: false},\r\n\t *   {name: \"lawn\", complete: true}\r\n\t * ]);\r\n\t * var todosAsOneObject = todos.reduce(function(todos, todo){\r\n\t *   todos[todo.name] = todo.complete;\r\n\t *   return todos;\r\n\t * }, {});\r\n\t * todosAsOneObject //-> { dishes: false, lawn: true }\r\n\t * ```\r\n\t *\r\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\r\n\t * The four parameters that callback gets passed are:\r\n\t *    - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\r\n\t *    - item (*) - the element at index.\r\n\t *    - index (Integer) - the index of the current element of the list.\r\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\r\n\t *\r\n\t * The return value of `callback` is passed to the next iteration as the first argument, and returned from \r\n\t * `reduce` if the last iteration.\r\n\t *\r\n\t * @param {*} [initialValue] The initial value to use as `current` in the first iteration\r\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\r\n\t * @return {*} The result of the final call of `callback` on the list.\r\n\t * @body\r\n\t *\r\n\t */\r\n\t\"reduceRight\": 4,\r\n\t/**\r\n\t * @function can-define/list/list.prototype.every every\r\n\t *\r\n\t * Return true if every item in a list matches a predicate.\r\n\t *\r\n\t * @signature `list.every( callback [,thisArg] )`\r\n\t *\r\n\t * Tests each item in `list` by calling `callback` on it.  If `callback` returns truthy for every element in\r\n\t * `list`, `every` returns `true`.\r\n\t *\r\n\t * ```\r\n\t * var names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\r\n\t * var aNames = names.every(function(name){\r\n\t *   return name[0] === \"a\"\r\n\t * });\r\n\t * aNames //-> false\r\n\t * ```\r\n\t *\r\n\t *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A\r\n\t *   function to call with each element of the DefineList. The three parameters that callback gets passed are:\r\n\t *    - item (*) - the element at index.\r\n\t *    - index (Integer) - the index of the current element of the list.\r\n\t *    - list (DefineList) - the `DefineList` the elements are coming from.\r\n\t *\r\n\t *   If `callback` returns a truthy result, `every` will evaluate the callback on the next element.  Otherwise, `every`\r\n\t *   will return `false`.\r\n\t *\r\n\t *   @param  {Object}  thisArg  What `this` should be in the `callback`.\r\n\t *   @return {Boolean} `true` if calling the callback on every element in `list` returns a truthy value, `false` otherwise.\r\n\t *\r\n\t * @signature `list.every( props )`\r\n\t *\r\n\t * Tests each item in `list` by comparing its properties to `props`.  If `props` match for every element in\r\n\t * `list`, `every` returns `true`.\r\n\t *\r\n\t * ```\r\n\t * var todos = new DefineList([\r\n\t *   {name: \"dishes\", complete: false},\r\n\t *   {name: \"lawn\", complete: true}\r\n\t * ]);\r\n\t * var complete = todos.every({complete: true});\r\n\t * complete //-> false\r\n\t * ```\r\n\t *\r\n\t *    @param  {Object}  props An object of key-value properties.  Each key and value in\r\n\t *    `props` must be present on an `item` for the `item` to match.\r\n\t *    @return {Boolean} `true` if every element in `list` matches `props`, `false` otherwise\r\n\t */\r\n\t\"every\": 3,\r\n\t/**\r\n\t * @function can-define/list/list.prototype.some some\r\n\t *\r\n\t * Return true if at least one item in a list matches a predicate.\r\n\t *\r\n\t * @signature `list.some( callback [,thisArg] )`\r\n\t *\r\n\t * Tests each item in `list` by calling `callback` on it.  If `callback` returns truthy for some element in\r\n\t * `list`, `some` returns `true`.\r\n\t *\r\n\t * ```\r\n\t * var names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\r\n\t * var aNames = names.some(function(name){\r\n\t *   return name[0] === \"a\"\r\n\t * });\r\n\t * aNames //-> false\r\n\t * ```\r\n\t *\r\n\t *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A\r\n\t *   function to call with each element of the DefineList. The three parameters that callback gets passed are:\r\n\t *    - item (*) - the element at index.\r\n\t *    - index (Integer) - the index of the current element of the list.\r\n\t *    - list (DefineList) - the DefineList the elements are coming from.\r\n\t *\r\n\t *   If `callback` returns a falsy result, `some` will evaluate the callback on the next element.  Otherwise, `some`\r\n\t *   will return `true`.\r\n\t *\r\n\t *   @param  {Object}  thisArg  What `this` should be in the `callback`.\r\n\t *   @return {Boolean} `false` if calling the callback on some element in `list` returns a falsy value, `true` otherwise.\r\n\t *\r\n\t * @signature `list.some( props )`\r\n\t *\r\n\t * Tests each item in `list` by comparing its properties to `props`.  If `props` match for some element in\r\n\t * `list`, `some` returns `true`.\r\n\t *\r\n\t * ```\r\n\t * var todos = new DefineList([\r\n\t *   {name: \"dishes\", complete: false},\r\n\t *   {name: \"lawn\", complete: true}\r\n\t * ]);\r\n\t * var complete = todos.some({complete: true});\r\n\t * complete //-> false\r\n\t * ```\r\n\t *\r\n\t *    @param  {Object}  props An object of key-value properties.  Each key and value in\r\n\t *    `props` must be present on an `item` for the `item` to match.\r\n\t *    @return {Boolean} `false` if every element in `list` fails to match `props`, `true` otherwise\r\n\t */\r\n\t\"some\": 3\r\n}, \r\nfunction a(fnLength, fnName) {\r\n\tDefineList.prototype[fnName] = function() {\r\n\t\tvar self = this;\r\n\t\tvar args = [].slice.call(arguments, 0);\r\n\t\tvar callback = args[0];\r\n\t\tvar thisArg = args[fnLength - 1] || self;\r\n\r\n\t\tif (typeof callback === \"object\") {\r\n\t\t\tcallback = makeFilterCallback(callback);\r\n\t\t}\r\n\r\n\t\targs[0] = function() {\r\n\t\t\tvar cbArgs = [].slice.call(arguments, 0);\r\n\t\t\t// use .get(index) to ensure observation added.\r\n\t\t\t// the arguments are (item, index) or (result, item, index)\r\n\t\t\tcbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);\r\n\t\t\treturn callback.apply(thisArg, cbArgs);\r\n\t\t};\r\n\t\tvar ret = Array.prototype[fnName].apply(this, args);\r\n\t\t\r\n\t\tif(fnName === \"map\") {\r\n\t\t\treturn new DefineList(ret);\r\n\t\t}\r\n\t\telse if(fnName === \"filter\") {\r\n\t\t\treturn new self.constructor(ret);\r\n\t\t} else {\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n\r\nassign(DefineList.prototype, {\r\n\t/**\r\n\t * @function can-define/list/list.prototype.indexOf indexOf\r\n\t * @description Look for an item in a DefineList.\r\n\t * @signature `list.indexOf(item)`\r\n\t *\r\n\t * `indexOf` finds the position of a given item in the DefineList.\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\r\n\t * list.indexOf('Alice');   // 0\r\n\t * list.indexOf('Charlie'); // -1\r\n\t * ```\r\n\t *\r\n\t *   @param {*} item The item to find.\r\n\t *\r\n\t *   @return {Number} The position of the item in the DefineList, or -1 if the item is not found.\r\n\t *\r\n\t * @body\r\n\t *\r\n\t */\r\n\tindexOf: function(item, fromIndex) {\r\n\t\tfor (var i = fromIndex || 0, len = this.length; i < len; i++) {\r\n\t\t\tif (this.get(i) === item) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\t\t/**\r\n\t * @function can-define/list/list.prototype.lastIndexOf lastIndexOf\r\n\t * @description Look for an item in a DefineList starting from the end.\r\n\t * @signature `list.lastIndexOf(item)`\r\n\t *\r\n\t * `lastIndexOf` finds the last position of a given item in the DefineList.\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList(['Alice', 'Bob', 'Alice', 'Eve']);\r\n\t * list.lastIndexOf('Alice');   // 2\r\n\t * list.lastIndexOf('Charlie'); // -1\r\n\t * ```\r\n\t *\r\n\t *   @param {*} item The item to find.\r\n\t *\r\n\t *   @return {Number} The position of the item in the DefineList, or -1 if the item is not found.\r\n\t *\r\n\t * @body\r\n\t *\r\n\t */\r\n\tlastIndexOf: function(item, fromIndex) {\r\n\t\tfromIndex = typeof fromIndex === \"undefined\" ? this.length - 1: fromIndex;\r\n\t\tfor (var i = fromIndex; i >= 0; i--) {\r\n\t\t\tif (this.get(i) === item) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t},\r\n\r\n\t/**\r\n\t * @function can-define/list/list.prototype.join join\r\n\t * @description Join a DefineList's elements into a string.\r\n\t * @signature `list.join(separator)`\r\n\t *\r\n\t * `join` turns a DefineList into a string by inserting _separator_ between the string representations\r\n\t * of all the elements of the DefineList.\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\r\n\t * list.join(', '); // 'Alice, Bob, Eve'\r\n\t * ```\r\n\t *\r\n\t * @param {String} separator The string to seperate elements.\r\n\t *\r\n\t * @return {String} The joined string.\r\n\t *\r\n\t */\r\n\tjoin: function() {\r\n\t\tObservation.add(this, \"length\");\r\n\t\treturn [].join.apply(this, arguments);\r\n\t},\r\n\r\n\t/**\r\n\t * @function can-define/list/list.prototype.reverse reverse\r\n\t * @description Reverse the order of a DefineList.\r\n\t * @signature `list.reverse()`\r\n\t *\r\n\t * Reverses the elements of the DefineList in place.\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\r\n\t * var reversedList = list.reverse();\r\n\t *\r\n\t * reversedList; //-> DefineList['Eve', 'Bob', 'Alice'];\r\n\t * list === reversedList; // true\r\n\t * ```\r\n\t *\r\n\t * @return {can-define/list/list} The DefineList, for chaining.\r\n\t *\r\n\t * @body\r\n\t *\r\n\t */\r\n\treverse: function() {\r\n\t\t// this shouldn't be observable\r\n\t\tvar list = [].reverse.call(this._items());\r\n\t\treturn this.replace(list);\r\n\t},\r\n\r\n\t/**\r\n\t * @function can-define/list/list.prototype.slice slice\r\n\t * @description Make a copy of a part of a DefineList.\r\n\t * @signature `list.slice([start[, end]])`\r\n\t *\r\n\t * `slice` creates a copy of a portion of the DefineList.\r\n\t *\r\n\t * ```js\r\n\t * var list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\r\n\t * var newList = list.slice(1, 4);\r\n\t * newList //-> DefineList['Bob', 'Charlie', 'Daniel']\r\n\t * ```\r\n\t *\r\n\t * @param {Number} [start=0] The index to start copying from. Defaults to `0`.\r\n\t *\r\n\t * @param {Number} [end] The first index not to include in the copy\r\n\t * If _end_ is not supplied, `slice` will copy until the end of the list.\r\n\t *\r\n\t * @return {can-define/list/list} A new `DefineList` with the extracted elements.\r\n\t *\r\n\t * @body\r\n\t *\r\n\t * ## Use\r\n\t *\r\n\t * `slice` is the simplest way to copy a DefineList:\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList(['Alice', 'Bob', 'Eve']);\r\n\t * var copy = list.slice();\r\n\t *\r\n\t * copy           //-> DefineList['Alice', 'Bob', 'Eve']\r\n\t * list === copy; //-> false\r\n\t * ```\r\n\t */\r\n\tslice: function() {\r\n\t\t// tells computes to listen on length for changes.\r\n\t\tObservation.add(this, \"length\");\r\n\t\tvar temp = Array.prototype.slice.apply(this, arguments);\r\n\t\treturn new this.constructor(temp);\r\n\t},\r\n\r\n\t/**\r\n\t * @function can-define/list/list.prototype.concat concat\r\n\t * @description Merge many collections together into a DefineList.\r\n\t * @signature `list.concat(...args)`\r\n\t *\r\n\t * Returns a `DefineList` with the `list`'s items and the additional `args`.\r\n\t *\r\n\t * @param {Array|can-define/list/list|*} args Any number of arrays, Lists, or values to add in\r\n\t * For each parameter given, if it is an Array or a DefineList, each of its elements will be added to\r\n\t * the end of the concatenated DefineList. Otherwise, the parameter itself will be added.\r\n\t *\r\n\t * @return {can-define/list/list} A DefineList of the same type.\r\n\t *\r\n\t * @body\r\n\t *\r\n\t * ## Use\r\n\t *\r\n\t * `concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList();\r\n\t * var newList = list.concat(\r\n\t *     'Alice',\r\n\t *     ['Bob', 'Charlie']),\r\n\t *     new DefineList(['Daniel', 'Eve']),\r\n\t *     {f: 'Francis'}\r\n\t * );\r\n\t * newList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\r\n\t * ```\r\n\t */\r\n\tconcat: function() {\r\n\t\tvar args = [];\r\n\t\t// Go through each of the passed `arguments` and\r\n\t\t// see if it is list-like, an array, or something else\r\n\t\teach(arguments, function(arg) {\r\n\t\t\tif (types.isListLike(arg) || Array.isArray(arg)) {\r\n\t\t\t\t// If it is list-like we want convert to a JS array then\r\n\t\t\t\t// pass each item of the array to this.__type\r\n\t\t\t\tvar arr = types.isListLike(arg) ? makeArray(arg) : arg;\r\n\t\t\t\teach(arr, function(innerArg) {\r\n\t\t\t\t\targs.push(this.__type(innerArg));\r\n\t\t\t\t}, this);\r\n\t\t\t} else {\r\n\t\t\t\t// If it is a Map, Object, or some primitive\r\n\t\t\t\t// just pass arg to this.__type\r\n\t\t\t\targs.push(this.__type(arg));\r\n\t\t\t}\r\n\t\t}, this);\r\n\r\n\t\t// We will want to make `this` list into a JS array\r\n\t\t// as well (We know it should be list-like), then\r\n\t\t// concat with our passed in args, then pass it to\r\n\t\t// list constructor to make it back into a list\r\n\t\treturn new this.constructor(Array.prototype.concat.apply(makeArray(this), args));\r\n\t},\r\n\r\n\t/**\r\n\t * @function can-define/list/list.prototype.forEach forEach\r\n\t * @description Call a function for each element of a DefineList.\r\n\t * @signature `list.forEach(callback[, thisArg])`\r\n\t *\r\n\t * Loops through the values of the list, calling `callback` for each one until the list ends\r\n\t * or `false` is returned.\r\n\t *\r\n\t * ```\r\n\t * list.forEach(function(item, index, list){ ... })\r\n\t * ```\r\n\t *\r\n\t * @param {function(item, index, list)} callback A function to call with each element of the DefineList.\r\n\t * The three parameters that callback gets passed are:\r\n\t *    - item - the element at index.\r\n\t *    - index - the current element of the list.\r\n\t *    - list - the DefineList the elements are coming from.\r\n\t *\r\n\t * If the callback returns `false` the looping stops.\r\n\t *\r\n\t * @param {Object} [thisArg] The object to use as `this` inside the callback.\r\n\t * @return {can-define/list/list} The list instance.\r\n\t * @body\r\n\t *\r\n\t * ## Use\r\n\t *\r\n\t * `forEach` calls a callback for each element in the DefineList.\r\n\t *\r\n\t * ```\r\n\t * var list = new DefineList([1, 2, 3]);\r\n\t * list.forEach(function(element, index, list) {\r\n\t *     list.get(index, element * element);\r\n\t * });\r\n\t * list.get(); // [1, 4, 9]\r\n\t * ```\r\n\t */\r\n\tforEach: function(cb, thisarg) {\r\n\t\tvar item;\r\n\t\tfor (var i = 0, len = this.length; i < len; i++) {\r\n\t\t\titem = this.get(i);\r\n\t\t\tif (cb.call(thisarg || item, item, i, this) === false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t/**\r\n\t * @function can-define/list/list.prototype.replace replace\r\n\t * @description Replace all the elements of a DefineList.\r\n\t * @signature `list.replace(collection)`\r\n\t *\r\n\t * Replaces every item in the list with `collection`.\r\n\t *\r\n\t * ```\r\n\t * var names = new DefineList([\"alice\",\"adam\",\"eve\"]);\r\n\t * names.replace([\"Justin\",\"Xena\"]);\r\n\t * names //-> DefineList[\"Justin\",\"Xena\"]\r\n\t * ```\r\n\t *\r\n\t * @param {Array|can-define/list/list} collection The collection of items that will be in `list`.\r\n\t * @return {can-define/list/list} Returns the `list`.\r\n\t *\r\n\t * @body\r\n\t *\r\n\t * ## Use\r\n\t *\r\n\t * `replace` is essentially a shortcut for [can-define/list/list.prototype.splice].\r\n\t *\r\n\t * ## Events\r\n\t *\r\n\t * `replace` causes _remove_, _add_, and _length_ events.\r\n\t */\r\n\treplace: function(newList) {\r\n\t\tvar patches = diff(this, newList);\r\n\r\n\t\tcanBatch.start();\r\n\t\tfor (var i = 0, len = patches.length; i < len; i++) {\r\n\t\t\tthis.splice.apply(this, [\r\n\t\t\t\tpatches[i].index,\r\n\t\t\t\tpatches[i].deleteCount\r\n\t\t\t].concat(patches[i].insert));\r\n\t\t}\r\n\t\tcanBatch.stop();\r\n\r\n\t\treturn this;\r\n\t},\r\n\t/**\r\n\t * @function can-define/list/list.prototype.sort sort\r\n\t * @description Sort the properties of a list.\r\n\t *\r\n\t * @signature `list.sort([compareFunction])`\r\n\t *\r\n\t * Sorts the elements of a list in place and returns the list. The API is the\r\n\t * same as the native JavaScript `Array.prototype.sort` API.\r\n\t *\r\n\t * ```js\r\n\t * var accounts = new Account.List([\r\n\t *   { name: \"Savings\", amount: 20.00 },\r\n\t *   { name: \"Checking\", amount: 103.24 },\r\n\t *   { name: \"Kids Savings\", amount: 48155.13 }\r\n\t * ]);\r\n\t * accounts.sort(function(a, b){\r\n\t *   if (a.name < b.name) {\r\n\t *     return -1;\r\n\t *   } else if (a.name > b.name){\r\n\t *     return 1;\r\n\t *   } else {\r\n\t *     return 0;\r\n\t *   }\r\n\t * });\r\n\t * accounts[0].name === \"Checking\"\r\n\t * accounts[1].name === \"Kids Savings\"\r\n\t * accounts[2].name === \"Savings\"\r\n\t * ```\r\n\t *\r\n\t * @param {function(a, b)} compareFunction Specifies a function that defines the sort order.\r\n\t *\r\n\t * If `compareFunction` is supplied, the list elements are sorted according to the return\r\n\t * value of the compare function. If `a` and `b` are two elements being compared, then:\r\n\t *\r\n\t *  - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\r\n\t *  a lower index than `b`, so `a` will now come first.\r\n\t *  - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\r\n\t *  - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\r\n\t *  a higher index than `b`, so `b` will now come first.\r\n\t *\r\n\t * @return {can-define/list/list} The list instance.\r\n\t * @body\r\n\t * ```\r\n\t */\r\n\tsort: function(compareFunction) {\r\n\t\tvar removed = Array.prototype.slice.call(this);\r\n\t\tArray.prototype.sort.call(this, compareFunction);\r\n\t\tvar added = Array.prototype.slice.call(this);\r\n\r\n\t\tcanBatch.start();\r\n\t\tcanEvent.dispatch.call(this, 'remove', [ removed, 0 ]);\r\n\t\tcanEvent.dispatch.call(this, 'add', [ added, 0 ]);\r\n\t\tcanEvent.dispatch.call(this, 'length', [ this._length, this._length ]);\r\n\t\tcanBatch.stop();\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\n\r\n// Add necessary event methods to this object.\r\nfor (var prop in define.eventsProto) {\r\n\tDefineList[prop] = define.eventsProto[prop];\r\n\tObject.defineProperty(DefineList.prototype, prop, {\r\n\t\tenumerable: false,\r\n\t\tvalue: define.eventsProto[prop],\r\n\t\twritable: true\r\n\t});\r\n}\r\n\r\nObject.defineProperty(DefineList.prototype, \"length\", {\r\n\tget: function() {\r\n\t\tif (!this.__inSetup) {\r\n\t\t\tObservation.add(this, \"length\");\r\n\t\t}\r\n\t\treturn this._length;\r\n\t},\r\n\tset: function(newVal) {\r\n\t\tif (runningNative) {\r\n\t\t\tthis._length = newVal;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (newVal === this._length) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (newVal > this._length - 1) {\r\n\t\t\tvar newArr = new Array(newVal - this._length);\r\n\t\t\tthis.push.apply(this, newArr);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.splice(newVal);\r\n\t\t}\r\n\t},\r\n\tenumerable: true\r\n});\r\n\r\nvar oldIsListLike = types.isListLike;\r\ntypes.isListLike = function(obj) {\r\n\treturn obj instanceof DefineList || oldIsListLike.apply(this, arguments);\r\n};\r\n\r\nDefineList.prototype.each = DefineList.prototype.forEach;\r\nDefineList.prototype.attr = function(prop, value) {\r\n\tcanLog.warn(\"DefineMap::attr shouldn't be called\");\r\n\tif (arguments.length === 0) {\r\n\t\treturn this.get();\r\n\t} else if (prop && typeof prop === \"object\") {\r\n\t\treturn this.set.apply(this, arguments);\r\n\t} else if (arguments.length === 1) {\r\n\t\treturn this.get(prop);\r\n\t} else {\r\n\t\treturn this.set(prop, value);\r\n\t}\r\n};\r\nDefineList.prototype.item = function(index, value) {\r\n\tif (arguments.length === 1) {\r\n\t\treturn this.get(index);\r\n\t} else {\r\n\t\treturn this.set(index, value);\r\n\t}\r\n};\r\nDefineList.prototype.items = function() {\r\n\tcanLog.warn(\"DefineList::get should should be used instead of DefineList::items\");\r\n\treturn this.get();\r\n};\r\n\r\ntypes.DefineList = DefineList;\r\ntypes.DefaultList = DefineList;\r\nmodule.exports = ns.DefineList = DefineList;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-define/list/list.js\n// module id = 57\n// module chunks = 0","var canEvent = require('can-event');\n/**\n * @typedef {{bind:function():*,unbind:function():*}} can.util.bind\n *\n * Provides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\n * when the first bind happens and.  `unbind()` calls `this._bindteardown` when there\n * are no more event handlers.\n *\n */\n\t// ## Bind helpers\n\nvar lifecycle = function(prototype) {\n\tvar baseAddEventListener = prototype.addEventListener;\n\tvar baseRemoveEventListener = prototype.removeEventListener;\n\n\tprototype.addEventListener = function () {\n\t\t// Add the event to this object\n\t\tvar ret = baseAddEventListener.apply(this, arguments);\n\t\t// If not initializing, and the first binding\n\t\t// call bindsetup if the function exists.\n\t\tif (!this.__inSetup) {\n\t\t\tthis.__bindEvents = this.__bindEvents || {};\n\t\t\tif (!this.__bindEvents._lifecycleBindings) {\n\t\t\t\tthis.__bindEvents._lifecycleBindings = 1;\n\t\t\t\t// setup live-binding\n\t\t\t\tif (this._eventSetup) {\n\t\t\t\t\tthis._eventSetup();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.__bindEvents._lifecycleBindings++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\tprototype.removeEventListener = function (event, handler) {\n\t\tif (!this.__bindEvents) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar handlers = this.__bindEvents[event] || [];\n\t\tvar handlerCount = handlers.length;\n\n\t\t// Remove the event handler\n\t\tvar ret = baseRemoveEventListener.apply(this, arguments);\n\t\tif (this.__bindEvents._lifecycleBindings === null) {\n\t\t\tthis.__bindEvents._lifecycleBindings = 0;\n\t\t} else {\n\t\t\t// Subtract the difference in the number of handlers bound to this\n\t\t\t// event before/after removeEvent\n\t\t\tthis.__bindEvents._lifecycleBindings -= (handlerCount - handlers.length);\n\t\t}\n\t\t// If there are no longer any bindings and\n\t\t// there is a bindteardown method, call it.\n\t\tif (!this.__bindEvents._lifecycleBindings && this._eventTeardown) {\n\t\t\tthis._eventTeardown();\n\t\t}\n\t\treturn ret;\n\t};\n\n\treturn prototype;\n};\n\nvar baseEvents = lifecycle({\n\taddEventListener: canEvent.addEventListener,\n\tremoveEventListener: canEvent.removeEventListener\n});\n\nlifecycle.addAndSetup = baseEvents.addEventListener;\nlifecycle.removeAndTeardown = baseEvents.removeEventListener;\n\nmodule.exports = lifecycle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-event/lifecycle/lifecycle.js\n// module id = 58\n// module chunks = 0","var Construct = require(\"can-construct\");\nvar canEvent = require(\"can-event\");\nvar canBatch = require(\"can-event/batch/batch\");\nvar assign = require(\"can-util/js/assign/assign\");\nvar each = require(\"can-util/js/each/each\");\nvar types = require(\"can-types\");\nvar Observation = require(\"can-observation\");\n\n// this is a very simple can-map like object\nvar SimpleMap = Construct.extend(\n\t/**\n\t * @prototype\n\t */\n\t{\n\t\t// ### setup\n\t\t// A setup function for the instantiation of a simple-map.\n\t\tsetup: function(initialData){\n\t\t\tthis._data = {};\n\t\t\tthis.attr(initialData);\n\t\t},\n\t\t// ### attr\n\t\t// The main get/set interface simple-map.\n\t\t// Either sets or gets one or more properties depending on how it is called.\n\t\tattr: function(prop, value) {\n\t\t\tvar self = this;\n\n\t\t\tif(arguments.length === 0 ) {\n\t\t\t\tObservation.add(this,\"__keys\");\n\t\t\t\tvar data = {};\n\t\t\t\teach(this._data, function(value, prop){\n\t\t\t\t\tObservation.add(this, prop);\n\t\t\t\t\tdata[prop] = value;\n\t\t\t\t}, this);\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if(arguments.length > 1) {\n\t\t\t\tvar had = this._data.hasOwnProperty(prop);\n\t\t\t\tvar old = this._data[prop];\n\t\t\t\tthis._data[prop] = value;\n\t\t\t\tcanBatch.start();\n\t\t\t\tif(!had) {\n\t\t\t\t\tcanEvent.dispatch.call(this, \"__keys\", []);\n\t\t\t\t}\n\t\t\t\tcanEvent.dispatch.call(this, prop, [value, old]);\n\t\t\t\tcanBatch.stop();\n\t\t\t}\n\t\t\t// 1 argument\n\t\t\telse if(typeof prop === 'object') {\n\t\t\t\tObject.keys(prop).forEach(function(key) {\n\t\t\t\t\tself.attr(key, prop[key]);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(prop !== \"constructor\") {\n\t\t\t\t\tObservation.add(this, prop);\n\t\t\t\t\treturn this._data[prop];\n\t\t\t\t}\n\n\t\t\t\treturn this.constructor;\n\t\t\t}\n\t\t},\n\t\tserialize: function(){\n\t\t\tvar serialized = {};\n\t\t\tObservation.add(this,\"__keys\");\n\t\t\teach(this._data, function(data, prop){\n\t\t\t\tObservation.add(this, prop);\n\t\t\t\tserialized[prop] = data && (typeof data.serialize === \"function\") ?\n\t\t\t\t\tdata.serialize() : data;\n\t\t\t}, this);\n\t\t\treturn serialized;\n\t\t},\n\t\tget: function(){\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t},\n\t\tset: function(){\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t}\n\t});\n\nassign(SimpleMap.prototype, canEvent);\n\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj) {\n\tif(obj instanceof SimpleMap) {\n\t\treturn true;\n\t}\n\n\treturn oldIsMapLike.call(this, obj);\n};\n\nif(!types.DefaultMap) {\n\ttypes.DefaultMap = SimpleMap;\n}\n\nmodule.exports = SimpleMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-simple-map/can-simple-map.js\n// module id = 59\n// module chunks = 0","'use strict';\n\nmodule.exports = function(child){\n\treturn this.contains(child);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/contains/contains.js\n// module id = 60\n// module chunks = 0","'use strict';\n\nvar domEvents = require(\"../events\");\nvar domData = require(\"../../data/data\");\nvar domMatches = require(\"../../matches/matches\");\nvar each = require(\"../../../js/each/each\");\nvar isEmptyObject = require(\"../../../js/is-empty-object/is-empty-object\");\n\nvar dataName = \"delegateEvents\";\n\n// Some events do not bubble, so delegating them requires registering the handler in the\n// capturing phase.\n// http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\nvar useCapture = function(eventType) {\n\treturn eventType === 'focus' || eventType === 'blur';\n};\n\n/**\n * @module {events} can-util/dom/events/delegate/delegate delegateEvents\n * @parent can-util/dom/events/events\n *\n * Add delegate listeners to DOM events.  Delegated listeners use a selector on an \n * ancestor element to determine when to fire the event for an item.  This can help \n * cases where large numbers of similar DOM nodes are added into a DOM subtree, since\n * event handlers do not have to be attached to each new node.\n *\n * ```js\n * var events = require(\"can-util/dom/events/events\");\n * require(\"can-util/dom/events/delegate/delegate\");\n * var el = document.createElement(\"div\");\n * var sub = document.createElement(\"div\");\n * sub.className = \"foo\"\n * el.appendChild(sub);\n *\n * function delegateEventsHandler() {\n * \tconsole.log(\"delegate event fired\");\n * }\n * \n * events.addDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler, false);\n *\n * events.removeDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler);\n * ```\n */\nvar handleEvent = function(ev){\n\tvar events = domData.get.call(this, dataName);\n\tvar eventTypeEvents = events[ev.type];\n\t// contains the element and the handlers to call back\n\tvar matches = [];\n\n\tif(eventTypeEvents) {\n\t\tvar selectorDelegates = [];\n\t\t// convert eventTypeEvents from an object to\n\t\t// an array.\n\t\teach(eventTypeEvents, function(delegates){\n\t\t\tselectorDelegates.push(delegates);\n\t\t});\n\n\t\t// walk from the target to the delegate element\n\t\t// checking each selector\n\t\tvar cur = ev.target;\n\t\tdo {\n\t\t\tselectorDelegates.forEach(function(delegates){\n\t\t\t\tif (domMatches.call(cur, delegates[0].selector )) {\n\t\t\t\t\tmatches.push({\n\t\t\t\t\t\ttarget: cur,\n\t\t\t\t\t\tdelegates: delegates\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tcur = cur.parentNode;\n\t\t} while (cur && cur !== ev.currentTarget);\n\n\t}\n\n\t// make sure `cancelBubble` is  set\n\tvar oldStopProp = ev.stopPropagation;\n\tev.stopPropagation = function() {\n\t\toldStopProp.apply(this, arguments);\n    this.cancelBubble = true;\n  };\n\n\tfor(var i = 0; i < matches.length; i++) {\n\t\tvar match = matches[i];\n\t\tvar delegates = match.delegates;\n\n\t\tfor(var d = 0, dLen = delegates.length; d < dLen; d++) {\n\t\t\tif( delegates[d].handler.call(match.target, ev) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (ev.cancelBubble) {\n                return;\n            }\n\t\t}\n\t}\n};\n\n/**\n * @function can-util/dom/events/delegate/delegate.addDelegateListener events.addDelegateListener\n * @parent can-util/dom/events/delegate/delegate\n * @signature `events.addDelegateListener(eventType, selector, handler)`\n * @param {String} eventType The type of the event to virtually bind to delegates\n * @param {String} selector  A CSS selector that matches all intended delegates\n * @param {function(event)} handler   The function to call when the event is dispatched\n *\n * Add an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\n * matching child nodes (\"delegates\") for which the event should fire.\n *\n * Delegate events are limited to firing in the bubble phase.\n */\ndomEvents.addDelegateListener = function(eventType, selector, handler) {\n\n\n\tvar events = domData.get.call(this, dataName),\n\t\teventTypeEvents;\n\n\tif (!events) {\n\t\tdomData.set.call(this, dataName, events = {});\n\t}\n\n\t// if the first of that event type, bind\n\tif (!(eventTypeEvents = events[eventType])) {\n\t\teventTypeEvents = events[eventType] = {};\n\t\tdomEvents.addEventListener.call(this, eventType, handleEvent, useCapture(eventType));\n\t}\n\n\tif (!eventTypeEvents[selector]) {\n\t\teventTypeEvents[selector] = [];\n\t}\n\n\teventTypeEvents[selector].push({\n\t\thandler: handler,\n\t\tselector: selector\n\t});\n\n};\n\n/**\n * @function can-util/dom/events/delegate/delegate.removeDelegateListener events.removeDelegateListener\n * @parent can-util/dom/events/delegate/delegate\n * @signature `events.removeDelegateListener(eventType, selector, handler)`\n * @param {String} eventType The type of the event to unbind\n * @param {String} selector  A CSS selector that matches a delegate selector added for this event type\n * @param {function(event)} handler   The function bound as handler when the listener was added\n *\n * Remove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n */\ndomEvents.removeDelegateListener = function(eventType, selector, handler) {\n\tvar events = domData.get.call(this, dataName);\n\n\tif (events[eventType] && events[eventType][selector]) {\n\t\tvar eventTypeEvents = events[eventType],\n\t\t\tdelegates = eventTypeEvents[selector],\n\t\t\ti = 0;\n\n\t\t// remove the matching eventType/selector/handler\n\t\twhile (i < delegates.length) {\n\t\t\tif (delegates[i].handler === handler) {\n\t\t\t\tdelegates.splice(i, 1);\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t// if there are no more selectors, remove the selector\n\t\tif(delegates.length === 0) {\n\t\t\tdelete eventTypeEvents[selector];\n\t\t\t// if there are no more events for that eventType, unbind\n\t\t\tif(isEmptyObject(eventTypeEvents)) {\n\t\t\t\tdomEvents.removeEventListener.call(this, eventType, handleEvent, useCapture(eventType));\n\t\t\t\tdelete events[eventType];\n\t\t\t\tif(isEmptyObject(events)) {\n\t\t\t\t\tdomData.clean.call(this, dataName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/delegate/delegate.js\n// module id = 61\n// module chunks = 0","'use strict';\n\nvar makeMutationEvent = require(\"../make-mutation-event/make-mutation-event\");\n\n/**\n * @module {events} can-util/dom/events/inserted/inserted inserted\n * @parent can-util/dom/events/events\n *  \n * This event fires when the bound element is added to the DOM.\n *\n * ```js\n * var events = require(\"can-util/dom/events/events\");\n * require(\"can-util/dom/events/inserted/inserted\");\n *\n * var foo = document.createElement(\"div\");\n *\n * var log = function() { console.log(\"inserted event fired\"); }\n * events.addEventListener.call(foo, \"inserted\", log);\n *\n * document.body.appendChild(foo); // inserted event fired\n */\nmakeMutationEvent(\"inserted\", \"addedNodes\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/inserted/inserted.js\n// module id = 62\n// module chunks = 0","'use strict';\n\n// This sets up an inserted event to work through mutation observers if\n// mutation observers are present.  If they aren't you have to use\n// the mutate methods.\nvar events = require(\"../events\");\nvar domData = require(\"../../data/data\");\nvar getMutationObserver = require(\"../../mutation-observer/mutation-observer\");\nvar domDispatch = require(\"../../dispatch/dispatch\");\nvar mutationDocument = require(\"../../mutation-observer/document/document\");\nvar getDocument = require(\"../../document/document\");\nvar CIDMap = require(\"../../../js/cid-map/cid-map\");\nvar string = require(\"../../../js/string/string\");\n\nrequire(\"../../is-of-global-document/is-of-global-document\");\n\n/**\n * @module {Function} can-util/dom/events/make-mutation-event/make-mutation-event makeMutationEvent\n * @parent can-util/dom/events/events\n *\n * @signature `makeMutationEvent(specialEventName, mutationNodesProperty)`\n *\n * @param {String} specialEventName the event to handle as a mutation observer-based event\n * @param {String} mutationNodesProperty the property of interest in a DOM mutation\n *\n * This function provides a simple interface to bind the DOM events interface to the mutation\n * observer interface, by firing an event when a matching mutation is generated by the client\n */\nmodule.exports = function(specialEventName, mutationNodesProperty){\n\tvar originalAdd = events.addEventListener,\n\t\toriginalRemove = events.removeEventListener;\n\n\tevents.addEventListener = function(eventName){\n\t\t// on an inserted event\n\t\t// if it's the first inserted event, we'll register a handler to the\n\t\t// mutationDocument singleton.  This will take nodes that are added\n\t\t// and fire add / remove events.\n\t\tif(eventName === specialEventName && getMutationObserver()) {\n\t\t\tvar documentElement = getDocument().documentElement;\n\t\t\tvar specialEventData = domData.get.call(documentElement,specialEventName+\"Data\");\n\t\t\tif(!specialEventData) {\n\t\t\t\tspecialEventData = {\n\t\t\t\t\thandler: function(mutatedNode){\n\t\t\t\t\t\t// keeps track of elements that have already been checked\n\t\t\t\t\t\t// so we don't double check (a parent and then a child added to the parent)\n\t\t\t\t\t\tif(specialEventData.nodeIdsRespondingToInsert.has(mutatedNode)) {\n\t\t\t\t\t\t\tdomDispatch.call(mutatedNode, specialEventName, [], false);\n\t\t\t\t\t\t\tspecialEventData.nodeIdsRespondingToInsert.delete(mutatedNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tnodeIdsRespondingToInsert: new CIDMap()\n\t\t\t\t};\n\t\t\t\tmutationDocument[\"on\" + string.capitalize(mutationNodesProperty)](specialEventData.handler);\n\t\t\t\tdomData.set.call(documentElement, specialEventName+\"Data\", specialEventData);\n\t\t\t}\n\n\t\t\t// count the number of handlers for this event\n\t\t\tvar count = specialEventData.nodeIdsRespondingToInsert.get(this) || 0;\n\t\t\tspecialEventData.nodeIdsRespondingToInsert.set(this, count + 1);\n\t\t}\n\t\treturn originalAdd.apply(this, arguments);\n\n\t};\n\n\tevents.removeEventListener = function(eventName){\n\t\tif(eventName === specialEventName && getMutationObserver() ) {\n\t\t\tvar documentElement = getDocument().documentElement;\n\t\t\tvar specialEventData = domData.get.call(documentElement, specialEventName+\"Data\");\n\t\t\tif(specialEventData) {\n\t\t\t\tvar newCount = specialEventData.nodeIdsRespondingToInsert.get(this) - 1;\n\n\t\t\t\t// if there is still at least one handler for this event, update the count\n\t\t\t\t// otherwise remove this element from the CIDMap\n\t\t\t\tif (newCount) {\n\t\t\t\t\tspecialEventData.nodeIdsRespondingToInsert.set(this, newCount);\n\t\t\t\t} else {\n\t\t\t\t\tspecialEventData.nodeIdsRespondingToInsert.delete(this);\n\t\t\t\t}\n\n\t\t\t\tif(!specialEventData.nodeIdsRespondingToInsert.size) {\n\t\t\t\t\tmutationDocument[\"off\" + string.capitalize(mutationNodesProperty)](specialEventData.handler);\n\t\t\t\t\tdomData.clean.call(documentElement, specialEventName+\"Data\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn originalRemove.apply(this, arguments);\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/make-mutation-event/make-mutation-event.js\n// module id = 63\n// module chunks = 0","'use strict';\n\nvar getDocument = require(\"../../document/document\");\nvar domDataCore = require(\"../../data/core\");\nvar MUTATION_OBSERVER = require(\"../../mutation-observer/mutation-observer\");\nvar each = require(\"../../../js/each/each\");\nvar CIDStore = require(\"../../../js/cid-set/cid-set\");\nvar makeArray = require(\"../../../js/make-array/make-array\");\nvar string = require(\"../../../js/string/string\");\n\nvar dispatchIfListening = function(mutatedNode, nodes, dispatched){\n\tif(dispatched.has(mutatedNode)) {\n\t\treturn true;\n\t}\n\tdispatched.add(mutatedNode);\n\n\tif(nodes.name === \"removedNodes\") {\n\t\tvar documentElement = getDocument().documentElement;\n\t\tif(documentElement.contains(mutatedNode)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tnodes.handlers.forEach(function(handler){\n\t\thandler(mutatedNode);\n\t});\n\tnodes.afterHandlers.forEach(function(handler){\n\t\thandler(mutatedNode);\n\t});\n};\n\nvar mutationObserverDocument = {\n\tadd: function(handler) {\n\t\tvar MO = MUTATION_OBSERVER();\n\t\tif (MO) {\n\t\t\tvar documentElement = getDocument().documentElement;\n\t\t\tvar globalObserverData = domDataCore.get.call(documentElement, \"globalObserverData\");\n\t\t\tif(!globalObserverData) {\n\t\t\t\tvar observer = new MO(function (mutations) {\n\t\t\t\t\tglobalObserverData.handlers.forEach(function(handler){\n\t\t\t\t\t\thandler(mutations);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tobserver.observe(documentElement, {childList: true, subtree: true});\n\n\t\t\t\tglobalObserverData = {\n\t\t\t\t\tobserver: observer,\n\t\t\t\t\thandlers: []\n\t\t\t\t};\n\t\t\t\tdomDataCore.set.call(documentElement, \"globalObserverData\", globalObserverData);\n\t\t\t}\n\t\t\tglobalObserverData.handlers.push(handler);\n\t\t}\n\t},\n\tremove: function(handler){\n\t\tvar documentElement = getDocument().documentElement;\n\t\tvar globalObserverData = domDataCore.get.call(documentElement, \"globalObserverData\");\n\t\tif(globalObserverData) {\n\t\t\tvar index = globalObserverData.handlers.indexOf(handler);\n\t\t\tif(index >= 0) {\n\t\t\t\tglobalObserverData.handlers.splice(index, 1);\n\t\t\t}\n\t\t\tif(globalObserverData.handlers.length === 0 ){\n\t\t\t\tglobalObserverData.observer.disconnect();\n\t\t\t\tdomDataCore.clean.call(documentElement, \"globalObserverData\");\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar makeMutationMethods = function(name) {\n\tvar mutationName = name.toLowerCase() + \"Nodes\";\n\n\tvar getMutationData = function() {\n\t\tvar documentElement = getDocument().documentElement;\n\t\tvar mutationData = domDataCore.get.call(documentElement, mutationName + \"MutationData\");\n\n\t\tif(!mutationData) {\n\t\t\tmutationData = {\n\t\t\t\tname: mutationName,\n\t\t\t\thandlers: [],\n\t\t\t\tafterHandlers: [],\n\t\t\t\thander: null\n\t\t\t};\n\t\t\tif (MUTATION_OBSERVER()) {\n\t\t\t\tdomDataCore.set.call(documentElement, mutationName + \"MutationData\", mutationData);\n\t\t\t}\n\t\t}\n\t\treturn mutationData;\n\t};\n\n\tvar setup = function() {\n\t\tvar mutationData = getMutationData();\n\n\t\tif( mutationData.handlers.length === 0 || mutationData.afterHandlers.length === 0 ) {\n\t\t\tmutationData.handler = function(mutations){\n\t\t\t\tvar dispatched = new CIDStore();\n\n\t\t\t\tmutations.forEach(function(mutation){\n\t\t\t\t\teach(mutation[mutationName], function(mutatedNode){\n\t\t\t\t\t\tvar children = mutatedNode.getElementsByTagName && makeArray( mutatedNode.getElementsByTagName(\"*\") );\n\n\t\t\t\t\t\tvar alreadyChecked = dispatchIfListening(mutatedNode, mutationData, dispatched);\n\t\t\t\t\t\tif(children && !alreadyChecked) {\n\t\t\t\t\t\t\tfor (var j = 0, child;\n\t\t\t\t\t\t\t\t(child = children[j]) !== undefined; j++) {\n\t\t\t\t\t\t\t\tdispatchIfListening(child, mutationData, dispatched);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\t\t\tthis.add(mutationData.handler);\n\t\t}\n\t\treturn mutationData;\n\t};\n\n\tvar teardown = function() {\n\t\tvar documentElement = getDocument().documentElement;\n\t\tvar mutationData = getMutationData();\n\t\tif( mutationData.handlers.length === 0 && mutationData.afterHandlers.length === 0 ) {\n\t\t\tthis.remove(mutationData.handler);\n\t\t\tdomDataCore.clean.call(documentElement, mutationName + \"MutationData\");\n\t\t}\n\t};\n\n\tvar createOnOffHandlers = function(name, handlerList) {\n\t\tmutationObserverDocument[\"on\" + name] = function(handler) {\n\t\t\tvar mutationData = setup.call(this);\n\t\t\tmutationData[handlerList].push(handler);\n\t\t};\n\n\t\tmutationObserverDocument[\"off\" + name] = function(handler) {\n\t\t\tvar mutationData = getMutationData();\n\t\t\tvar index = mutationData[handlerList].indexOf(handler);\n\t\t\tif(index >=0 ) {\n\t\t\t\tmutationData[handlerList].splice(index, 1);\n\t\t\t}\n\t\t\tteardown.call(this);\n\t\t};\n\t};\n\n\tvar createHandlers = function(name) {\n\t\tcreateOnOffHandlers(name, \"handlers\");\n\t\tcreateOnOffHandlers(\"After\" + name, \"afterHandlers\");\n\t};\n\n\tcreateHandlers(string.capitalize(mutationName));\n};\n\nmakeMutationMethods(\"added\");\nmakeMutationMethods(\"removed\");\n\nmodule.exports = mutationObserverDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/mutation-observer/document/document.js\n// module id = 64\n// module chunks = 0","'use strict';\n\n// Returns `true` if the object can have properties (no `null`s).\nmodule.exports = function (current) {\n    return /^f|^o/.test(typeof current);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-container/is-container.js\n// module id = 65\n// module chunks = 0","'use strict';\n\nvar types = require(\"can-types\");\n\nmodule.exports = function(obj) {\n\treturn obj && !!obj[types.iterator];\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-iterable/is-iterable.js\n// module id = 66\n// module chunks = 0","\"use strict\";\nvar domData = require('can-util/dom/data/data');\nvar SimpleMap = require('can-simple-map');\nvar types = require(\"can-types\");\nvar ns = require(\"can-namespace\");\nvar getDocument = require(\"can-util/dom/document/document\");\nvar isArrayLike = require('can-util/js/is-array-like/is-array-like');\nmodule.exports = ns.viewModel = function (el, attr, val) {\n\tvar scope ;\n\tif (typeof el === 'string') {\n\t\tel = getDocument().querySelector(el);\n\t} else if (isArrayLike(el) && !el.nodeType) {\n\t\tel= el[0];\n\t}\n\n\tif (types.isMapLike(attr)) {\n\t\treturn domData.set.call( el, \"viewModel\", attr);\n\t}\n\n\tscope = domData.get.call(el, \"viewModel\");\n\tif(!scope) {\n\t\tscope = types.DefaultMap ? new types.DefaultMap() : new SimpleMap();\n\t\tdomData.set.call(el, \"viewModel\", scope);\n\t}\n\tswitch (arguments.length) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\treturn scope;\n\t\tcase 2:\n\t\t\treturn \"attr\" in scope ? scope.attr(attr) : scope[attr];\n\t\tdefault:\n\t\t\tif(\"attr\" in scope) {\n\t\t\t\tscope.attr(attr, val);\n\t\t\t} else {\n\t\t\t\tscope[attr] = val;\n\t\t\t}\n\t\t\treturn el;\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-model/can-view-model.js\n// module id = 67\n// module chunks = 0","/* jshint maxdepth:7 */\n/* jshint latedef:false */\nvar childNodes = require('can-util/dom/child-nodes/child-nodes');\nvar domAttr = require('can-util/dom/attr/attr');\nvar each = require('can-util/js/each/each');\nvar makeArray = require('can-util/js/make-array/make-array');\nvar getDocument = require('can-util/dom/document/document');\nvar domMutate = require('can-util/dom/mutate/mutate');\nvar namespace = require('can-namespace');\nvar MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');\n\n// if an object or a function\n// convert into what it should look like\n// then the modification can happen in place\n// but it has to have more than the current node\n// blah!\nvar processNodes = function(nodes, paths, location, document){\n\tvar frag = document.createDocumentFragment();\n\n\tfor(var i = 0, len = nodes.length; i < len; i++) {\n\t\tvar node = nodes[i];\n\t\tfrag.appendChild( processNode(node,paths,location.concat(i), document) );\n\t}\n\treturn frag;\n},\n\tkeepsTextNodes =  typeof document !== \"undefined\" && (function(){\n\t\tvar testFrag = document.createDocumentFragment();\n\t\tvar div = document.createElement(\"div\");\n\n\t\tdiv.appendChild(document.createTextNode(\"\"));\n\t\tdiv.appendChild(document.createTextNode(\"\"));\n\t\ttestFrag.appendChild(div);\n\n\t\tvar cloned  = testFrag.cloneNode(true);\n\n\t\treturn childNodes(cloned.firstChild).length === 2;\n\t})(),\n\tclonesWork = typeof document !== \"undefined\" && (function(){\n\t\t// Since html5shiv is required to support custom elements, assume cloning\n\t\t// works in any browser that doesn't have html5shiv\n\n\t\t// Clone an element containing a custom tag to see if the innerHTML is what we\n\t\t// expect it to be, or if not it probably was created outside of the document's\n\t\t// namespace.\n\t\tvar el = document.createElement('a');\n\t\tel.innerHTML = \"<xyz></xyz>\";\n\t\tvar clone = el.cloneNode(true);\n\t\tvar works = clone.innerHTML === \"<xyz></xyz>\";\n\t\tvar MO, observer;\n\n\t\tif(works) {\n\t\t\t// Cloning text nodes with dashes seems to create multiple nodes in IE11 when\n\t\t\t// MutationObservers of subtree modifications are used on the documentElement.\n\t\t\t// Since this is not what we expect we have to include detecting it here as well.\n\t\t\tel = document.createDocumentFragment();\n\t\t\tel.appendChild(document.createTextNode('foo-bar'));\n\n\t\t\tMO = MUTATION_OBSERVER();\n\n\t\t\tif (MO) {\n\t\t\t\tobserver = new MO(function() {});\n\t\t\t\tobserver.observe(document.documentElement, { childList: true, subtree: true });\n\n\t\t\t\tclone = el.cloneNode(true);\n\n\t\t\t\tobserver.disconnect();\n\t\t\t} else {\n\t\t\t\tclone = el.cloneNode(true);\n\t\t\t}\n\n\t\t\treturn clone.childNodes.length === 1;\n\t\t}\n\n\t\treturn works;\n\t})(),\n\tnamespacesWork = typeof document !== \"undefined\" && !!document.createElementNS;\n\n/**\n * @function cloneNode\n * @hide\n *\n * A custom cloneNode function to be used in browsers that properly support cloning\n * of custom tags (IE8 for example). Fixes it by doing some manual cloning that\n * uses innerHTML instead, which has been shimmed.\n *\n * @param {DocumentFragment} frag A document fragment to clone\n * @return {DocumentFragment} a new fragment that is a clone of the provided argument\n */\nvar cloneNode = clonesWork ?\n\tfunction(el){\n\t\treturn el.cloneNode(true);\n\t} :\n\tfunction(node){\n\t\tvar document = node.ownerDocument;\n\t\tvar copy;\n\n\t\tif(node.nodeType === 1) {\n\t\t\tcopy = document.createElement(node.nodeName);\n\t\t} else if(node.nodeType === 3){\n\t\t\tcopy = document.createTextNode(node.nodeValue);\n\t\t} else if(node.nodeType === 8) {\n\t\t\tcopy = document.createComment(node.nodeValue);\n\t\t} else if(node.nodeType === 11) {\n\t\t\tcopy = document.createDocumentFragment();\n\t\t}\n\n\t\tif(node.attributes) {\n\t\t\tvar attributes = makeArray(node.attributes);\n\t\t\teach(attributes, function (node) {\n\t\t\t\tif(node && node.specified) {\n\t\t\t\t\tdomAttr.setAttribute(copy, node.nodeName || node.name, node.nodeValue || node.value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif(node && node.firstChild) {\n\t\t\tvar child = node.firstChild;\n\n\t\t\twhile(child) {\n\t\t\t\tcopy.appendChild( cloneNode(child) );\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn copy;\n\t};\n\nfunction processNode(node, paths, location, document){\n\tvar callback,\n\t\tloc = location,\n\t\tnodeType = typeof node,\n\t\tel,\n\t\tp,\n\t\ti , len;\n\tvar getCallback = function(){\n\t\tif(!callback) {\n\t\t\tcallback  = {\n\t\t\t\tpath: location,\n\t\t\t\tcallbacks: []\n\t\t\t};\n\t\t\tpaths.push(callback);\n\t\t\tloc = [];\n\t\t}\n\t\treturn callback;\n\t};\n\n\tif(nodeType === \"object\") {\n\t\tif( node.tag ) {\n\t\t\tif(namespacesWork && node.namespace) {\n\t\t\t\tel = document.createElementNS(node.namespace, node.tag);\n\t\t\t} else {\n\t\t\t\tel = document.createElement(node.tag);\n\t\t\t}\n\n\t\t\tif(node.attrs) {\n\t\t\t\tfor(var attrName in node.attrs) {\n\t\t\t\t\tvar value = node.attrs[attrName];\n\t\t\t\t\tif(typeof value === \"function\"){\n\t\t\t\t\t\tgetCallback().callbacks.push({\n\t\t\t\t\t\t\tcallback:  value\n\t\t\t\t\t\t});\n\t\t\t\t\t} else  {\n\t\t\t\t\t\tdomAttr.setAttribute(el, attrName, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(node.attributes) {\n\t\t\t\tfor(i = 0, len = node.attributes.length; i < len; i++ ) {\n\t\t\t\t\tgetCallback().callbacks.push({callback: node.attributes[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(node.children && node.children.length) {\n\t\t\t\t// add paths\n\t\t\t\tif(callback) {\n\t\t\t\t\tp = callback.paths = [];\n\t\t\t\t} else {\n\t\t\t\t\tp = paths;\n\t\t\t\t}\n\n\t\t\t\tel.appendChild( processNodes(node.children, p, loc, document) );\n\t\t\t}\n\t\t} else if(node.comment) {\n\t\t\tel = document.createComment(node.comment);\n\n\t\t\tif(node.callbacks) {\n\t\t\t\tfor(i = 0, len = node.attributes.length; i < len; i++ ) {\n\t\t\t\t\tgetCallback().callbacks.push({callback: node.callbacks[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t} else if(nodeType === \"string\"){\n\n\t\tel = document.createTextNode(node);\n\n\t} else if(nodeType === \"function\") {\n\n\t\tif(keepsTextNodes) {\n\t\t\tel = document.createTextNode(\"\");\n\t\t\tgetCallback().callbacks.push({\n\t\t\t\tcallback: node\n\t\t\t});\n\t\t} else {\n\t\t\tel = document.createComment(\"~\");\n\t\t\tgetCallback().callbacks.push({\n\t\t\t\tcallback: function(){\n\t\t\t\t\tvar el = document.createTextNode(\"\");\n\t\t\t\t\tdomMutate.replaceChild.call(this.parentNode, el, this);\n\t\t\t\t\treturn node.apply(el,arguments );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t}\n\treturn el;\n}\n\nfunction getCallbacks(el, pathData, elementCallbacks){\n\tvar path = pathData.path,\n\t\tcallbacks = pathData.callbacks,\n\t\tpaths = pathData.paths,\n\t\tchild = el,\n\t\tpathLength = path ? path.length : 0,\n\t\tpathsLength = paths ? paths.length : 0;\n\n\tfor(var i = 0; i < pathLength; i++) {\n\t\tchild = child.childNodes.item(path[i]);\n\t}\n\n\tfor( i= 0 ; i < pathsLength; i++) {\n\t\tgetCallbacks(child, paths[i], elementCallbacks);\n\t}\n\n\telementCallbacks.push({element: child, callbacks: callbacks});\n}\n\nfunction hydrateCallbacks(callbacks, args) {\n\tvar len = callbacks.length,\n\t\tcallbacksLength,\n\t\tcallbackElement,\n\t\tcallbackData;\n\n\tfor(var i = 0; i < len; i++) {\n\t\tcallbackData = callbacks[i];\n\t\tcallbacksLength = callbackData.callbacks.length;\n\t\tcallbackElement = callbackData.element;\n\t\tfor(var c = 0; c < callbacksLength; c++) {\n\t\t\tcallbackData.callbacks[c].callback.apply(callbackElement, args);\n\t\t}\n\t}\n}\n\nfunction makeTarget(nodes, doc){\n\tvar paths = [];\n\tvar frag = processNodes(nodes, paths, [], doc || getDocument());\n\treturn {\n\t\tpaths: paths,\n\t\tclone: frag,\n\t\thydrate: function(){\n\t\t\tvar cloned = cloneNode(this.clone);\n\t\t\tvar args = makeArray(arguments);\n\n\t\t\tvar callbacks = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tgetCallbacks(cloned, paths[i], callbacks);\n\t\t\t}\n\t\t\thydrateCallbacks(callbacks, args);\n\n\t\t\treturn cloned;\n\t\t}\n\t};\n}\nmakeTarget.keepsTextNodes = keepsTextNodes;\nmakeTarget.cloneNode = cloneNode;\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.target = makeTarget;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-target/can-view-target.js\n// module id = 68\n// module chunks = 0","import {makeSentenceCase} from '../string/string';\r\nimport stache from 'can-stache';\r\nimport DefineMap from 'can-define/map/map';\r\nimport DefineList from 'can-define/list/list';\r\nimport dev from 'can-util/js/dev/dev';\r\n\r\n/**\r\n * Built in field templates. If `fieldType` is specified on a field, the\r\n * template listed here will be used. Otherwise, `formTemplate` should be\r\n * provided for custom field templates.\r\n *  - text: `<text-field />` component\r\n *  - select: `<select-field />` component\r\n *  - file: `<file-field />` component\r\n *  - json: `<json-field />` component\r\n *  - subform: `<subform-field />` component\r\n *  - date: `<date-field />` component\r\n *  - checkbox: `<checkbox-field />` component\r\n * @property {Object} util/field/Field.TEMPLATES Built-in Templates\r\n * @parent util/field.guides\r\n */\r\nexport const TEMPLATES = {\r\n    text: '<text-field {properties}=\".\" (fieldchange)=\"setField\" value=\"{{formObject[name]}}\" {errors}=\"validationErrors\" />', // string\r\n    select: '<select-field {properties}=\".\" (fieldchange)=\"setField\" value=\"{{formObject[name]}}\" {errors}=\"validationErrors\" />', // string\r\n    file: '<file-field {properties}=\".\" (fieldchange)=\"setField\" value=\"{{formObject[name]}}\" {errors}=\"validationErrors\" />', // string\r\n    json: '<json-field {properties}=\".\" (fieldchange)=\"setField\" {value}=\"formObject[name]\" {errors}=\"validationErrors\" />', // string\r\n    subform: '<subform-field {properties}=\".\" (fieldchange)=\"setField\" {value}=\"formObject[name]\" {errors}=\"validationErrors\" />', // string\r\n    date: '<date-field {properties}=\".\" (fieldchange)=\"setField\" {value}=\"formObject[name]\" {errors}=\"validationErrors\" />', // date object\r\n    checkbox: '<checkbox-field (fieldchange)=\"setField\" value=\"{{formObject[name]}}\" {errors}=\"validationErrors\" {properties}=\".\" />'\r\n};\r\n\r\nconst displayTemplate = stache('{{object[field.name]}}');\r\n\r\n/**\r\n * @constructor util/field/Field Field\r\n * @parent util/field\r\n * @group util/field/Field.props Properties\r\n * @description Constructs a new field\r\n */\r\nexport const Field = DefineMap.extend('Field', {\r\n\r\n    // allow extra properties on this type\r\n    seal: false\r\n}, {\r\n    /**\r\n     * @prototype\r\n     */\r\n    /**\r\n     * The name of the property on the object, this field's name\r\n     * @property {String} util/field/Field.props.name name\r\n     * @parent util/field/Field.props\r\n     */\r\n    name: 'string',\r\n    /**\r\n     * A friendly name for the field used to display to the user\r\n     * The default is to capitalize the name and remove underscores\r\n     * @property {String} util/field/Field.props.alias alias\r\n     * @parent util/field/Field.props\r\n     */\r\n    alias: {\r\n        type: 'string',\r\n        get (alias) {\r\n            if (alias) {\r\n                return alias;\r\n            }\r\n            return makeSentenceCase(this.name);\r\n        }\r\n    },\r\n    /**\r\n     * The type of the form field to use when editing this field. These types\r\n     * are defined in the `util/field.TEMPLATES` constant. This should be\r\n     * omitted if a custom template is used.\r\n     * @property {String} util/field/Field.props.fieldType fieldType\r\n     * @parent util/field/Field.props\r\n     */\r\n    fieldType: {\r\n        type: 'string',\r\n        value: 'text'\r\n    },\r\n    /**\r\n     * The form field template to use when editing this field in the form-widget. This should be\r\n     * a template renderer. By default, this value is set to the\r\n     * template for the given `fieldType` property.\r\n     *\r\n     * The default renderers are provided as a constant, and may be referenced\r\n     * by passing the `field.fieldType` parameter. For instance, passing\r\n     * `fieldType: 'select'` will set `formTemplate` to the registered\r\n     * template for a `select-field` component.\r\n     *\r\n     * Custom templates can be created to add various field types and functionality\r\n     * to the form widget.\r\n     *\r\n     * The custom templates will have the following useful properties in their scope:\r\n     *  - `this`: (alias `.` is the current `this` object) the field properties object\r\n     *  - `setField`: the function to call when the field changes\r\n     *  - `formObject`: the form object\r\n     *  - `validationErrors`: An object with keys referencing the field name, and a string referencing a validation error\r\n     *\r\n     * For example:\r\n     * @property {Renderer} util/field/Field.props.formTemplate formTemplate\r\n     * @parent util/field/Field.props\r\n     */\r\n    formTemplate: {\r\n        type: '*',\r\n        get (template) {\r\n            if (template) {\r\n                if (typeof template === 'string') {\r\n                    template = stache(template);\r\n                }\r\n                return template;\r\n            }\r\n            const fType = this.fieldType;\r\n            if (!TEMPLATES.hasOwnProperty(fType)) {\r\n                dev.warn('No template for the given field type', fType);\r\n                return stache(TEMPLATES.text);\r\n            }\r\n            return stache(TEMPLATES[fType]);\r\n        }\r\n    },\r\n    /**\r\n     * @body\r\n     * Formats the field into a renderer in the list and details view of the\r\n     * data-admin component. The renderer has the scope of the\r\n     * list-table or property table. The simplest displayTemplate value would be\r\n     * the default, which is `object[field.name]`. (make sure to surround values with brackets)\r\n     *\r\n     * In this example,\r\n     * the scope of the table components provide access to each row as `object` and the\r\n     * current field as `field`.\r\n     *\r\n     * In addition, other properties can be accessed and combined by providing it\r\n     * `{{object.other_prop_name}}`. Custom helpers and other methods may also be\r\n     * registered and utilized. For instance, if we created a global helper\r\n     * `capitalize(property)` we could access it with `capitalize object.prop_name`.\r\n     *\r\n     * For a local helper, an additional method could be added to the field, like\r\n     * ```javascript\r\n     * {\r\n     * name: 'prop',\r\n     * alias: 'Property',\r\n     * capitalize: function(val){\r\n     *     return val.toUpperCase();\r\n     * }\r\n     * }\r\n     * ```\r\n     *\r\n     * In a stache template, this could be rendered using `field.capitalize(object.prop)`\r\n     * @property {Renderer} util/field/Field.props.displayTemlpate displayTemplate\r\n     * @parent util/field/Field.props\r\n     */\r\n    displayTemplate: {\r\n        value: function () {\r\n            return displayTemplate;\r\n        },\r\n        type (val) {\r\n            if (typeof val === 'string') {\r\n                return stache(val);\r\n            }\r\n            return val;\r\n        }\r\n    },\r\n    /**\r\n     * Includes this field in the list view in the data-admin\r\n     * @property {Boolean} util/field/Field.props.list list\r\n     * @parent util/field/Field.props\r\n     */\r\n    list: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * Includes this field in the details view in the data-admin\r\n     * @property {Boolean} util/field/Field.props.detail detail\r\n     * @parent util/field/Field.props\r\n     */\r\n    detail: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * Includes this field in the edit view in the data-admin\r\n     * @property {Boolean} util/field/Field.props.edit edit\r\n     * @parent util/field/Field.props\r\n     */\r\n    edit: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * Includes this field in the filter widget's fields.\r\n     * @property {Boolean} util/field/Field.props.filter filter\r\n     * @parent util/field/Field.props\r\n     */\r\n    filter: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * Includes this field in the sorting capability\r\n     * @property {Boolean} util/field/Field.props.sort sort\r\n     * @parent util/field/Field.props\r\n     */\r\n    sort: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * Validates a property and returns a string if the field is invalid\r\n     * @property {Function} util/field/Field.props.validate validate\r\n     * @signature `validate(props)`\r\n     * @param {util/field.ValidationObject} props A special object consisting of information about the current value and dirty state of the form object\r\n     * @return {String|falsey} a string error message if the value is not valid or undefined if there is no error message\r\n     * @parent util/field/Field.props\r\n     */\r\n    validate: {\r\n        value: null\r\n    },\r\n    /**\r\n     * A boolean flag to display form field inline with others and hide labels\r\n     * @property {Boolean} util/field/Field.props.inline inline\r\n     * @parent util/field/Field.props\r\n     */\r\n    inline: 'boolean',\r\n    /**\r\n     * Text to display when the field is empty (like a textbox). Doesn't apply to\r\n     * some fields, like select or date fields.\r\n     * @property {String} util/field/Field.props.placeholder placeholder\r\n     * @parent util/field/Field.props\r\n     */\r\n    placeholder: 'string',\r\n    /**\r\n     * Adds css classes to the table cells and headings. Selectors should use\r\n     * `th.classname` and `td.classname`\r\n     * @property {String} util/field/Field.props.classes classes\r\n     * @parent util/field/Field.props\r\n     */\r\n    classes: 'string'\r\n});\r\n\r\n\r\nexport const FieldList = DefineList.extend('FieldList', {\r\n    '#': Field\r\n});\r\n\r\nexport default Field;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/util/field/Field.js\n// module id = 69\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 70\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 71\n// module chunks = 0","import { esriPromise } from 'esri-promise';\nimport { Promise } from 'es6-promise';\nimport BoilerFactory from './boilerplate/boilerplate';\nimport ApplicationFactory from './application/application';\nimport './test';\n\nesriPromise([ // Get some info from configuration files with the dojo loader\n  'dojo/text!config/appConfig.json',\n  'dojo/text!config/boilerplateSettings.json'\n]).then(([appConfig, boilerplateSettings]) => { // esri-promise resolves with our requested modules as an array\n  ApplicationFactory().then((AppInstance) => {  // make an instance of application\n    BoilerFactory(JSON.parse(appConfig), JSON.parse(boilerplateSettings)) // make an instance of boilerplate\n    .then((BoilerInstance) => {\n      BoilerInstance.init() // initialize the boilerplate --> this returns a promise that resolves with the info we need to boot up our app\n      .then((boilerplateResponse) => {\n        AppInstance.init(boilerplateResponse);  // initialize the application\n      })\n    }).catch(Promise.reject)\n  }).catch(Promise.reject)\n}).catch((err) => {\n  console.error(err);  // If an error occurs at any of these steps, we'd like to see what it is!\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/ts/app.ts","import '../../css/index.scss';\n\nimport { esriPromise } from 'esri-promise';\nimport { Promise } from 'es6-promise';\nimport ItemHelperFactory from \"../boilerplate/ItemHelper\";\nimport UrlParamHelperFactory from \"../boilerplate/UrlParamHelper\";\nimport { BoilerplateResults, BoilerplateResponse, Settings, GroupData, Config, UrlParamHelperInterface, ItemHelperInterface, ApplicationInterface } from '../interfaces';\n\nconst CSS = {\n  loading: \"boilerplate--loading\",\n  error: \"boilerplate--error\",\n  errorIcon: \"esri-icon-notice-round\"\n};\n\nexport default (): Promise<ApplicationInterface> => esriPromise([\n  'dojo/_base/lang', 'dojo/dom', 'dojo/dom-attr', 'dojo/domReady!',\n  'esri/views/MapView', 'esri/views/SceneView', 'esri/widgets/Search',\n  'esri/WebMap', 'esri/WebScene', 'dojo/i18n!config/nls/resources'\n]).then(([\n  lang, dom, domAttr, domClass,\n  MapView, SceneView, Search,\n  WebMap, WebScene, i18n\n]) => {\n\n  class Application implements ApplicationInterface {\n    config: Config = null;\n    direction: any = null;\n    settings: Settings = null;\n    urlParamHelper = null;\n    itemHelper = null;\n\n    public init(boilerplateResponse: BoilerplateResponse): void {\n      if (boilerplateResponse) {\n        this.direction = boilerplateResponse.direction;\n        this.config = boilerplateResponse.config;\n        this.settings = boilerplateResponse.settings;\n        const boilerplateResults = boilerplateResponse.results;\n        const webMapItem = boilerplateResults.webMapItem;\n        const webSceneItem = boilerplateResults.webSceneItem;\n        const groupData = boilerplateResults.group;\n\n        document.documentElement.lang = boilerplateResponse.locale;\n\n        ItemHelperFactory().then((instance) => {\n          this.itemHelper = instance;\n        })\n        .catch((err) => {\n          throw err;\n        }).then(UrlParamHelperFactory).then((instance) => {\n          this.urlParamHelper = instance;\n        }).catch((err) => {\n          throw err;\n        }).then(() => {\n\n          this._setDirection();\n\n          if (webMapItem) {\n            this._createWebMap(webMapItem);\n          }\n          else if (webSceneItem) {\n            this._createWebScene(webSceneItem);\n          }\n          else if (groupData) {\n            this._createGroupGallery(groupData);\n          }\n          else {\n            this.reportError(new Error(\"app:: Could not load an item to display\"));\n          }\n        }).catch((err) => {\n          throw(err);\n        });\n      }\n      else {\n        this.reportError(new Error(\"app:: Boilerplate is not defined\"));\n      }\n    }\n\n    public reportError(error) {\n      // remove loading class from body\n      document.body.removeAttribute('class');\n      document.body.className = CSS.error;\n      // an error occurred - notify the user. In this example we pull the string from the\n      // resource.js file located in the nls folder because we've set the application up\n      // for localization. If you don't need to support multiple languages you can hardcode the\n      // strings here and comment out the call in index.html to get the localization strings.\n      // set message\n      const node = dom.byId(\"loading_message\");\n      if (node) {\n        node.innerHTML = \"<h1><span class=\\\"\" + CSS.errorIcon + \"\\\"></span> \" + i18n.error + \"</h1><p>\" + error.message + \"</p>\";\n      }\n      return error;\n    }\n\n    private _setDirection() {\n      const direction = this.direction;\n      const dirNode = document.getElementsByTagName(\"html\")[0];\n      domAttr.set(dirNode, \"dir\", direction);\n    }\n\n    private _ready() {\n      document.body.removeAttribute('class');\n      document.title = this.config.title;\n    }\n\n    private _createWebMap(webMapItem) {\n      this.itemHelper.createWebMap(webMapItem).then((map: __esri.WebMap) => {\n\n        const viewProperties = {\n          map,\n          container: this.settings.webmap.containerId\n        };\n\n        if (!this.config.title && map.portalItem && map.portalItem.title) {\n          this.config.title = map.portalItem.title;\n        }\n\n        lang.mixin(viewProperties, this.urlParamHelper.getViewProperties(this.config));\n\n        const view = new MapView(viewProperties);\n\n        view.then((response) => {\n          this.urlParamHelper.addToView(view, this.config);\n\n          this._ready();\n\n        }, this.reportError);\n\n      }, this.reportError);\n    }\n\n    private _createWebScene(webSceneItem) {\n      this.itemHelper.createWebScene(webSceneItem).then((map: __esri.WebScene) => {\n\n        const viewProperties = {\n          map,\n          container: this.settings.webscene.containerId\n        };\n\n        if (!this.config.title && map.portalItem && map.portalItem.title) {\n          this.config.title = map.portalItem.title;\n        }\n\n        lang.mixin(viewProperties, this.urlParamHelper.getViewProperties(this.config));\n\n          const view = new SceneView(viewProperties);\n\n          view.then((response) => {\n            this.urlParamHelper.addToView(view, this.config);\n\n            this._ready();\n\n          }, this.reportError);\n\n      }, this.reportError);\n    }\n\n    private _createGroupGallery(groupData: GroupData) {\n      const groupInfoData = groupData.infoData;\n      const groupItemsData = groupData.itemsData;\n\n      if (!groupInfoData || !groupItemsData || groupInfoData.total === 0 || groupInfoData instanceof Error) {\n        this.reportError(new Error(\"app:: group data does not exist.\"));\n        return;\n      }\n\n      const info = groupInfoData.results[0];\n      const items = groupItemsData.results;\n\n      this._ready();\n\n      if (info && items) {\n        let html = \"\";\n\n        html += \"<h1>\" + info.title + \"</h1>\";\n\n        html += \"<ol>\";\n\n        items.forEach((item) => {\n          html += \"<li>\" + item.title + \"</li>\";\n        });\n\n        html += \"</ol>\";\n\n        document.body.innerHTML = html;\n      }\n    }\n  }\n\n  return Promise.resolve(new Application());\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/ts/application/application.ts","import { esriPromise } from 'esri-promise';\nimport { Promise } from 'es6-promise';\nimport { ItemHelperInterface } from '../interfaces';\n\ninterface Item {\n  data?: __esri.PortalItem | Error;\n  json?: {\n    itemData: any,\n    item: any\n  }\n}\n\nexport default (): Promise<ItemHelperInterface> => esriPromise([\n  'dojo/Deferred', 'dojo/promise/Promise',\n  'esri/WebMap', 'esri/WebScene',\n  'esri/portal/PortalItem'\n]).then(([\n  Deferred, DojoPromise,\n  WebMap, WebScene, PortalItem\n]) => {\n  \n  class ItemHelper implements ItemHelperInterface {\n    public createWebMap(item: Item): dojo.promise.Promise<__esri.WebMap> {\n      const deferred = new Deferred();\n      if (!item) {\n        deferred.reject(new Error(\"ItemHelper:: WebMap data does not exist.\"));\n      }\n      else if (item.data instanceof Error) {\n        deferred.reject(item.data);\n      }\n      else {\n        let wm;\n        if (item.data) {\n          wm = new WebMap({\n            portalItem: item.data\n          });\n        }\n        if (!wm) {\n          deferred.reject(new Error(\"ItemHelper:: WebMap does not have usable data.\"));\n        }\n        else {\n          deferred.resolve(wm);\n        }\n      }\n      return deferred.promise;\n    }\n\n    public createWebScene(item: Item): dojo.promise.Promise<__esri.WebScene> {\n      const deferred = new Deferred();\n      if (!item) {\n        deferred.reject(new Error(\"ItemHelper:: WebScene data does not exist.\"));\n      }\n      else if (item.data instanceof Error) {\n        deferred.reject(item.data);\n      }\n      else {\n        let ws;\n        if (item.data) {\n          ws = new WebScene({\n            portalItem: item.data\n          });\n        }\n        else if (item.json) {\n          ws = WebScene.fromJSON(item.json.itemData);\n          ws.portalItem = item.json.item;\n        }\n        if (!ws) {\n          deferred.reject(new Error(\"ItemHelper:: WebScene does not have usable data.\"));\n        }\n        else {\n          deferred.resolve(ws);\n        }\n      }\n      return deferred.promise;\n    }\n  }\n\n  return Promise.resolve(new ItemHelper());\n\n}).catch((err) => {\n  throw new Error(err)\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/ts/boilerplate/ItemHelper.ts","import { esriPromise } from 'esri-promise';\nimport { Promise } from 'es6-promise';\nimport { Config, UrlParamHelperInterface } from '../interfaces';\n\ninterface ViewProperties {\n  ui?: {\n    [propName: string]: any\n  }\n  camera?: __esri.Camera,\n  center?: __esri.Point,\n  zoom?: number,\n  extent?: __esri.Extent\n}\n\nconst DEFAULT_MARKER_SYMBOL = {\n  url: \"./symbols/mapPin.png\",\n  width: \"36px\",\n  height: \"19px\",\n  xoffset: \"9px\",\n  yoffset: \"18px\"\n};\n\nexport default (): Promise<UrlParamHelperInterface> => esriPromise([\n  'esri/Camera', 'esri/geometry/Extent', 'esri/geometry/Point',\n  'esri/widgets/Search', 'esri/Basemap', 'esri/layers/Layer',\n  'esri/core/promiseUtils', 'esri/Graphic', 'esri/PopupTemplate', 'esri/symbols/PictureMarkerSymbol',\n  'esri/views/MapView', 'esri/views/SceneView'\n]).then(([\n  Camera, Extent, Point,\n  Search, Basemap, Layer,\n  promiseList, Graphic, PopupTemplate, PictureMarkerSymbol,\n  MapView, SceneView\n]) => {\n\n  class UrlParamHelper {\n    public getViewProperties(config: Config): ViewProperties {\n      const viewProperties: ViewProperties = {};\n\n      if (config.components) {\n        viewProperties.ui = {\n          components: config.components.split(\",\")\n        };\n      }\n\n      const camera = this.viewPointStringToCamera(config.viewpoint);\n      if (camera) {\n        viewProperties.camera = camera;\n      }\n\n      const center = this.centerStringToPoint(config.center);\n      if (center) {\n        viewProperties.center = center;\n      }\n\n      const level = this.levelStringToLevel(config.level);\n      if (level) {\n        viewProperties.zoom = level;\n      }\n\n      const extent = this.extentStringToExtent(config.extent);\n      if (extent) {\n        viewProperties.extent = extent;\n      }\n\n      return viewProperties;\n    }\n\n    public addToView(view: __esri.MapView | __esri.SceneView, config, searchWidget?: __esri.Search) {\n      this.addMarkerToView(view, config.marker);\n      this.find(view, config.find, searchWidget);\n      this.setBasemapOnView(view, config.basemapUrl, config.basemapReferenceUrl);\n    }\n\n    public find(view: __esri.MapView | __esri.SceneView, findString, searchWidget?: __esri.Search) {\n      if (findString) {\n        if (searchWidget) {\n          searchWidget.search(findString);\n        }\n        else {\n          searchWidget = new Search({\n            view: view\n          });\n          searchWidget.search(findString);\n        }\n        return searchWidget;\n      }\n    }\n\n    public setBasemapOnView (view: __esri.MapView | __esri.SceneView, basemapUrl, basemapReferenceUrl) {\n      if (basemapUrl && view) {\n        const pl = promiseList.eachAlways({\n          baseLayer: Layer.fromArcGISServerUrl({\n            url: basemapUrl\n          }),\n          referenceLayer: Layer.fromArcGISServerUrl({\n            url: basemapReferenceUrl\n          })\n        });\n        pl.then((response) => {\n          if (response.baseLayer) {\n            const basemapOptions = {\n              baseLayers: response.baseLayer,\n              referenceLayers: null\n            };\n            if (response.referenceLayer) {\n              basemapOptions.referenceLayers = response.referenceLayer;\n            }\n            view.map.basemap = new Basemap(basemapOptions);\n          }\n        });\n      }\n    }\n\n    public viewPointStringToCamera(viewpointParamString: string): __esri.Camera {\n      const viewpointArray = viewpointParamString && viewpointParamString.split(\";\");\n      if (!viewpointArray || !viewpointArray.length) {\n        return;\n      }\n      else {\n        let cameraString = \"\";\n        let tiltHeading = \"\";\n        for (let i = 0; i < viewpointArray.length; i++) {\n          if (viewpointArray[i].indexOf(\"cam:\") !== -1) {\n            cameraString = viewpointArray[i];\n          }\n          else {\n            tiltHeading = viewpointArray[i];\n          }\n        }\n        if (cameraString !== \"\") {\n          cameraString = cameraString.substr(4, cameraString.length - 4);\n          const positionArray = cameraString.split(\",\");\n          if (positionArray.length >= 3) {\n            let x = 0,\n              y = 0,\n              z = 0;\n            x = parseFloat(positionArray[0]);\n            y = parseFloat(positionArray[1]);\n            z = parseFloat(positionArray[2]);\n            let wkid = 4326;\n            if (positionArray.length === 4) {\n              wkid = parseInt(positionArray[3], 10);\n            }\n\n            const cameraPosition = new Point({\n              x: x,\n              y: y,\n              z: z,\n              spatialReference: {\n                wkid: wkid\n              }\n            });\n\n            let heading = 0,\n              tilt = 0;\n            if (tiltHeading !== \"\") {\n              const tiltHeadingArray = tiltHeading.split(\",\");\n              if (tiltHeadingArray.length >= 0) {\n                heading = parseFloat(tiltHeadingArray[0]);\n                if (tiltHeadingArray.length > 1) {\n                  tilt = parseFloat(tiltHeadingArray[1]);\n                }\n              }\n            }\n\n            const camera = new Camera({\n              position: cameraPosition,\n              heading: heading,\n              tilt: tilt\n            });\n            return camera;\n          }\n        }\n      }\n    }\n\n    public extentStringToExtent(extentString: string): __esri.Extent {\n      if (extentString) {\n        //?extent=-13054125.21,4029134.71,-13032684.63,4041785.04,102100 or ?extent=-13054125.21;4029134.71;-13032684.63;4041785.04;102100\n        //?extent=-117.2672,33.9927,-117.0746,34.1064 or ?extent=-117.2672;33.9927;-117.0746;34.1064\n        const extentArray = this._splitArray(extentString);\n        if (extentArray.length === 4 || extentArray.length === 5) {\n          const xmin = parseFloat(extentArray[0]),\n            ymin = parseFloat(extentArray[1]),\n            xmax = parseFloat(extentArray[2]),\n            ymax = parseFloat(extentArray[3]);\n          if (!isNaN(xmin) && !isNaN(ymin) && !isNaN(xmax) && !isNaN(ymax)) {\n            let wkid = 4326;\n            if (extentArray.length === 5 && !isNaN(extentArray[4])) {\n              wkid = parseInt(extentArray[4], 10);\n            }\n            const ext = new Extent({\n              xmin: xmin,\n              ymin: ymin,\n              xmax: xmax,\n              ymax: ymax,\n              spatialReference: {\n                wkid: wkid\n              }\n            });\n            return ext;\n          }\n        }\n      }\n    }\n\n    public centerStringToPoint(centerString: string): __esri.Point {\n      //?center=-13044705.25,4036227.41,102113&level=12 or ?center=-13044705.25;4036227.41;102113&level=12\n      //?center=-117.1825,34.0552&level=12 or ?center=-117.1825;34.0552&level=12\n      if (centerString) {\n        const centerArray = this._splitArray(centerString);\n        if (centerArray.length === 2 || centerArray.length === 3) {\n          let x = parseFloat(centerArray[0]);\n          let y = parseFloat(centerArray[1]);\n          if (isNaN(x) || isNaN(y)) {\n            x = parseFloat(centerArray[0]);\n            y = parseFloat(centerArray[1]);\n          }\n          if (!isNaN(x) && !isNaN(y)) {\n            let wkid = 4326;\n            if (centerArray.length === 3 && !isNaN(centerArray[2])) {\n              wkid = parseInt(centerArray[2], 10);\n            }\n\n            const point = new Point({\n              x: x,\n              y: y,\n              spatialReference: {\n                wkid: wkid\n              }\n            });\n\n            return point;\n          }\n        }\n      }\n    }\n\n    public levelStringToLevel(levelString: string): number {\n      return levelString && parseInt(levelString, 10);\n    }\n\n    public addMarkerToView(view: __esri.MapView | __esri.SceneView, markerString: string): void {\n      // ?marker=-117;34;4326;My%20Title;http%3A//www.daisysacres.com/images/daisy_icon.gif;My%20location&level=10\n      // ?marker=-117,34,4326,My%20Title,http%3A//www.daisysacres.com/images/daisy_icon.gif,My%20location&level=10\n      // ?marker=-13044705.25,4036227.41,102100,My%20Title,http%3A//www.daisysacres.com/images/daisy_icon.gif,My%20location&level=10\n      // ?marker=-117,34,,My%20Title,http%3A//www.daisysacres.com/images/daisy_icon.gif,My%20location&level=10\n      // ?marker=-117,34,,,,My%20location&level=10\n      // ?marker=-117,34&level=10\n      // ?marker=10406557.402,6590748.134,2526\n      if (markerString) {\n        const markerArray = this._splitArray(markerString);\n        if (markerArray.length >= 2 &&\n          !isNaN(markerArray[0]) &&\n          !isNaN(markerArray[1])) {\n          const x = parseFloat(markerArray[0]),\n            y = parseFloat(markerArray[1]),\n            content = markerArray[3],\n            icon_url = markerArray[4],\n            label = markerArray[5];\n\n          let wkid = 4326;\n          if (!isNaN(markerArray[2])) {\n            wkid = parseInt(markerArray[2], 10);\n          }\n\n          let symbolOptions;\n\n          if (icon_url) {\n            symbolOptions = {\n              url: icon_url,\n              height: \"32px\",\n              width: \"32px\"\n            };\n          }\n          else {\n            symbolOptions = DEFAULT_MARKER_SYMBOL;\n          }\n\n          const markerSymbol = new PictureMarkerSymbol(symbolOptions);\n\n          const point = new Point({\n            \"x\": x,\n            \"y\": y,\n            \"spatialReference\": {\n              \"wkid\": wkid\n            }\n          });\n\n          let popupTemplate = null;\n          if (content || label) {\n            popupTemplate = new PopupTemplate({\n              \"title\": label || null,\n              \"content\": content || null\n            });\n          }\n\n          const graphic = new Graphic({\n            geometry: point,\n            symbol: markerSymbol,\n            popupTemplate: popupTemplate\n          });\n\n          if (graphic) {\n            view.graphics.add(graphic);\n            // view.goTo(graphic);\n          }\n        }\n      }\n    }\n\n    private _splitArray(value: string) {\n      let splitValues;\n      if (value) {\n        splitValues = value.split(\";\");\n        if (splitValues.length === 1) {\n          splitValues = value.split(\",\");\n        }\n      }\n      return splitValues;\n    }\n  }\n\n  return Promise.resolve(new UrlParamHelper());\n\n}).catch((err) => {\n  throw new Error(err);\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/ts/boilerplate/UrlParamHelper.ts","import { esriPromise } from 'esri-promise';\nimport { Promise } from 'es6-promise';\nimport { Settings, Config, BoilerplateResults, BoilerplateResponse, BoilerplateInterface } from '../interfaces';\n\nconst TAGS_RE = /<\\/?[^>]+>/g;\nconst URL_RE = /([^&=]+)=?([^&]*)(?:&+|$)/g;\nconst SHARING_PATH = \"/sharing\";\nconst ESRI_PROXY_PATH = \"/sharing/proxy\";\nconst ESRI_APPS_PATH = \"/apps/\";\nconst ESRI_HOME_PATH = \"/home/\";\nconst RTL_LANGS = [\"ar\", \"he\"];\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst LOCALSTORAGE_PREFIX = \"boilerplate_config_\";\nconst DEFAULT_URL_PARAM = \"default\";\n\nexport default (appSettings, boilerSettings): Promise<BoilerplateInterface> => esriPromise([\n  'dojo/_base/kernel', 'dojo/_base/lang', 'dojo/Deferred',\n  'esri/config', 'esri/core/promiseUtils',\n  'esri/identity/IdentityManager', 'esri/identity/OAuthInfo',\n  'esri/portal/Portal', 'esri/portal/PortalItem', 'esri/portal/PortalQueryParams',\n  'dojo/text!config/demoWebMap.json', 'dojo/text!config/demoWebScene.json'\n]).then(([\n  kernel, lang, Deferred,\n  esriConfig, promiseUtils,\n  IdentityManager, OAuthInfo,\n  Portal, PortalItem, PortalQueryParams,\n  webmapText, websceneText\n]) => {\n\n  class Boilerplate implements BoilerplateInterface {\n\n    settings: Settings = null;\n    config: Config = null;\n    results: BoilerplateResults = null;\n    portal: any = null;\n    direction: string = null;\n    locale: string = null;\n    units: string = null;\n    userPrivileges: any = null;\n\n    constructor(applicationConfigJSON, boilerplateSettings) {\n      this.settings = lang.mixin({\n        webscene: {},\n        webmap: {},\n        group: {},\n        portal: {},\n        urlItems: []\n      }, boilerplateSettings);\n\n      this.config = applicationConfigJSON;\n      this.results = {};\n    }\n\n    public queryGroupItems() {\n      let deferred;\n      // Get details about the specified web scene. If the web scene is not shared publicly users will\n      // be prompted to log-in by the Identity Manager.\n      deferred = new Deferred();\n      if (!this.settings.group.fetchItems || !this.config.group) {\n        deferred.resolve();\n      }\n      else {\n        const defaultParams = {\n          query: \"group:\\\"{groupid}\\\" AND -type:\\\"Code Attachment\\\"\",\n          sortField: \"modified\",\n          sortOrder: \"desc\",\n          num: 9,\n          start: 1\n        };\n        const paramOptions = lang.mixin(defaultParams, this.settings.group.itemParams);\n        // place group ID\n        if (paramOptions.query) {\n          paramOptions.query = lang.replace(paramOptions.query, {\n            groupid: this.config.group\n          });\n        }\n        // group params\n        const params = new PortalQueryParams(paramOptions);\n        this.portal.queryItems(params).then((response) => {\n          if (!this.results.group) {\n            this.results.group = {};\n          }\n          this.results.group.itemsData = response;\n          deferred.resolve(this.results.group);\n        }, (error) => {\n          if (!error) {\n            error = new Error(\"Boilerplate:: Error retrieving group items.\");\n          }\n          if (!this.results.group) {\n            this.results.group = {};\n          }\n          this.results.group.itemsData = error;\n          deferred.reject(error);\n        });\n      }\n      return deferred.promise;\n    }\n\n    public init(): dojo.Deferred<BoilerplateResponse> {\n      // Set the web scene and appid if they exist but ignore other url params.\n      // Additional url parameters may be defined by the application but they need to be mixed in\n      // to the config object after we retrieve the application configuration info. As an example,\n      // we'll mix in some commonly used url parameters after\n      // the application configuration has been applied so that the url parameters overwrite any\n      // configured settings. It's up to the application developer to update the application to take\n      // advantage of these parameters.\n      // This demonstrates how to handle additional custom url parameters. For example\n      // if you want users to be able to specify lat/lon coordinates that define the map's center or\n      // specify an alternate basemap via a url parameter.\n      // If these options are also configurable these updates need to be added after any\n      // application default and configuration info has been applied. Currently these values\n      // (center, basemap, theme) are only here as examples and can be removed if you don't plan on\n      // supporting additional url parameters in your application.\n      this.results.urlParams = {\n        config: this._getUrlParamValues(this.settings.urlItems)\n      };\n      // config defaults <- standard url params\n      // we need the web scene, appid,and oauthappid to query for the data\n      this._mixinAllConfigs();\n      // Define the portalUrl and other default values like the proxy.\n      // The portalUrl defines where to search for the web map and application content. The\n      // default value is arcgis.com.\n      this._initializeApplication();\n      // determine boilerplate language properties\n      this._setLangProps();\n      // check if signed in. Once we know if we're signed in, we can get data and create a portal if needed.\n      return this._checkSignIn().always(() => {\n        // execute these tasks async\n        return promiseUtils.eachAlways([\n          // get application data\n          this._queryApplicationItem(),\n          // get org data\n          this._queryPortal()\n        ]).always(() => {\n          // gets a temporary config from the users local storage\n          this.results.localStorageConfig = this._getLocalConfig();\n          // mixin all new settings from org and app\n          this._mixinAllConfigs();\n          // let's set up a few things\n          this._completeApplication();\n          // then execute these async\n          return promiseUtils.eachAlways([\n            // webmap item\n            this._queryWebMapItem(),\n            // webscene item\n            this._queryWebSceneItem(),\n            // group information\n            this._queryGroupInfo(),\n            // items within a specific group\n            this.queryGroupItems()\n          ]).always(() => {\n            return {\n              settings: this.settings,\n              config: this.config,\n              results: this.results,\n              portal: this.portal,\n              direction: this.direction,\n              locale: this.locale,\n              units: this.units,\n              userPrivileges: this.userPrivileges\n            };\n          });\n        });\n      });\n    }\n\n    private _getLocalConfig() {\n      const appid = this.config.appid;\n      if (window.localStorage && appid && this.settings.localConfig.fetch) {\n        const lsItem = localStorage.getItem(LOCALSTORAGE_PREFIX + appid);\n        if (lsItem) {\n          const config = JSON.parse(lsItem);\n          if (config) {\n            return config;\n          }\n        }\n      }\n    }\n\n    private _queryWebMapItem() {\n      let deferred;\n      // Get details about the specified web map. If the web map is not shared publicly users will\n      // be prompted to log-in by the Identity Manager.\n      deferred = new Deferred();\n      if (!this.settings.webmap.fetch) {\n        deferred.resolve();\n      }\n      else {\n        // Use local web map instead of portal web map\n        if (this.settings.webmap.useLocal) {\n          const json = JSON.parse(webmapText);\n          this.results.webMapItem = {\n            json\n          };\n          deferred.resolve(this.results.webMapItem);\n        }\n        // use webmap from id\n        else if (this.config.webmap) {\n          const mapItem = new PortalItem({\n            id: this.config.webmap\n          }).load();\n          mapItem.then((itemData) => {\n            this.results.webMapItem = {\n              data: itemData\n            };\n            deferred.resolve(this.results.webMapItem);\n          }, (error) => {\n            if (!error) {\n              error = new Error(\"Boilerplate:: Error retrieving webmap item.\");\n            }\n            this.results.webMapItem = {\n              data: error\n            };\n            deferred.reject(error);\n          });\n        }\n        else {\n          deferred.resolve();\n        }\n      }\n      return deferred.promise;\n    }\n\n    private _queryGroupInfo() {\n      let deferred;\n      // Get details about the specified group. If the group is not shared publicly users will\n      // be prompted to log-in by the Identity Manager.\n      deferred = new Deferred();\n      if (!this.settings.group.fetchInfo || !this.config.group) {\n        deferred.resolve();\n      }\n      else {\n        // group params\n        const params = new PortalQueryParams({\n          query: \"id:\\\"\" + this.config.group + \"\\\"\"\n        });\n        this.portal.queryGroups(params).then((response) => {\n          if (!this.results.group) {\n            this.results.group = {};\n          }\n          this.results.group.infoData = response;\n          deferred.resolve(this.results.group);\n        }, (error) => {\n          if (!error) {\n            error = new Error(\"Boilerplate:: Error retrieving group info.\");\n          }\n          if (!this.results.group) {\n            this.results.group = {};\n          }\n          this.results.group.infoData = error;\n          deferred.reject(error);\n        });\n      }\n      return deferred.promise;\n    }\n\n    private _queryWebSceneItem() {\n      let deferred, sceneItem;\n      // Get details about the specified web scene. If the web scene is not shared publicly users will\n      // be prompted to log-in by the Identity Manager.\n      deferred = new Deferred();\n      if (!this.settings.webscene.fetch) {\n        deferred.resolve();\n      }\n      else {\n        // Use local web scene instead of portal web scene\n        if (this.settings.webscene.useLocal) {\n          // get web scene js file\n          const json = JSON.parse(websceneText);\n          this.results.webSceneItem = {\n            json: json\n          };\n          deferred.resolve(this.results.webSceneItem);\n        }\n        // use webscene from id\n        else if (this.config.webscene) {\n          sceneItem = new PortalItem({\n            id: this.config.webscene\n          }).load();\n          sceneItem.then((itemData) => {\n            this.results.webSceneItem = {\n              data: itemData\n            };\n            deferred.resolve(this.results.webSceneItem);\n          }, (error) => {\n            if (!error) {\n              error = new Error(\"Boilerplate:: Error retrieving webscene item.\");\n            }\n            this.results.webSceneItem = {\n              data: error\n            };\n            deferred.reject(error);\n          });\n        }\n        else {\n          deferred.resolve();\n        }\n      }\n      return deferred.promise;\n    }\n\n    private _queryApplicationItem() {\n      // Get the application configuration details using the application id. When the response contains\n      // itemData.values then we know the app contains configuration information. We'll use these values\n      // to overwrite the application defaults.\n      const deferred = new Deferred();\n      if (!this.config.appid) {\n        deferred.resolve();\n      }\n      else {\n        const appItem = new PortalItem({\n          id: this.config.appid\n        }).load();\n        appItem.then((itemData) => {\n          itemData.fetchData().then((data) => {\n            let cfg: any = {};\n            if (data && data.values) {\n              // get app config values - we'll merge them with config later.\n              cfg = data.values;\n            }\n            // get the extent for the application item. This can be used to override the default web map extent\n            if (itemData.extent) {\n              cfg.application_extent = itemData.extent;\n            }\n            // get any app proxies defined on the application item\n            if (itemData.appProxies) {\n              const layerMixins = itemData.appProxies.map((p) => {\n                return {\n                  \"url\": p.sourceUrl,\n                  \"mixin\": {\n                    \"url\": p.proxyUrl\n                  }\n                };\n              });\n              cfg.layerMixins = layerMixins;\n            }\n            this.results.applicationItem = {\n              data: itemData,\n              config: cfg\n            };\n            deferred.resolve(this.results.applicationItem);\n          }, (error) => {\n            if (!error) {\n              error = new Error(\"Boilerplate:: Error retrieving application configuration data.\");\n            }\n            this.results.applicationItem = {\n              data: error,\n              config: null\n            };\n            deferred.reject(error);\n          });\n\n        }, (error) => {\n          if (!error) {\n            error = new Error(\"Boilerplate:: Error retrieving application configuration.\");\n          }\n          this.results.applicationItem = {\n            data: error,\n            config: null\n          };\n          deferred.reject(error);\n        });\n      }\n      return deferred.promise;\n    }\n\n    private _queryPortal() {\n      let deferred = new Deferred();\n      if (!this.settings.portal.fetch) {\n        deferred.resolve();\n      }\n      else {\n        // Query the ArcGIS.com organization. This is defined by the portalUrl that is specified. For example if you\n        // are a member of an org you'll want to set the portalUrl to be http://<your org name>.arcgis.com. We query\n        // the organization by making a self request to the org url which returns details specific to that organization.\n        // Examples of the type of information returned are custom roles, units settings, helper services and more.\n        // If this fails, the application will continue to function\n        const portal = new Portal().load();\n        this.portal = portal;\n        portal.then((response) => {\n          if (this.settings.webTierSecurity) {\n            let trustedHost;\n            if (response.authorizedCrossOriginDomains && response.authorizedCrossOriginDomains.length > 0) {\n              for (let i = 0; i < response.authorizedCrossOriginDomains.length; i++) {\n                trustedHost = response.authorizedCrossOriginDomains[i];\n                // add if trusted host is not null, undefined, or empty string\n                if (this._isDefined(trustedHost) && trustedHost.length > 0) {\n                  esriConfig.request.corsEnabledServers.push({\n                    host: trustedHost,\n                    withCredentials: true\n                  });\n                }\n              }\n            }\n          }\n          // set boilerplate units\n          let units = \"metric\";\n          if (response.user && response.user.units) { //user defined units\n            units = response.user.units;\n          }\n          else if (response.units) { //org level units\n            units = response.units;\n          }\n          else if ((response.user && response.user.region && response.user.region === \"US\") || (response.user && !response.user.region && response.region === \"US\") || (response.user && !response.user.region && !response.region) || (!response.user && response.ipCntryCode === \"US\") || (!response.user && !response.ipCntryCode && kernel.locale === \"en-us\")) {\n            // use feet/miles only for the US and if nothing is set for a user\n            units = \"english\";\n          }\n          this.units = units;\n          // are any custom roles defined in the organization?\n          if (response.user && this._isDefined(response.user.roleId)) {\n            if (response.user.privileges) {\n              this.userPrivileges = response.user.privileges;\n            }\n          }\n          // set data for portal on boilerplate\n          this.results.portal = {\n            data: response\n          };\n          deferred.resolve(this.results.portal);\n        }, (error) => {\n          if (!error) {\n            error = new Error(\"Boilerplate:: Error retrieving organization information.\");\n          }\n          this.results.portal = {\n            data: error\n          };\n          deferred.reject(error);\n        });\n      }\n      return deferred.promise;\n    }\n\n    private _overwriteExtent(itemInfo, extent) {\n      const item = itemInfo && itemInfo.item;\n      if (item && item.extent) {\n        item.extent = [\n          [\n            parseFloat(extent[0][0]), parseFloat(extent[0][1])\n          ],\n          [\n            parseFloat(extent[1][0]), parseFloat(extent[1][1])\n          ]\n        ];\n      }\n    }\n\n    private _completeApplication() {\n      // ArcGIS.com allows you to set an application extent on the application item. Overwrite the\n      // existing extents with the application item extent when set.\n      const applicationExtent = this.config.application_extent;\n      const results = this.results;\n      if (this.config.appid && applicationExtent && applicationExtent.length > 0) {\n        this._overwriteExtent(results.webSceneItem.data, applicationExtent);\n        this._overwriteExtent(results.webMapItem.data, applicationExtent);\n      }\n      // get helper services\n      const configHelperServices = this.config.helperServices;\n      const portalHelperServices = this.portal && this.portal.helperServices;\n      // see if config has a geometry service\n      const configGeometryUrl = configHelperServices && configHelperServices.geometry && configHelperServices.geometry.url;\n      // seee if portal has a geometry service\n      const portalGeometryUrl = portalHelperServices && portalHelperServices.geometry && portalHelperServices.geometry.url;\n      // use the portal geometry service or config geometry service\n      const geometryUrl = portalGeometryUrl || configGeometryUrl;\n      if (geometryUrl) {\n        // set the esri config to use the geometry service\n        esriConfig.geometryServiceUrl = geometryUrl;\n      }\n      if ((!this.config.webmap || this.config.webmap === DEFAULT_URL_PARAM) && this.settings.defaultWebmap) {\n        this.config.webmap = this.settings.defaultWebmap;\n      }\n      if ((!this.config.webscene || this.config.webscene === DEFAULT_URL_PARAM) && this.settings.defaultWebscene) {\n        this.config.webscene = this.settings.defaultWebscene;\n      }\n      if ((!this.config.group || this.config.group === DEFAULT_URL_PARAM) && this.settings.defaultGroup) {\n        this.config.group = this.settings.defaultGroup;\n      }\n    }\n\n    private _setLangProps() {\n      let direction = LTR;\n      RTL_LANGS.forEach((l) => {\n        if (kernel.locale.indexOf(l) !== -1) {\n          direction = RTL;\n        }\n      });\n      // set boilerplate language direction\n      this.direction = direction;\n      // set boilerplate langauge locale\n      this.locale = kernel.locale;\n    }\n\n    private _mixinAllConfigs() {\n      lang.mixin(\n        this.config,\n        this.results.applicationItem ? this.results.applicationItem.config : null,\n        this.results.localStorageConfig,\n        this.results.urlParams ? this.results.urlParams.config : null\n      );\n    }\n\n    private _getUrlParamValues(items: string[]) {\n      // retrieves only the items specified from the URL object.\n      // Gets parameters from the URL, convert them to an object and remove HTML tags.\n      const urlObject = this._createUrlParamsObject();\n      const obj = {};\n      if (urlObject && items && items.length) {\n        for (let i = 0; i < items.length; i++) {\n          const item = urlObject[items[i]];\n          if (item) {\n            if (typeof item === \"string\") {\n              switch (item.toLowerCase()) {\n                case \"true\":\n                  obj[items[i]] = true;\n                  break;\n                case \"false\":\n                  obj[items[i]] = false;\n                  break;\n                default:\n                  obj[items[i]] = item;\n              }\n            }\n            else {\n              obj[items[i]] = item;\n            }\n          }\n        }\n      }\n      return obj;\n    }\n\n    private _createUrlParamsObject() {\n      // retrieve url parameters. Templates all use url parameters to determine which arcgis.com\n      // resource to work with.\n      // Scene templates use the webscene param to define the scene to display\n      // appid is the id of the application based on the template. We use this\n      // id to retrieve application specific configuration information. The configuration\n      // information will contain the values the  user selected on the template configuration\n      // panel.\n      return this._stripObjectTags(this._urlToObject());\n    }\n\n    private _initializeApplication() {\n      // If this app is hosted on an Esri environment.\n      if (this.settings.esriEnvironment) {\n        let appLocation, instance;\n        // Check to see if the app is hosted or a portal. If the app is hosted or a portal set the\n        // portalUrl and the proxy. Otherwise use the portalUrl set it to arcgis.com.\n        // We know app is hosted (or portal) if it has /apps/ or /home/ in the url.\n        appLocation = location.pathname.indexOf(ESRI_APPS_PATH);\n        if (appLocation === -1) {\n          appLocation = location.pathname.indexOf(ESRI_HOME_PATH);\n        }\n        // app is hosted and no portalUrl is defined so let's figure it out.\n        if (appLocation !== -1) {\n          // hosted or portal\n          instance = location.pathname.substr(0, appLocation); //get the portal instance name\n          this.config.portalUrl = \"https://\" + location.host + instance;\n          this.config.proxyUrl = \"https://\" + location.host + instance + ESRI_PROXY_PATH;\n        }\n      }\n      esriConfig.portalUrl = this.config.portalUrl;\n      // Define the proxy url for the app\n      if (this.config.proxyUrl) {\n        esriConfig.request.proxyUrl = this.config.proxyUrl;\n      }\n    }\n\n    private _checkSignIn() {\n      let deferred, signedIn, oAuthInfo;\n      deferred = new Deferred();\n      //If there's an oauth appid specified register it\n      if (this.config.oauthappid) {\n        oAuthInfo = new OAuthInfo({\n          appId: this.config.oauthappid,\n          portalUrl: this.config.portalUrl,\n          popup: true\n        });\n        IdentityManager.registerOAuthInfos([oAuthInfo]);\n      }\n      // check sign-in status\n      signedIn = IdentityManager.checkSignInStatus(this.config.portalUrl + SHARING_PATH);\n      // resolve regardless of signed in or not.\n      signedIn.always(deferred.resolve);\n      return deferred.promise;\n    }\n\n    private _isDefined(value: any) {\n      return (value !== undefined) && (value !== null);\n    }\n\n    private _stripStringTags(data: string) {\n      return data.replace(TAGS_RE, \"\");\n    }\n\n    private _stripObjectTags(data: Object) {\n      return Object.keys(data).reduce((p, c, i) => {\n        let obj = p;\n        if (typeof data[c] === \"string\") {\n          obj[c] === c.replace(TAGS_RE, \"\");\n        } else {\n          obj[c] === c;\n        }\n        return obj\n      }, {});\n    }\n\n    private _urlToObject() {\n      const query = (window.location.search || \"?\").substr(1),\n        map = {};\n      query.replace(URL_RE, (match, key, value) => {\n        map[key] = decodeURIComponent(value);\n        return '';\n      });\n      return map;\n    }\n  }\n\n  return Promise.resolve(new Boilerplate(appSettings, boilerSettings));\n  \n}).catch((err) => {\n  throw new Error(err);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/ts/boilerplate/boilerplate.ts","var stache = require('can-stache');\nvar mustacheCore = require('can-stache/src/mustache_core');\nvar getIntermediateAndImports = require(\"can-stache/src/intermediate_and_imports\");\n\n\n\nvar source = module.exports = \"<div class=\\\"property-table\\\">\\r\\n    <table class=\\\"table table-striped table-condensed\\\">\\r\\n        <thead>\\r\\n            <tr>\\r\\n                <th>Field</th>\\r\\n                <th>Value</th>\\r\\n            </tr>\\r\\n        </thead>\\r\\n        <tbody>\\r\\n            {{#each fields as field}}\\r\\n                <tr>\\r\\n                    <td>{{field.alias}}</td>\\r\\n                    <td class=\\\"{{field.classes}}\\\">\\r\\n                      {{>field.displayTemplate}}\\r\\n                    </td>\\r\\n                </tr>\\r\\n            {{/each}}\\r\\n        </tbody>\\r\\n    </table>\\r\\n</div>\\r\\n\";;\nvar intermediateAndImports = getIntermediateAndImports(source);\n\nvar intermediate = intermediateAndImports.intermediate;\nvar renderer = stache(intermediate);\n\nmodule.exports = function (scope, options, nodeList) {\n    var moduleOptions = { module: module };\n\n    if (!(options instanceof mustacheCore.Options)) {\n        options = new mustacheCore.Options(options || {});\n    }\n\n    return renderer(scope, options.add(moduleOptions), nodeList);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/property-table/property-table.stache\n// module id = 77\n// module chunks = 0","var stache = require('can-stache');\nvar mustacheCore = require('can-stache/src/mustache_core');\nvar getIntermediateAndImports = require(\"can-stache/src/intermediate_and_imports\");\n\n\n\nvar source = module.exports = \"<h1>Property Table Demo</h1>\\n<h2>Simple: </h2>\\n<property-table {object}=\\\"data\\\" />\\n\\n<br />\\n<div class=\\\"divider\\\" />\\n\\n<h2>Customized: </h2>\\n<property-table {object}=\\\"data\\\" {fields}=\\\"fields\\\" />\\n\";;\nvar intermediateAndImports = getIntermediateAndImports(source);\n\nvar intermediate = intermediateAndImports.intermediate;\nvar renderer = stache(intermediate);\n\nmodule.exports = function (scope, options, nodeList) {\n    var moduleOptions = { module: module };\n\n    if (!(options instanceof mustacheCore.Options)) {\n        options = new mustacheCore.Options(options || {});\n    }\n\n    return renderer(scope, options.add(moduleOptions), nodeList);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/template.stache\n// module id = 78\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/css/index.scss\n// module id = 79\n// module chunks = 0","/* jshint -W079 */\n// # can/component/component.js\n//\n// This implements the `Component` which allows you to create widgets\n// that use a template, a view-model and custom tags.\n//\n// `Component` implements most of it's functionality in the `Component.setup`\n// and the `Component.prototype.setup` functions.\n//\n// `Component.setup` prepares everything needed by the `Component.prototype.setup`\n// to hookup the component.\nvar ComponentControl = require(\"./control/control\");\nvar namespace = require('can-namespace');\n\nvar Construct = require(\"can-construct\");\nvar stacheBindings = require(\"can-stache-bindings\");\nvar Scope = require(\"can-view-scope\");\nvar viewCallbacks = require(\"can-view-callbacks\");\nvar nodeLists = require(\"can-view-nodelist\");\n\nvar domData = require('can-util/dom/data/data');\nvar domMutate = require('can-util/dom/mutate/mutate');\nvar getChildNodes = require('can-util/dom/child-nodes/child-nodes');\nvar domDispatch = require('can-util/dom/dispatch/dispatch');\nvar types = require(\"can-types\");\nvar string = require(\"can-util/js/string/string\");\n\nvar canEach = require('can-util/js/each/each');\nvar isFunction = require('can-util/js/is-function/is-function');\nvar canLog = require('can-util/js/log/log');\n\nrequire('can-util/dom/events/inserted/inserted');\nrequire('can-util/dom/events/removed/removed');\nrequire('can-view-model');\n\n/**\n * @add Component\n */\nvar Component = Construct.extend(\n\n\t// ## Static\n\t/**\n\t * @static\n\t */\n\n\t{\n\t\t// ### setup\n\t\t//\n\t\t// When a component is extended, this sets up the component's internal constructor\n\t\t// functions and templates for later fast initialization.\n\t\tsetup: function() {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\t// When `Component.setup` function is ran for the first time, `Component` doesn't exist yet\n\t\t\t// which ensures that the following code is ran only in constructors that extend `Component`.\n\t\t\tif (Component) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t// Define a control using the `events` prototype property.\n\t\t\t\tthis.Control = ComponentControl.extend(this.prototype.events);\n\n\t\t\t\t// Look at viewModel, scope, and ViewModel properties and set one of:\n\t\t\t\t//  - this.viewModelHandler\n\t\t\t\t//  - this.ViewModel\n\t\t\t\t//  - this.viewModelInstance\n\t\t\t\tvar protoViewModel = this.prototype.viewModel || this.prototype.scope;\n\n\t\t\t\tif(protoViewModel && this.prototype.ViewModel) {\n\t\t\t\t\tthrow new Error(\"Cannot provide both a ViewModel and a viewModel property\");\n\t\t\t\t}\n\t\t\t\tvar vmName = string.capitalize( string.camelize(this.prototype.tag) )+\"VM\";\n\t\t\t\tif(this.prototype.ViewModel) {\n\t\t\t\t\tif(typeof this.prototype.ViewModel === \"function\") {\n\t\t\t\t\t\tthis.ViewModel = this.prototype.ViewModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = types.DefaultMap.extend(vmName, this.prototype.ViewModel);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif(protoViewModel) {\n\t\t\t\t\t\tif(typeof protoViewModel === \"function\") {\n\t\t\t\t\t\t\tif(types.isMapLike(protoViewModel.prototype)) {\n\t\t\t\t\t\t\t\tthis.ViewModel = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.viewModelHandler = protoViewModel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(types.isMapLike(protoViewModel)) {\n\t\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is sharing a single map across all component instances\");\n\t\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\t\tthis.viewModelInstance = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.ViewModel = types.DefaultMap.extend(vmName,protoViewModel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = types.DefaultMap.extend(vmName,{});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Convert the template into a renderer function.\n\t\t\t\tif (this.prototype.template) {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tcanLog.warn('can-component.prototype.template: is deprecated and will be removed in a future release. Use can-component.prototype.view');\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.renderer = this.prototype.template;\n\t\t\t\t}\n\t\t\t\tif (this.prototype.view) {\n\t\t\t\t\tthis.renderer = this.prototype.view;\n\t\t\t\t}\n\n\t\t\t\t// Register this component to be created when its `tag` is found.\n\t\t\t\tviewCallbacks.tag(this.prototype.tag, function(el, options) {\n\t\t\t\t\tnew self(el, options);\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\t}, {\n\t\t// ## Prototype\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// ### setup\n\t\t// When a new component instance is created, setup bindings, render the template, etc.\n\t\tsetup: function(el, componentTagData) {\n\t\t\tvar component = this;\n\t\t\t// If a template is not provided, we fall back to\n\t\t\t// dynamic scoping regardless of settings.\n\t\t\tvar lexicalContent = (\n\t\t\t\t\t(typeof this.leakScope === \"undefined\" ? true : !this.leakScope) &&\n\t\t\t\t\t!!(this.template || this.view)\n\t\t\t\t);\n\t\t\t// an array of teardown stuff that should happen when the element is removed\n\t\t\tvar teardownFunctions = [];\n\t\t\tvar initialViewModelData = {};\n\t\t\tvar callTeardownFunctions = function() {\n\t\t\t\t\tfor (var i = 0, len = teardownFunctions.length; i < len; i++) {\n\t\t\t\t\t\tteardownFunctions[i]();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\tvar setupBindings = !domData.get.call(el, \"preventDataBindings\");\n\t\t\tvar viewModel, frag;\n\n\t\t\t// ## Scope\n\t\t\tvar teardownBindings;\n\t\t\tif (setupBindings) {\n\t\t\t\tvar setupFn = componentTagData.setupBindings ||\n\t\t\t\t\tfunction(el, callback, data){\n\t\t\t\t\t\treturn stacheBindings.behaviors.viewModel(el, componentTagData,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcallback, data);\n\t\t\t\t\t};\n\t\t\t\tteardownBindings = setupFn(el, function(initialViewModelData) {\n\n\t\t\t\t\tvar ViewModel = component.constructor.ViewModel,\n\t\t\t\t\t\tviewModelHandler = component.constructor.viewModelHandler,\n\t\t\t\t\t\tviewModelInstance = component.constructor.viewModelInstance;\n\n\t\t\t\t\tif(viewModelHandler) {\n\t\t\t\t\t\tvar scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);\n\t\t\t\t\t\tif (types.isMapLike( scopeResult ) ) {\n\t\t\t\t\t\t\t// If the function returns a can.Map, use that as the viewModel\n\t\t\t\t\t\t\tviewModelInstance = scopeResult;\n\t\t\t\t\t\t} else if ( types.isMapLike(scopeResult.prototype) ) {\n\t\t\t\t\t\t\t// If `scopeResult` is of a `can.Map` type, use it to wrap the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = scopeResult;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise extend `can.Map` with the `scopeResult` and initialize it with the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = types.DefaultMap.extend(scopeResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(ViewModel) {\n\t\t\t\t\t\tviewModelInstance = new component.constructor.ViewModel(initialViewModelData);\n\t\t\t\t\t}\n\t\t\t\t\tviewModel = viewModelInstance;\n\t\t\t\t\treturn viewModelInstance;\n\t\t\t\t}, initialViewModelData);\n\t\t\t}\n\n\t\t\t// Set `viewModel` to `this.viewModel` and set it to the element's `data` object as a `viewModel` property\n\t\t\tthis.viewModel = viewModel;\n\n\t\t\tdomData.set.call(el, \"viewModel\", viewModel);\n\t\t\tdomData.set.call(el, \"preventDataBindings\", true);\n\n\t\t\t// Create a real Scope object out of the viewModel property\n\t\t\t// The scope used to render the component's template.\n\t\t\t// However, if there is no template, the \"light\" dom is rendered with this anyway.\n\t\t\tvar shadowScope;\n\t\t\tif (lexicalContent) {\n\t\t\t\tshadowScope = Scope.refsScope().add(this.viewModel, {\n\t\t\t\t\tviewModel: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// if this component has a template,\n\t\t\t\t// render the template with it's own Refs scope\n\t\t\t\t// otherwise, just add this component's viewModel.\n\t\t\t\tshadowScope = (this.constructor.renderer ?\n\t\t\t\t\t\tcomponentTagData.scope.add(new Scope.Refs()) :\n\t\t\t\t\t\tcomponentTagData.scope)\n\t\t\t\t\t.add(this.viewModel, {\n\t\t\t\t\t\tviewModel: true\n\t\t\t\t\t});\n\t\t\t}\n\t\t\tvar options = {\n\t\t\t\t\thelpers: {}\n\t\t\t\t},\n\t\t\t\taddHelper = function(name, fn) {\n\t\t\t\t\toptions.helpers[name] = function() {\n\t\t\t\t\t\treturn fn.apply(viewModel, arguments);\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t// ## Helpers\n\n\t\t\t// Setup helpers to callback with `this` as the component\n\t\t\tcanEach(this.helpers || {}, function(val, prop) {\n\t\t\t\tif (isFunction(val)) {\n\t\t\t\t\taddHelper(prop, val);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// ## `events` control\n\n\t\t\t// Create a control to listen to events\n\t\t\tthis._control = new this.constructor.Control(el, {\n\t\t\t\t// Pass the viewModel to the control so we can listen to it's changes from the controller.\n\t\t\t\tscope: this.viewModel,\n\t\t\t\tviewModel: this.viewModel,\n\t\t\t\tdestroy: callTeardownFunctions\n\t\t\t});\n\n\t\t\t// ## Rendering\n\n\t\t\t// Keep a nodeList so we can kill any directly nested nodeLists within this component\n\t\t\tvar nodeList = nodeLists.register([], function() {\n\t\t\t\tdomDispatch.call(el, \"beforeremove\", [], false);\n\t\t\t\tif(teardownBindings) {\n\t\t\t\t\tteardownBindings();\n\t\t\t\t}\n\t\t\t}, componentTagData.parentNodeList || true, false);\n\t\t\tnodeList.expression = \"<\" + this.tag + \">\";\n\t\t\tteardownFunctions.push(function() {\n\t\t\t\tnodeLists.unregister(nodeList);\n\t\t\t});\n\n\t\t\t// If this component has a template (that we've already converted to a renderer)\n\t\t\tif (this.constructor.renderer) {\n\t\t\t\t// If `options.tags` doesn't exist set it to an empty object.\n\t\t\t\tif (!options.tags) {\n\t\t\t\t\toptions.tags = {};\n\t\t\t\t}\n\n\t\t\t\t// We need be alerted to when a <content> element is rendered so we can put the original contents of the widget in its place\n\t\t\t\toptions.tags.content = function contentHookup(el, contentTagData) {\n\t\t\t\t\t// First check if there was content within the custom tag\n\t\t\t\t\t// otherwise, render what was within <content>, the default code.\n\t\t\t\t\t// `componentTagData.subtemplate` is the content inside this component\n\t\t\t\t\tvar subtemplate = componentTagData.subtemplate || contentTagData.subtemplate,\n\t\t\t\t\t\trenderingLightContent = subtemplate === componentTagData.subtemplate;\n\n\t\t\t\t\tif (subtemplate) {\n\n\t\t\t\t\t\t// `contentTagData.options` is a viewModel of helpers where `<content>` was found, so\n\t\t\t\t\t\t// the right helpers should already be available.\n\t\t\t\t\t\t// However, `_tags.content` is going to point to this current content callback.  We need to\n\t\t\t\t\t\t// remove that so it will walk up the chain\n\n\t\t\t\t\t\tdelete options.tags.content;\n\n\t\t\t\t\t\t// By default, light dom scoping is\n\t\t\t\t\t\t// dynamic. This means that any `{{foo}}`\n\t\t\t\t\t\t// bindings inside the \"light dom\" content of\n\t\t\t\t\t\t// the component will have access to the\n\t\t\t\t\t\t// internal viewModel. This can be overridden to be\n\t\t\t\t\t\t// lexical with the leakScope option.\n\t\t\t\t\t\tvar lightTemplateData;\n\t\t\t\t\t\tif (renderingLightContent) {\n\t\t\t\t\t\t\tif (lexicalContent) {\n\t\t\t\t\t\t\t\t// render with the same scope the component was found within.\n\t\t\t\t\t\t\t\tlightTemplateData = componentTagData;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// render with the component's viewModel mixed in, however\n\t\t\t\t\t\t\t\t// we still want the outer refs to be used, NOT the component's refs\n\t\t\t\t\t\t\t\t// <component> {{some value }} </component>\n\t\t\t\t\t\t\t\t// To fix this, we\n\t\t\t\t\t\t\t\t// walk down the scope to the component's ref, clone scopes from that point up\n\t\t\t\t\t\t\t\t// use that as the new scope.\n\t\t\t\t\t\t\t\tlightTemplateData = {\n\t\t\t\t\t\t\t\t\tscope: contentTagData.scope.cloneFromRef(),\n\t\t\t\t\t\t\t\t\toptions: contentTagData.options\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// we are rendering default content so this content should\n\t\t\t\t\t\t\t// use the same scope as the <content> tag was found within.\n\t\t\t\t\t\t\tlightTemplateData = contentTagData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (contentTagData.parentNodeList) {\n\t\t\t\t\t\t\tvar frag = subtemplate(lightTemplateData.scope, lightTemplateData.options, contentTagData.parentNodeList);\n\t\t\t\t\t\t\tnodeLists.replace([el], frag);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnodeLists.replace([el], subtemplate(lightTemplateData.scope, lightTemplateData.options));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Restore the content tag so it could potentially be used again (as in lists)\n\t\t\t\t\t\toptions.tags.content = contentHookup;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Render the component's template\n\t\t\t\tfrag = this.constructor.renderer(shadowScope, componentTagData.options.add(options), nodeList);\n\t\t\t} else {\n\t\t\t\t// Otherwise render the contents between the element\n\t\t\t\tfrag = componentTagData.subtemplate ?\n\t\t\t\t\tcomponentTagData.subtemplate(shadowScope, componentTagData.options.add(options), nodeList) :\n\t\t\t\t\tdocument.createDocumentFragment();\n\n\t\t\t}\n\t\t\t// Append the resulting document fragment to the element\n\t\t\tdomMutate.appendChild.call(el, frag);\n\n\t\t\t// update the nodeList with the new children so the mapping gets applied\n\t\t\tnodeLists.update(nodeList, getChildNodes(el));\n\t\t}\n\t});\n\n\n\nmodule.exports = namespace.Component = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-component/can-component.js\n// module id = 80\n// module chunks = 0","var Control = require(\"can-control\");\n\nvar canEach = require('can-util/js/each/each');\nvar string = require('can-util/js/string/string');\nvar canCompute = require(\"can-compute\");\nvar observeReader = require('can-observation/reader/reader');\n\n// ## Helpers\n// Attribute names to ignore for setting viewModel values.\nvar paramReplacer = /\\{([^\\}]+)\\}/g;\n\nvar ComponentControl = Control.extend({\n\t\t// the lookup path - where templated keys will be looked up\n\t\t// change lookup to first look in the viewModel\n\t\t_lookup: function(options) {\n\t\t\treturn [options.scope, options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t// viewModel.foo -> foo\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key.replace(/^(scope|^viewModel)\\./, \"\");\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'scope' || key === 'viewModel';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn options[key];\n\t\t},\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar hasObjectLookup;\n\n\t\t\tparamReplacer.lastIndex = 0;\n\n\t\t\thasObjectLookup = paramReplacer.test(methodName);\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later.\n\t\t\tif (!controlInstance && hasObjectLookup) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\treturn Control._action.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t},\n\t// Extend `events` with a setup method that listens to changes in `viewModel` and\n\t// rebinds all templated event handlers.\n\t{\n\t\tsetup: function(el, options) {\n\t\t\tthis.scope = options.scope;\n\t\t\tthis.viewModel = options.viewModel;\n\t\t\treturn Control.prototype.setup.call(this, el, options);\n\t\t},\n\t\toff: function() {\n\t\t\t// If `this._bindings` exists we need to go through it's `readyComputes` and manually\n\t\t\t// unbind `change` event listeners set by the controller.\n\t\t\tif (this._bindings) {\n\t\t\t\tcanEach(this._bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tvalue.compute.unbind(\"change\", value.handler);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Call `Control.prototype.off` function on this instance to cleanup the bindings.\n\t\t\tControl.prototype.off.apply(this, arguments);\n\t\t\tthis._bindings.readyComputes = {};\n\t\t},\n\t\tdestroy: function() {\n\t\t\tControl.prototype.destroy.apply(this, arguments);\n\t\t\tif (typeof this.options.destroy === 'function') {\n\t\t\t\tthis.options.destroy.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t});\n\nmodule.exports = ComponentControl;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-component/control/control.js\n// module id = 81\n// module chunks = 0","// # can/compute/proto_compute (aka can.Compute)\n//\n// Allows the creation of observablue values. This\n// is a prototype based version of [can.compute](compute.html).\n//\n// can.Computes come in different flavors:\n//\n// - [Getter / Setter functional computes](#setup-getter-setter-functional-computes).\n// - [Property computes](#setup-property-computes).\n// - [Setter computes](#setup-setter-computes).\n// - [Async computes](#setup-async-computes).\n// - [Settings computes](#setup-settings-computes).\n// - [Simple value computes](#setup-simple-value-computes).\n//\n//\n// can.Computes have public `.get`, `.set`, `.on`, and `.off` methods that call\n// internal methods that are configured differently depending on what flavor of\n// compute is being created.  Those methods are:\n//\n// - `_on(updater)` - Called the first time the compute is bound. This should bind to\n//    any source observables.  When any of the source observables have changed, it should call\n//    `updater(newVal, oldVal, batchNum)`.\n//\n// - `_off(updater)` - Called when the compute has no more event handlers.  This should unbind to any source observables.\n// - `_get` - Called to get the current value of the compute.\n// - `_set` - Called to set the value of the compute.\n//\n//\n//\n// Other internal flags and values:\n// - `value` - the cached value\n// - `_setUpdates` - if calling `_set` will have updated the cached value itself so `_get` does not need to be called.\n// - `_canObserve` - if this compute can be observed.\n// - `hasDependencies` - if this compute has source observable values.\nvar Observation = require('can-observation');\nvar canEvent = require('can-event');\nvar eventLifecycle = require('can-event/lifecycle/lifecycle');\nrequire('can-event/batch/batch');\nvar observeReader = require('can-observation/reader/reader');\nvar getObject = require('can-util/js/get/get');\nvar setImmediate = require('can-util/js/set-immediate/set-immediate');\n\nvar CID = require('can-cid');\nvar assign = require('can-util/js/assign/assign');\nvar types = require('can-types');\nvar isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');\nvar canLog = require('can-util/js/log/log');\n\n// ## can.Compute\n// Checks the arguments and calls different setup methods.\nvar Compute = function(getterSetter, context, eventName, bindOnce) {\n\tCID(this, 'compute');\n\n\tvar args = [];\n\n\tfor(var i = 0, arglen = arguments.length; i < arglen; i++) {\n\t\targs[i] = arguments[i];\n\t}\n\n\tvar contextType = typeof args[1];\n\n\tif (typeof args[0] === 'function') {\n\t\t// Getter/Setter functional computes.\n\t\t// `new can.Compute(function(){ ... })`\n\t\tthis._setupGetterSetterFn(args[0], args[1], args[2], args[3]);\n\t} else if (args[1] !== undefined) {\n\t\tif (contextType === 'string' || contextType === 'number') {\n\t\t\t// Property computes.\n\t\t\t// `new can.Compute(object, propertyName[, eventName])`\n\t\t\tvar isListLike = types.isListLike(args[0]);\n\t\t\tif(types.isMapLike( args[0] ) || isListLike) {\n\t\t\t\tvar map = args[0];\n\t\t\t\tvar propertyName = args[1];\n\t\t\t\tvar mapGetterSetter = function(newValue){\n\t\t\t\t\tif(arguments.length) {\n\t\t\t\t\t\tobserveReader.set(map,propertyName, newValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// forces length to be read\n\t\t\t\t\t\tif(isListLike) {\n\t\t\t\t\t\t\tobserveReader.get(map,\"length\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn observeReader.get(map,\"\"+propertyName);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);\n\t\t\t} else {\n\t\t\t\tthis._setupProperty(args[0], args[1], args[2]);\n\t\t\t}\n\n\t\t} else if(contextType === 'function') {\n\t\t\t// Setter computes.\n\t\t\t// `new can.Compute(initialValue, function(newValue){ ... })`\n\t\t\tthis._setupSetter(args[0], args[1], args[2]);\n\t\t} else {\n\n\t\t\tif(args[1] && args[1].fn) {\n\t\t\t\t// Async computes.\n\t\t\t\tthis._setupAsyncCompute(args[0], args[1]);\n\t\t\t} else {\n\t\t\t\t// Settings computes.\n\t\t\t\t//`new can.Compute(initialValue, {on, off, get, set})`\n\t\t\t\tthis._setupSettings(args[0], args[1]);\n\t\t\t}\n\n\t\t}\n\t} else {\n\t\t// Simple value computes.\n\t\t// `new can.Compute(initialValue)`\n\t\tthis._setupSimpleValue(args[0]);\n\t}\n\n\tthis._args = args;\n\tthis._primaryDepth = 0;\n\n\tthis.isComputed = true;\n\n};\n\n// ## Helpers\n\n// ## updateOnChange\n// A helper to trigger an event when a value changes\nvar updateOnChange = function(compute, newValue, oldValue, batchNum){\n\n\tvar valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);\n\n\t// Only trigger event when value has changed\n\tif (valueChanged) {\n\t\tcanEvent.dispatch.call(compute, {type: \"change\", batchNum: batchNum}, [\n\t\t\tnewValue,\n\t\t\toldValue\n\t\t]);\n\t}\n};\n\n// ### setupComputeHandlers\n// A helper that creates an `_on` and `_off` function that\n// will bind on source observables and update the value of the compute.\nvar setupComputeHandlers = function(compute, func, context) {\n\n\tvar observation = new Observation(func, context, compute);\n\tcompute.observation = observation;\n\treturn {\n\t\t// Call `onchanged` when any source observables change.\n\t\t_on: function() {\n\t\t\tobservation.start();\n\t\t\tcompute.value = observation.value;\n\t\t\tcompute.hasDependencies = !isEmptyObject(observation.newObserved);\n\t\t},\n\t\t// Unbind `onchanged` from all source observables.\n\t\t_off: function() {\n\t\t\tobservation.stop();\n\t\t},\n\t\tgetDepth: function() {\n\t\t\treturn observation.getDepth();\n\t\t}\n\t};\n};\n\nassign(Compute.prototype, {\n\tsetPrimaryDepth: function(depth) {\n\t\tthis._primaryDepth = depth;\n\t},\n\n\t// ## Setup getter / setter functional computes\n\t// Uses the function as both a getter and setter.\n\t_setupGetterSetterFn: function(getterSetter, context, eventName) {\n\t\tthis._set = context ? getterSetter.bind(context) : getterSetter;\n\t\tthis._get = context ? getterSetter.bind(context) : getterSetter;\n\t\tthis._canObserve = eventName === false ? false : true;\n\t\t// The helper provides the on and off methods that use `getValueAndBind`.\n\t\tvar handlers = setupComputeHandlers(this, getterSetter, context || this);\n\n\t\tassign(this, handlers);\n\t},\n\t// ## Setup property computes\n\t// Listen to a property changing on an object.\n\t_setupProperty: function(target, propertyName, eventName) {\n\t\tvar self = this,\n\t\t\thandler;\n\n\n\t\t// This is objects that can be bound to with can.bind.\n\t\thandler = function () {\n\t\t\tself.updater(self._get(), self.value);\n\t\t};\n\t\tthis._get = function() {\n\t\t\treturn getObject(target, propertyName);\n\t\t};\n\t\tthis._set = function(value) {\n\t\t\t// allow setting properties n levels deep, if separated with dot syntax\n\t\t\tvar properties = propertyName.split(\".\"),\n\t\t\t\tleafPropertyName = properties.pop();\n\n\t\t\tif(properties.length) {\n\t\t\t\tvar targetProperty = getObject(target, properties.join('.'));\n\t\t\t\ttargetProperty[leafPropertyName] = value;\n\t\t\t} else {\n\t\t\t\ttarget[propertyName] = value;\n\t\t\t}\n\t\t};\n\n\t\tthis._on = function(update) {\n\t\t\tcanEvent.on.call(target, eventName || propertyName, handler);\n\t\t\t// Set the cached value\n\t\t\tthis.value = this._get();\n\t\t};\n\t\tthis._off = function() {\n\t\t\treturn canEvent.off.call( target, eventName || propertyName, handler);\n\t\t};\n\t},\n\t// ## Setup Setter Computes\n\t// Only a setter function is specified.\n\t_setupSetter: function(initialValue, setter, eventName) {\n\t\tthis.value = initialValue;\n\t\tthis._set = setter;\n\t\tassign(this, eventName);\n\t},\n\t// ## Setup settings computes\n\t// Use whatever `on`, `off`, `get`, `set` the users provided\n\t// as the internal methods.\n\t_setupSettings: function(initialValue, settings) {\n\n\t\tthis.value = initialValue;\n\n\t\tthis._set = settings.set || this._set;\n\t\tthis._get = settings.get || this._get;\n\n\t\t// This allows updater to be called without any arguments.\n\t\t// selfUpdater flag can be set by things that want to call updater themselves.\n\t\tif(!settings.__selfUpdater) {\n\t\t\tvar self = this,\n\t\t\t\toldUpdater = this.updater;\n\t\t\tthis.updater = function() {\n\t\t\t\toldUpdater.call(self, self._get(), self.value);\n\t\t\t};\n\t\t}\n\n\n\t\tthis._on = settings.on ? settings.on : this._on;\n\t\tthis._off = settings.off ? settings.off : this._off;\n\t},\n\t// ## Setup async computes\n\t// This is a special, non-documented form of a compute\n\t// rhat can asynchronously update its value.\n\t_setupAsyncCompute: function(initialValue, settings){\n\t\tvar self = this;\n\t\t// This is the async getter function.  Depending on how many arguments the function takes,\n\t\t// we setup bindings differently.\n\t\tvar getter = settings.fn;\n\t\tvar bindings;\n\n\t\tthis.value = initialValue;\n\n\t\t// This compute will call update with the new value itself.\n\t\tthis._setUpdates = true;\n\n\t\t// An \"async\" compute has a `lastSetValue` that represents\n\t\t// the last value `compute.set` was called with.\n\t\t// The following creates `lastSetValue` as a can.Compute so when\n\t\t//  `lastSetValue` is changed, the `getter` can see that change\n\t\t// and automatically update itself.\n\t\tthis.lastSetValue = new Compute(initialValue);\n\n\t\t// Wires up setting this compute to set `lastSetValue`.\n\t\t// If the new value matches the last setValue, do nothing.\n\t\tthis._set = function(newVal){\n\t\t\tif(newVal === self.lastSetValue.get()) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\treturn self.lastSetValue.set(newVal);\n\t\t};\n\n\t\t// Wire up the get to pass the lastNewValue\n\t\tthis._get = function() {\n\t\t\treturn getter.call(settings.context, self.lastSetValue.get() );\n\t\t};\n\n\t\tif(getter.length === 0) {\n\t\t\t// If it takes no arguments, it should behave just like a Getter compute.\n\t\t\tbindings = setupComputeHandlers(this, getter, settings.context);\n\t\t} else if(getter.length === 1) {\n\t\t\t// If it has a single argument, pass it the last setValue.\n\t\t\tbindings = setupComputeHandlers(this, function() {\n\t\t\t\treturn getter.call(settings.context, self.lastSetValue.get() );\n\t\t\t}, settings);\n\n\t\t} else {\n\t\t\t// If the function takes 2 arguments, the second argument is a function\n\t\t\t// that should update the value of the compute (`setValue`). To make this we need\n\t\t\t// the \"normal\" updater function because we are about to overwrite it.\n\t\t\tvar oldUpdater = this.updater,\n\t\t\t\tresolve = Observation.ignore(function(newVal) {\n\t\t\t\t\toldUpdater.call(self, newVal, self.value);\n\t\t\t\t});\n\n\t\t\t// Because `setupComputeHandlers` calls `updater` internally with its\n\t\t\t// observation.value as `oldValue` and that might not be up to date,\n\t\t\t// we overwrite updater to always use self.value.\n\t\t\tthis.updater = function(newVal) {\n\t\t\t\toldUpdater.call(self, newVal, self.value);\n\t\t\t};\n\n\n\t\t\tbindings = setupComputeHandlers(this, function() {\n\t\t\t\t// Call getter, and get new value\n\t\t\t\tvar res = getter.call(settings.context, self.lastSetValue.get(), resolve);\n\t\t\t\t// If undefined is returned, don't update the value.\n\t\t\t\treturn res !== undefined ? res : this.value;\n\t\t\t}, this);\n\t\t}\n\n\t\tassign(this, bindings);\n\t},\n\t// ## Setup simple value computes\n\t// Uses the default `_get`, `_set` behaviors.\n\t_setupSimpleValue: function(initialValue) {\n\t\tthis.value = initialValue;\n\t},\n\t// ## _bindsetup\n\t// When a compute is first bound, call the internal `this._on` method.\n\t// `can.__notObserve` makes sure if `_on` is listening to any observables,\n\t// they will not be observed by any outer compute.\n\t_eventSetup: Observation.ignore(function () {\n\t\tthis.bound = true;\n\t\tthis._on(this.updater);\n\t}),\n\t// ## _bindteardown\n\t// When a compute has no other bindings, call the internal `this._off` method.\n\t_eventTeardown: function () {\n\t\tthis._off(this.updater);\n\t\tthis.bound = false;\n\t},\n\t// ## bind and unbind\n\t// A bind and unbind that calls `_bindsetup` and `_bindteardown`.\n\taddEventListener: eventLifecycle.addAndSetup,\n\tremoveEventListener: eventLifecycle.removeAndTeardown,\n\n\t// ## clone\n\t// Copies this compute, but for a different context.\n\t// This is mostly used for computes on a map's prototype.\n\tclone: function(context) {\n\t\tif(context && typeof this._args[0] === 'function') {\n\t\t\tthis._args[1] = context;\n\t\t} else if(context) {\n\t\t\tthis._args[2] = context;\n\t\t}\n\n\t\treturn new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);\n\t},\n\t// ## _on and _off\n\t// Default _on and _off do nothing.\n\t_on: function(){},\n\t_off: function(){},\n\t// ## get\n\t// Returns the cached value if `bound`, otherwise, returns\n\t// the _get value.\n\tget: function() {\n\t\t// If an external compute is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tvar recordingObservation = Observation.isRecording();\n\t\tif(recordingObservation && this._canObserve !== false) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this computed.\n\t\t\tObservation.add(this, 'change');\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this compute.\n\t\t\tif (!this.bound) {\n\t\t\t\tCompute.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\t\t// If computed is bound, use the cached value.\n\t\tif (this.bound) {\n\t\t\tif(this.observation) {\n\t\t\t\treturn this.observation.get();\n\t\t\t} else {\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._get();\n\t\t}\n\t},\n\t// ## _get\n\t// Returns the cached value.\n\t_get: function() {\n\t\treturn this.value;\n\t},\n\t// ## set\n\t// Sets the value of the compute.\n\t// Depending on the type of the compute and what `_set` returns, it might need to call `_get` after\n\t// `_set` to get the final value.\n\tset: function(newVal) {\n\n\t\tvar old = this.value;\n\n\t\t// Setter may return the value if setter\n\t\t// is for a value maintained exclusively by this compute.\n\t\tvar setVal = this._set(newVal, old);\n\n\t\t// If the setter updated this.value, just return that.\n\t\tif(this._setUpdates) {\n\t\t\treturn this.value;\n\t\t}\n\n\t\t// If the computed function has dependencies,\n\t\t// we should call the getter.\n\t\tif (this.hasDependencies) {\n\t\t\treturn this._get();\n\t\t}\n\n\t\t// Setting may not fire a change event, in which case\n\t\t// the value must be read\n\t\tthis.updater(setVal === undefined ? this._get() : setVal, old);\n\n\t\treturn this.value;\n\t},\n\t// ## _set\n\t// Updates the cached value.\n\t_set: function(newVal) {\n\t\treturn this.value = newVal;\n\t},\n\t// ## updater\n\t// Updates the cached value and fires an event if the value has changed.\n\tupdater: function(newVal, oldVal, batchNum) {\n\t\tthis.value = newVal;\n\t\tif(this.observation) {\n\t\t\t// it's possible the observation doesn't actually\n\t\t\t// have any dependencies\n\t\t\tthis.observation.value = newVal;\n\t\t}\n\t\tupdateOnChange(this, newVal, oldVal, batchNum);\n\t},\n\t// ## toFunction\n\t// Returns a proxy form of this compute.\n\ttoFunction: function() {\n\t\treturn this._computeFn.bind( this);\n\t},\n\t_computeFn: function(newVal) {\n\t\tif(arguments.length) {\n\t\t\treturn this.set(newVal);\n\t\t}\n\n\t\treturn this.get();\n\t}\n\t//!steal-remove-start\n\t,\n\ttrace: function(){\n\t\tvar me = {\n\t\t\tcomputeValue: this.get(),\n\t\t\tdefinition: this.observation && this.observation.func,\n\t\t\tcid: this._cid\n\t\t};\n\n\n\t\tif(this.observation) {\n\t\t\tvar deps = [];\n\t\t\tfor(var name in this.observation.newObserved) {\n\t\t\t\tvar obs = assign({},this.observation.newObserved[name]);\n\t\t\t\tif(obs.obj.isComputed) {\n\t\t\t\t\tdeps.push(obs.obj.trace());\n\n\t\t\t\t} else {\n\t\t\t\t\tdeps.push(obs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tme.dependencies = deps;\n\t\t}\n\t\treturn me;\n\t},\n\tlog: function(){\n\t\tvar log = function(trace){\n\t\t\tvar currentTrace = '';\n\n\t\t\tif(trace.dependencies && trace.dependencies.length) {\n\t\t\t\tcurrentTrace = trace.cid + \" = \" + trace.computeValue;\n\t\t\t\t\n\t\t\t\tif(console && console.group) {\n\t\t\t\t\tconsole.group(currentTrace);\n\t\t\t\t} else {\n\t\t\t\t\tcanLog.log(currentTrace);\n\t\t\t\t}\n\n\t\t\t\ttrace.dependencies.forEach(function(dep){\n\t\t\t\t\tif(dep.hasOwnProperty(\"computeValue\")) {\n\t\t\t\t\t\tlog(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanLog.log(dep.obj, dep.event);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif(console && console.groupEnd) {\n\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcanLog.log(trace.cid +\" - \"+ trace.computeValue);\n\t\t\t}\n\t\t\treturn trace;\n\t\t};\n\n\t\treturn log(this.trace());\n\t}\n\t//!steal-remove-end\n});\n\nCompute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;\nCompute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;\n\nvar k = function(){};\n// A list of temporarily bound computes\nvar computes;\n// Unbinds all temporarily bound computes.\nvar unbindComputes = function () {\n\tfor (var i = 0, len = computes.length; i < len; i++) {\n\t\tcomputes[i].removeEventListener('change', k);\n\t}\n\tcomputes = null;\n};\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nCompute.temporarilyBind = function (compute) {\n\tvar computeInstance = compute.computeInstance || compute;\n\tcomputeInstance.addEventListener('change', k);\n\tif (!computes) {\n\t\tcomputes = [];\n\t\tsetImmediate(unbindComputes);\n\t}\n\tcomputes.push(computeInstance);\n};\n\n// ### async\n// A simple helper that makes an async compute a bit easier.\nCompute.async = function(initialValue, asyncComputer, context){\n\treturn new Compute(initialValue, {\n\t\tfn: asyncComputer,\n\t\tcontext: context\n\t});\n};\n\n\n// ### truthy\n// Wraps a compute with another compute that only changes when\n// the wrapped compute's `truthiness` changes.\nCompute.truthy = function(compute) {\n\treturn new Compute(function() {\n\t\tvar res = compute.get();\n\t\tif(typeof res === 'function') {\n\t\t\tres = res.get();\n\t\t}\n\t\treturn !!res;\n\t});\n};\n\nmodule.exports = exports = Compute;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-compute/proto-compute.js\n// module id = 82\n// module chunks = 0","// # can/control/control.js\n//\n// Create organized, memory-leak free, rapidly performing, stateful\n// controls with declarative eventing binding. Used when creating UI\n// controls with behaviors, bound to elements on the page.\n// ## helpers\n\nvar Construct = require(\"can-construct\");\n\nvar namespace = require(\"can-namespace\");\nvar string = require(\"can-util/js/string/string\");\nvar assign = require(\"can-util/js/assign/assign\");\nvar isFunction = require(\"can-util/js/is-function/is-function\");\nvar each = require(\"can-util/js/each/each\");\nvar dev = require(\"can-util/js/dev/dev\");\nvar types = require(\"can-types\");\nvar get = require(\"can-util/js/get/get\");\nvar domData = require(\"can-util/dom/data/data\");\nvar className = require(\"can-util/dom/class-name/class-name\");\nvar domEvents = require(\"can-util/dom/events/events\");\nvar canEvent = require(\"can-event\");\nvar canCompute = require(\"can-compute\");\nvar observeReader = require('can-observation/reader/reader');\nvar processors;\n\nrequire(\"can-util/dom/dispatch/dispatch\");\nrequire(\"can-util/dom/events/delegate/delegate\");\n\n// ### bind\n// this helper binds to one element and returns a function that unbinds from that element.\nvar bind = function (el, ev, callback) {\n\n    canEvent.on.call(el, ev, callback);\n\n\treturn function () {\n        canEvent.off.call(el, ev, callback);\n\t};\n},\n\tslice = [].slice,\n\tparamReplacer = /\\{([^\\}]+)\\}/g,\n\n\t// ### delegate\n\t//\n\t// this helper binds to elements based on a selector and returns a\n\t// function that unbinds.\n\tdelegate = function (el, selector, ev, callback) {\n        canEvent.on.call(el, ev, selector, callback);\n\n\t\treturn function () {\n            canEvent.off.call(el, ev, selector, callback);\n\t\t};\n\t},\n\n\t// ### binder\n\t//\n\t// Calls bind or unbind depending if there is a selector.\n\tbinder = function (el, ev, callback, selector) {\n\t\treturn selector ?\n\t\t\tdelegate(el, selector.trim(), ev, callback) :\n\t\t\tbind(el, ev, callback);\n\t},\n\n\tbasicProcessor;\n\nvar Control = Construct.extend(\n\t/**\n\t * @add can.Control\n\t */\n\t// ## *static functions*\n\t/**\n\t * @static\n\t */\n\t{\n\t\t// ## can.Control.setup\n\t\t//\n\t\t// This function pre-processes which methods are event listeners and which are methods of\n\t\t// the control. It has a mechanism to allow controllers to inherit default values from super\n\t\t// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)\n\t\t// or functions with an underscored name.\n\t\tsetup: function () {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\tif (Control) {\n\t\t\t\tvar control = this,\n\t\t\t\t\tfuncName;\n\n\t\t\t\tcontrol.actions = {};\n\t\t\t\tfor (funcName in control.prototype) {\n\t\t\t\t\tif (control._isAction(funcName)) {\n\t\t\t\t\t\tcontrol.actions[funcName] = control._action(funcName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## can.Control._shifter\n\t\t//\n\t\t// Moves `this` to the first argument, wraps it with `jQuery` if it's\n\t\t// an element.\n\t\t_shifter: function (context, name) {\n\t\t\tvar method = typeof name === \"string\" ? context[name] : name;\n\n\t\t\tif (!isFunction(method)) {\n\t\t\t\tmethod = context[method];\n\t\t\t}\n\n\t\t\treturn function () {\n\t\t\t\tvar wrapped = types.wrapElement(this);\n\t\t\t\tcontext.called = name;\n\t\t\t\treturn method.apply(context, [wrapped].concat(slice.call(arguments, 0)));\n\t\t\t};\n\t\t},\n\n\t\t// ## can.Control._isAction\n\t\t//\n\t\t// Return `true` if `methodName` refers to an action. An action is a `methodName` value that\n\t\t// is not the constructor, and is either a function or string that refers to a function, or is\n\t\t// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.\n\t\t_isAction: function (methodName) {\n\t\t\tvar val = this.prototype[methodName],\n\t\t\t\ttype = typeof val;\n\n\t\t\treturn (methodName !== 'constructor') &&\n\t\t\t(type === \"function\" || (type === \"string\" && isFunction(this.prototype[val]))) &&\n\t\t\t!! (Control.isSpecial(methodName) || processors[methodName] || /[^\\w]/.test(methodName));\n\t\t},\n\t\t// ## can.Control._action\n\t\t//\n\t\t// Takes a method name and the options passed to a control and tries to return the data\n\t\t// necessary to pass to a processor (something that binds things).\n\t\t//\n\t\t// For performance reasons, `_action` is called twice:\n\t\t// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.\n\t\t// * It is called wehn a control instance is created, but only for templated actions.\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar readyCompute;\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later. If we have\n\t\t\t// options, run `can.sub` to replace the action template `{}` with values from the `options`\n\t\t\t// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.\n\t\t\t// In that case, the event name we want will be the last item in that array.\n\t\t\tparamReplacer.lastIndex = 0;\n\t\t\tif (options || !paramReplacer.test(methodName)) {\n\n\t\t\t\treadyCompute = canCompute(function() {\n\t\t\t\t\tvar delegate;\n\n\t\t\t\t\t// Set the delegate target and get the name of the event we're listening to.\n\t\t\t\t\tvar name = methodName.replace(paramReplacer, function(matched, key) {\n\t\t\t\t\t\tvar value, parent;\n\n\t\t\t\t\t\t// If listening directly to a delegate target, set it\n\t\t\t\t\t\tif (this._isDelegate(options, key)) {\n\t\t\t\t\t\t\tdelegate = this._getDelegate(options, key);\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If key contains part of the lookup path, remove it.\n\t\t\t\t\t\t// This is needed for bindings like {viewModel.foo} in can-component's Control.\n\t\t\t\t\t\tkey = this._removeDelegateFromKey(key);\n\n\t\t\t\t\t\t// set the parent (where the key will be read from)\n\t\t\t\t\t\tparent = this._lookup(options)[0];\n\n\t\t\t\t\t\tvalue = observeReader.read(parent, observeReader.reads(key), {\n\t\t\t\t\t\t\t// if we find a compute, we should bind on that and not read it\n\t\t\t\t\t\t\treadCompute: false\n\t\t\t\t\t\t}).value;\n\n\t\t\t\t\t\t// If `value` is undefined use `string.getObject` to get the value.\n\t\t\t\t\t\tif (value === undefined && typeof window !== 'undefined') {\n\t\t\t\t\t\t\tvalue = get(window, key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the parent is not an observable and we don't have a value, show a warning\n\t\t\t\t\t\t// in this situation, it is not possible for the event handler to be triggered\n\t\t\t\t\t\tif (!parent || !types.isMapLike(parent) && !value) {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tdev.log('can/control/control.js: No property found for handling ' + methodName);\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If `value` is a string we just return it, otherwise we set it as a delegate target.\n\t\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelegate = value;\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\t// removing spaces that get added when converting\n\t\t\t\t\t// `{element} click` -> ` click`\n\t\t\t\t\tname = name.trim();\n\n\t\t\t\t\t// Get the name of the `event` we're listening to.\n\t\t\t\t\tvar parts = name.split(/\\s+/g),\n\t\t\t\t\t\tevent = parts.pop();\n\n\t\t\t\t\t// Return everything needed to handle the event we're listening to.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprocessor: this.processors[event] || basicProcessor,\n\t\t\t\t\t\tparts: [name, parts.join(\" \"), event],\n\t\t\t\t\t\tdelegate: delegate || undefined\n\t\t\t\t\t};\n\t\t\t\t}, this);\n\n\t\t\t\tif (controlInstance) {\n\t\t\t\t\t// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.\n\t\t\t\t\tvar handler = function(ev, ready) {\n\t\t\t\t\t\t// unbinds the old binding\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName](controlInstance.element);\n\t\t\t\t\t\t// binds the new\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName] = ready.processor(\n\t\t\t\t\t\t\tready.delegate || controlInstance.element,\n\t\t\t\t\t\t\tready.parts[2], ready.parts[1], methodName, controlInstance);\n\t\t\t\t\t};\n\n\t\t\t\t\treadyCompute.bind(\"change\", handler);\n\n\t\t\t\t\tcontrolInstance._bindings.readyComputes[methodName] = {\n\t\t\t\t\t\tcompute: readyCompute,\n\t\t\t\t\t\thandler: handler\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn readyCompute();\n\t\t\t}\n\t\t},\n\t\t// the lookup path - where templated keys will be looked up\n\t\t_lookup: function (options) {\n\t\t\treturn [options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key;\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'element';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn undefined;\n\t\t},\n\t\t// ## can.Control.processors\n\t\t//\n\t\t// An object of `{eventName : function}` pairs that Control uses to\n\t\t// hook up events automatically.\n\t\tprocessors: {},\n\t\t// ## can.Control.defaults\n\t\t// A object of name-value pairs that act as default values for a control instance\n\t\tdefaults: {},\n        // should be used to overwrite to make nodeLists on this\n        convertElement: function(element) {\n            element = typeof element === \"string\" ?\n\t\t\t\t\t\t\tdocument.querySelector(element) : element;\n\n\t\t\t\t\t\treturn types.wrapElement(element);\n        },\n        // should be overwritten to look in jquery special events\n        isSpecial: function(eventName){\n            return eventName === \"inserted\" || eventName === \"removed\";\n        }\n\t}, {\n\t\t// ## *prototype functions*\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// ## setup\n\t\t//\n\t\t// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:\n\t\t// - Sets `this.element`\n\t\t// - Adds the Control's name to the element's className\n\t\t// - Saves the Control in `$.data`\n\t\t// - Merges Options\n\t\t// - Binds event handlers using `delegate`\n\t\t// The final step is to return pass the element and prepareed options, to be used in `init`.\n\t\tsetup: function (element, options) {\n\n\t\t\tvar cls = this.constructor,\n\t\t\t\tpluginname = cls.pluginName || cls.shortName,\n\t\t\t\tarr;\n\n\t\t\tif (!element) {\n\t\t\t\tthrow new Error('Creating an instance of a named control without passing an element');\n\t\t\t}\n\t\t\t// Retrieve the raw element, then set the plugin name as a class there.\n      this.element = cls.convertElement(element);\n\n\t\t\tif (pluginname && pluginname !== 'can_control') {\n\t\t\t\tclassName.add.call(this.element, pluginname);\n\t\t\t}\n\n\t\t\t// Set up the 'controls' data on the element. If it does not exist, initialize\n\t\t\t// it to an empty array.\n\t\t\tarr = domData.get.call(this.element, 'controls');\n\t\t\tif (!arr) {\n\t\t\t\tarr = [];\n\t\t\t\tdomData.set.call(this.element, 'controls', arr);\n\t\t\t}\n\t\t\tarr.push(this);\n\n\t\t\t// The `this.options` property is an Object that contains configuration data\n\t\t\t// passed to a control when it is created (`new can.Control(element, options)`)\n\t\t\t//\n\t\t\t// The `options` argument passed when creating the control is merged with `can.Control.defaults`\n\t\t\t// in [can.Control.prototype.setup setup].\n\t\t\t//\n\t\t\t// If no `options` value is used during creation, the value in `defaults` is used instead\n\t\t\tif (types.isMapLike(options)) {\n\t\t\t\tfor (var prop in cls.defaults) {\n\t\t\t\t\tif (!options.hasOwnProperty(prop)) {\n\t\t\t\t\t\tobserveReader.set(options, prop, cls.defaults[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.options = options;\n\t\t\t} else {\n\t\t\t\tthis.options = assign( assign({}, cls.defaults), options);\n\t\t\t}\n\n\t\t\tthis.on();\n\n\t\t\treturn [this.element, this.options];\n\t\t},\n\t\t// ## on\n\t\t//\n\t\t// This binds an event handler for an event to a selector under the scope of `this.element`\n\t\t// If no options are specified, all events are rebound to their respective elements. The actions,\n\t\t// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.\n\t\ton: function (el, selector, eventName, func) {\n\t\t\tif (!el) {\n\t\t\t\tthis.off();\n\n\t\t\t\tvar cls = this.constructor,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tactions = cls.actions,\n\t\t\t\t\telement = types.unwrapElement(this.element),\n\t\t\t\t\tdestroyCB = Control._shifter(this, \"destroy\"),\n\t\t\t\t\tfuncName, ready;\n\n\t\t\t\tfor (funcName in actions) {\n\t\t\t\t\t// Only push if we have the action and no option is `undefined`\n\t\t\t\t\tif ( actions.hasOwnProperty(funcName) ) {\n\t\t\t\t\t\tready = actions[funcName] || cls._action(funcName, this.options, this);\n\t\t\t\t\t\tif( ready ) {\n\t\t\t\t\t\t\tbindings.control[funcName]  = ready.processor(ready.delegate || element,\n\t\t\t\t\t\t\t\tready.parts[2], ready.parts[1], funcName, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set up the ability to `destroy` the control later.\n\t\t\t\tdomEvents.addEventListener.call(element, \"removed\", destroyCB);\n\t\t\t\tbindings.user.push(function (el) {\n\t\t\t\t\tdomEvents.removeEventListener.call(el, \"removed\", destroyCB);\n\t\t\t\t});\n\t\t\t\treturn bindings.user.length;\n\t\t\t}\n\n\t\t\t// if `el` is a string, use that as `selector` and re-set it to this control's element...\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = el;\n\t\t\t\tel = this.element;\n\t\t\t}\n\n\t\t\t// ...otherwise, set `selector` to null\n\t\t\tif (func === undefined) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = null;\n\t\t\t}\n\n\t\t\tif (typeof func === 'string') {\n\t\t\t\tfunc = Control._shifter(this, func);\n\t\t\t}\n\n\t\t\tthis._bindings.user.push(binder(el, eventName, func, selector));\n\n\t\t\treturn this._bindings.user.length;\n\t\t},\n\t\t// ## off\n\t\t//\n\t\t// Unbinds all event handlers on the controller.\n\t\t// This should _only_ be called in combination with .on()\n\t\toff: function () {\n\t\t\tvar el = types.unwrapElement(this.element),\n\t\t\t\tbindings = this._bindings;\n\t\t\tif( bindings ) {\n\t\t\t\teach(bindings.user || [], function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\teach(bindings.control || {}, function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\teach(bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tvalue.compute.unbind(\"change\", value.handler);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Adds bindings.\n\t\t\tthis._bindings = {user: [], control: {}, readyComputes: {}};\n\t\t},\n\t\t// ## destroy\n\t\t//\n\t\t// Prepares a `control` for garbage collection.\n\t\t// First checks if it has already been removed. Then, removes all the bindings, data, and\n\t\t// the element from the Control instance.\n\t\tdestroy: function () {\n\t\t\tif (this.element === null) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tdev.warn(\"can/control/control.js: Control already destroyed\");\n\t\t\t\t//!steal-remove-end\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar Class = this.constructor,\n\t\t\t\tpluginName = Class.pluginName || (Class.shortName && string.underscore(Class.shortName)),\n\t\t\t\tcontrols;\n\n\t\t\tthis.off();\n\n\t\t\tif (pluginName && pluginName !== 'can_control') {\n\t\t\t\tclassName.remove.call(this.element, pluginName);\n\t\t\t}\n\n\t\t\tcontrols = domData.get.call(this.element, \"controls\");\n\t\t\tif (controls) {\n\t\t\t\tcontrols.splice(controls.indexOf(this), 1);\n\t\t\t}\n\n\t\t\tcanEvent.dispatch.call(this, \"destroyed\");\n\n\t\t\tthis.element = null;\n\t\t}\n\t});\n\n// ## Processors\n//\n// Processors do the binding. This basic processor binds events. Each returns a function that unbinds\n// when called.\nprocessors = Control.processors;\nbasicProcessor = function (el, event, selector, methodName, control) {\n\treturn binder(el, event, Control._shifter(control, methodName), selector);\n};\n\n// Set common events to be processed as a `basicProcessor`\neach([\"beforeremove\", \"change\", \"click\", \"contextmenu\", \"dblclick\", \"keydown\", \"keyup\",\n\t\"keypress\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\",\n\t\"mouseup\", \"reset\", \"resize\", \"scroll\", \"select\", \"submit\", \"focusin\",\n\t\"focusout\", \"mouseenter\", \"mouseleave\",\n\t\"touchstart\", \"touchmove\", \"touchcancel\", \"touchend\", \"touchleave\",\n\t\"inserted\",\"removed\",\n\t\"dragstart\", \"dragenter\", \"dragover\", \"dragleave\", \"drag\", \"drop\", \"dragend\"\n], function (v) {\n\tprocessors[v] = basicProcessor;\n});\n\nmodule.exports = namespace.Control = Control;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-control/can-control.js\n// module id = 83\n// module chunks = 0","'use strict';\n\nvar events = require('can-util/dom/events/events');\nvar domData = require('can-util/dom/data/data');\nvar getDocument = require('can-util/dom/document/document');\nvar domDispatch = require('can-util/dom/dispatch/dispatch');\nvar CIDMap = require('can-util/js/cid-map/cid-map');\n\nfunction getRoot () {\n\treturn getDocument().documentElement;\n}\n\nfunction getRegistryName (eventName) {\n\treturn 'can-event-radiochange:' + eventName + ':registry';\n}\n\nfunction getListenerName (eventName) {\n\treturn 'can-event-radiochange:' + eventName + ':listener';\n}\n\nfunction getRegistry (eventName) {\n\tvar root = getRoot();\n\tvar name = getRegistryName(eventName);\n\tvar registry = domData.get.call(root, name);\n\tif (!registry) {\n\t\tregistry = new CIDMap();\n\t\tdomData.set.call(root, name, registry);\n\t}\n\treturn registry;\n}\n\nfunction findParentForm (el) {\n\twhile (el) {\n\t\tif (el.nodeName === 'FORM') {\n\t\t\tbreak;\n\t\t}\n\t\tel = el.parentNode;\n\t}\n\treturn el;\n}\n\nfunction shouldReceiveEventFromRadio (source, dest) {\n\t// Must have the same name attribute and parent form\n\tvar name = source.getAttribute('name');\n\treturn (\n\t\tname &&\n\t\tname === dest.getAttribute('name') &&\n\t\tfindParentForm(source) === findParentForm(dest)\n\t);\n}\n\nfunction isRadioInput (el) {\n\treturn el.nodeName === 'INPUT' && el.type === 'radio';\n}\n\nfunction dispatch (eventName, target) {\n\tvar registry = getRegistry(eventName);\n\tvar event = {type: eventName};\n\tregistry.forEach(function (el) {\n\t\tif (shouldReceiveEventFromRadio(target, el)) {\n\t\t\tdomDispatch.call(el, event, [], false);\n\t\t}\n\t});\n}\n\nfunction attachRootListener (eventName) {\n\tvar root = getRoot();\n\tvar listenerName = getListenerName(eventName);\n\tvar listener = domData.get.call(root, listenerName);\n\tif (listener) {\n\t\treturn;\n\t}\n\tvar newListener = function (event) {\n\t\tvar target = event.target;\n\t\tif (isRadioInput(target)) {\n\t\t\tdispatch(eventName, target);\n\t\t}\n\t};\n\tevents.addEventListener.call(root, 'change', newListener);\n\tdomData.set.call(root, listenerName, newListener);\n}\n\nfunction detachRootListener (eventName) {\n\tvar root = getRoot();\n\tvar listenerName = getListenerName(eventName);\n\tvar listener = domData.get.call(root, listenerName);\n\tif (!listener) {\n\t\treturn;\n\t}\n\tvar registry = getRegistry(eventName);\n\tif (registry.size > 0) {\n\t\treturn;\n\t}\n\tevents.removeEventListener.call(root, 'change', listener);\n\tdomData.clean.call(root, listenerName);\n}\n\nfunction addListener (eventName, el) {\n\tif (!isRadioInput(el)) {\n\t\tthrow new Error('Listeners for ' + eventName + ' must be radio inputs');\n\t}\n\tgetRegistry(eventName).set(el, el);\n\tattachRootListener(eventName);\n}\n\nfunction removeListener (eventName, el) {\n\tgetRegistry(eventName).delete(el);\n\tdetachRootListener(eventName);\n}\n\n/**\n * @module {events} can-event-radiochange can-event-radiochange\n * @parent can-infrastructure\n *\n * A custom event for listening to changes of inputs with type \"radio\",\n * which fires when a conflicting radio input changes. A \"conflicting\"\n * radio button has the same \"name\" attribute and exists within in the\n * same form, or lack thereof. This event coordinates state bound to\n * whether a radio is checked. The \"change\" event does not fire for deselected\n * radios. By using this event instead, deselected radios receive notification.\n *\n * ```js\n * var events = require(\"can-util/dom/events/events\");\n * var radioChange = require(\"can-util/dom/events/radiochange/radiochange\");\n * events.addCustomEvent(radioChange);\n *\n * var el = document.createElement(\"div\");\n *\n * function radiochangeHandler() {\n * \tconsole.log(\"radiochange event fired\");\n * }\n *\n * events.addEventListener.call(el, \"radiochange\", radiochangeHandler, false);\n * events.removeEventListener.call(el, \"radiochange\", radiochangeHandler);\n *\n * events.removeCustomEvent(radioChange);\n * ```\n */\nmodule.exports = {\n\teventName: 'radiochange',\n\tapplyEventListener: true,\n\n\taddEventListener: function addEventListener (eventName) {\n\t\taddListener(eventName, this);\n\t},\n\n\tremoveEventListener: function removeEventListener (eventName) {\n\t\tremoveListener(eventName, this);\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-event-radiochange/can-event-radiochange.js\n// module id = 84\n// module chunks = 0","var radioChange = require('./can-event-radiochange');\n\n/*\n\tThis module conforms to the current custom event\n\toverriding behavior which will be replaced by the\n\tend result of https://github.com/canjs/can-util/issues/249.\n\n\tUntil then (and for older can-util versions), this\n\tmodule is a means on including the radiochange event.\n*/\n\nfunction isDomEvents (obj) {\n\treturn !!(obj && obj.addEventListener && obj.removeEventListener);\n}\n\nfunction override (domEvents) {\n\tif (!isDomEvents(domEvents)) {\n\t\tthrow new Error ('override() must be passed domEvents');\n\t}\n\n\tvar isOverriding = true;\n\tvar oldAddEventListener = domEvents.addEventListener;\n\tvar addEventListener = domEvents.addEventListener = function (eventName) {\n\t\tif (isOverriding && eventName === radioChange.eventName) {\n\t\t\tradioChange.addEventListener.apply(this, arguments);\n\t\t}\n\t\treturn oldAddEventListener.apply(this, arguments);\n\t};\n\n\tvar oldRemoveEventListener = domEvents.removeEventListener;\n\tvar removeEventListener = domEvents.removeEventListener = function (eventName) {\n\t\tif (isOverriding && eventName === radioChange.eventName) {\n\t\t\tradioChange.removeEventListener.apply(this, arguments);\n\t\t}\n\t\treturn oldRemoveEventListener.apply(this, arguments);\n\t};\n\n\treturn function removeOverride () {\n\t\tisOverriding = false;\n\t\tif (domEvents.addEventListener === addEventListener) {\n\t\t\tdomEvents.addEventListener = oldAddEventListener;\n\t\t}\n\t\tif (domEvents.removeEventListener === removeEventListener) {\n\t\t\tdomEvents.removeEventListener = oldRemoveEventListener;\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\toverride: override\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-event-radiochange/override.js\n// module id = 85\n// module chunks = 0","// # can-stache-bindings.js\n//\n// This module provides CanJS's default data and event bindings.\n// It's broken up into several parts:\n//\n// - Behaviors - Binding behaviors that run given an attribute or element.\n// - Attribute Syntaxes - Hooks up custom attributes to their behaviors.\n// - getComputeFrom - Methods that return a compute cross bound to the scope, viewModel, or element.\n// - bind - Methods for setting up cross binding\n// - getBindingInfo - A helper that returns the details of a data binding given an attribute.\n// - makeDataBinding - A helper method for setting up a data binding.\n// - initializeValues - A helper that initializes a data binding.\nvar expression = require('can-stache/src/expression');\nvar viewCallbacks = require('can-view-callbacks');\nvar live = require('can-view-live');\nvar Scope = require('can-view-scope');\nvar canViewModel = require('can-view-model');\nvar canEvent = require('can-event');\nvar canBatch = require('can-event/batch/batch');\nvar compute = require('can-compute');\nvar observeReader = require('can-observation/reader/reader');\nvar Observation = require('can-observation');\n\nvar assign = require('can-util/js/assign/assign');\nvar makeArray  = require('can-util/js/make-array/make-array');\nvar each  = require('can-util/js/each/each');\nvar string = require('can-util/js/string/string');\nvar dev = require('can-util/js/dev/dev');\nvar types = require('can-types');\nvar last = require('can-util/js/last/last');\n\nvar getMutationObserver = require('can-util/dom/mutation-observer/mutation-observer');\nvar domEvents = require('can-util/dom/events/events');\nrequire('can-util/dom/events/removed/removed');\nrequire('can-event-radiochange/override').override(domEvents);\nvar domData = require('can-util/dom/data/data');\nvar attr = require('can-util/dom/attr/attr');\nvar canLog = require('can-util/js/log/log');\nvar stacheHelperCore = require(\"can-stache/helpers/core\");\n\n\t// ## Behaviors\n\tvar behaviors = {\n\t\t// ### bindings.behaviors.viewModel\n\t\t// Sets up all of an element's data binding attributes to a \"soon-to-be-created\"\n\t\t// `viewModel`.\n\t\t// This is primarily used by `can.Component` to ensure that its\n\t\t// `viewModel` is initialized with values from the data bindings as quickly as possible.\n\t\t// Component could look up the data binding values itself.  However, that lookup\n\t\t// would have to be duplicated when the bindings are established.\n\t\t// Instead, this uses the `makeDataBinding` helper, which allows creation of the `viewModel`\n\t\t// after scope values have been looked up.\n\t\t//\n\t\t// - `makeViewModel(initialViewModelData)` - a function that returns the `viewModel`.\n\t\t// - `initialViewModelData` any initial data that should already be added to the `viewModel`.\n\t\t//\n\t\t// Returns:\n\t\t// - `function` - a function that tears all the bindings down. Component\n\t\t// wants all the bindings active so cleanup can be done during a component being removed.\n\t\tviewModel: function(el, tagData, makeViewModel, initialViewModelData){\n\t\t\tinitialViewModelData = initialViewModelData || {};\n\n\t\t\tvar bindingsSemaphore = {},\n\t\t\t\tviewModel,\n\t\t\t\t// Stores callbacks for when the viewModel is created.\n\t\t\t\tonCompleteBindings = [],\n\t\t\t\t// Stores what needs to be called when the element is removed\n\t\t\t\t// to prevent memory leaks.\n\t\t\t\tonTeardowns = {},\n\t\t\t\t// Track info about each binding, we need this for binding attributes correctly.\n\t\t\t\tbindingInfos = {},\n\t\t\t\tattributeViewModelBindings = assign({}, initialViewModelData);\n\n\t\t\t// For each attribute, we start the binding process,\n\t\t\t// and save what's returned to be used when the `viewModel` is created,\n\t\t\t// the element is removed, or the attribute changes values.\n\t\t\teach( makeArray(el.attributes), function(node){\n\n\t\t\t\tvar dataBinding = makeDataBinding(node, el, {\n\t\t\t\t\ttemplateType: tagData.templateType,\n\t\t\t\t\tscope: tagData.scope,\n\t\t\t\t\tsemaphore: bindingsSemaphore,\n\t\t\t\t\tgetViewModel: function(){\n\t\t\t\t\t\treturn viewModel;\n\t\t\t\t\t},\n\t\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\t\talreadyUpdatedChild: true,\n\t\t\t\t\tnodeList: tagData.parentNodeList\n\t\t\t\t});\n\t\t\t\tif(dataBinding) {\n\t\t\t\t\t// For bindings that change the viewModel,\n\t\t\t\t\tif(dataBinding.onCompleteBinding) {\n\t\t\t\t\t\t// save the initial value on the viewModel.\n\t\t\t\t\t\tif(dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {\n\t\t\t\t\t\t\tinitialViewModelData[cleanVMName(dataBinding.bindingInfo.childName)] = dataBinding.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Save what needs to happen after the `viewModel` is created.\n\t\t\t\t\t\tonCompleteBindings.push(dataBinding.onCompleteBinding);\n\t\t\t\t\t}\n\t\t\t\t\tonTeardowns[node.name] = dataBinding.onTeardown;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// Create the `viewModel` and call what needs to be happen after\n\t\t\t// the `viewModel` is created.\n\t\t\tviewModel = makeViewModel(initialViewModelData);\n\n\t\t\tfor(var i = 0, len = onCompleteBindings.length; i < len; i++) {\n\t\t\t\tonCompleteBindings[i]();\n\t\t\t}\n\n\t\t\t// Listen to attribute changes and re-initialize\n\t\t\t// the bindings.\n\t\t\tdomEvents.addEventListener.call(el, \"attributes\", function (ev) {\n\t\t\t\tvar attrName = ev.attributeName,\n\t\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\t\tif( onTeardowns[attrName] ) {\n\t\t\t\t\tonTeardowns[attrName]();\n\t\t\t\t}\n\t\t\t\t// Parent attribute bindings we always re-setup.\n\t\t\t\tvar parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === \"attribute\";\n\n\t\t\t\tif(value !== null || parentBindingWasAttribute ) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({name: attrName, value: value}, el, {\n\t\t\t\t\t\ttemplateType: tagData.templateType,\n\t\t\t\t\t\tscope: tagData.scope,\n\t\t\t\t\t\tsemaphore: {},\n\t\t\t\t\t\tgetViewModel: function(){\n\t\t\t\t\t\t\treturn viewModel;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\t\t\t// always update the viewModel accordingly.\n\t\t\t\t\t\tinitializeValues: true,\n\t\t\t\t\t\tnodeList: tagData.parentNodeList\n\t\t\t\t\t});\n\t\t\t\t\tif(dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tif(dataBinding.onCompleteBinding) {\n\t\t\t\t\t\t\tdataBinding.onCompleteBinding();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbindingInfos[attrName] = dataBinding.bindingInfo;\n\t\t\t\t\t\tonTeardowns[attrName] = dataBinding.onTeardown;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn function(){\n\t\t\t\tfor(var attrName in onTeardowns) {\n\t\t\t\t\tonTeardowns[attrName]();\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t// ### bindings.behaviors.data\n\t\t// This is called when an individual data binding attribute is placed on an element.\n\t\t// For example `{^value}=\"name\"`.\n\t\tdata: function(el, attrData){\n\t\t\tif(domData.get.call(el,\"preventDataBindings\")){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar viewModel = canViewModel(el),\n\t\t\t\tsemaphore = {},\n\t\t\t\tteardown;\n\n\t\t\t// If a two-way binding, take extra measure to ensure\n\t\t\t//  that parent and child sync values properly.\n\t\t\tvar twoWay = bindingsRegExp.exec(attrData.attributeName)[1];\n\n\t\t\t// Setup binding\n\t\t\tvar dataBinding = makeDataBinding({\n\t\t\t\tname: attrData.attributeName,\n\t\t\t\tvalue: el.getAttribute(attrData.attributeName),\n\t\t\t\tnodeList: attrData.nodeList\n\t\t\t}, el, {\n\t\t\t\ttemplateType: attrData.templateType,\n\t\t\t\tscope: attrData.scope,\n\t\t\t\tsemaphore: semaphore,\n\t\t\t\tgetViewModel: function(){\n\t\t\t\t\treturn viewModel;\n\t\t\t\t},\n\t\t\t\tsyncChildWithParent: twoWay\n\t\t\t});\n\n\t\t\tif(dataBinding.onCompleteBinding) {\n\t\t\t\tdataBinding.onCompleteBinding();\n\t\t\t}\n\t\t\tteardown = dataBinding.onTeardown;\n\t\t\tcanEvent.one.call(el, 'removed', function(){\n\t\t\t\tteardown();\n\t\t\t});\n\n\t\t\t// Listen for changes\n\t\t\tdomEvents.addEventListener.call(el, \"attributes\", function (ev) {\n\t\t\t\tvar attrName = ev.attributeName,\n\t\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\t\tif( attrName === attrData.attributeName ) {\n\n\t\t\t\t\tif( teardown ) {\n\t\t\t\t\t\tteardown();\n\t\t\t\t\t}\n\n\t\t\t\t\tif(value !== null  ) {\n\n\t\t\t\t\t\tvar dataBinding = makeDataBinding({name: attrName, value: value}, el, {\n\t\t\t\t\t\t\ttemplateType: attrData.templateType,\n\t\t\t\t\t\t\tscope: attrData.scope,\n\t\t\t\t\t\t\tsemaphore: semaphore,\n\t\t\t\t\t\t\tgetViewModel: function(){\n\t\t\t\t\t\t\t\treturn viewModel;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// always update the viewModel accordingly.\n\t\t\t\t\t\t\tinitializeValues: true,\n\t\t\t\t\t\t\tnodeList: attrData.nodeList,\n\t\t\t\t\t\t\tsyncChildWithParent: twoWay\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(dataBinding) {\n\t\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\t\tif(dataBinding.onCompleteBinding) {\n\t\t\t\t\t\t\t\tdataBinding.onCompleteBinding();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tteardown = dataBinding.onTeardown;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t// ### bindings.behaviors.reference\n\t\t// Provides the shorthand `*ref` behavior that exports the `viewModel`.\n\t\t// For example `{^value}=\"name\"`.\n\t\treference: function(el, attrData) {\n\t\t\tif(el.getAttribute(attrData.attributeName)) {\n\t\t\t\tcanLog.warn(\"*reference attributes can only export the view model.\");\n\t\t\t}\n\n\t\t\tvar name = string.camelize( attrData.attributeName.substr(1).toLowerCase() );\n\n\t\t\tvar viewModel = canViewModel(el);\n\t\t\tvar refs = attrData.scope.getRefs();\n\t\t\trefs._context.attr(\"*\"+name, viewModel);\n\t\t},\n\t\t// ### bindings.behaviors.event\n\t\t// The following section contains code for implementing the can-EVENT attribute.\n\t\t// This binds on a wildcard attribute name. Whenever a view is being processed\n\t\t// and can-xxx (anything starting with can-), this callback will be run.  Inside, its setting up an event handler\n\t\t// that calls a method identified by the value of this attribute.\n\t\tevent: function(el, data) {\n\n\t\t\t// Get the `event` name and if we are listening to the element or viewModel.\n\t\t\t// The attribute name is the name of the event.\n\t\t\tvar attributeName = data.attributeName,\n\t\t\t// The old way of binding is can-X\n\t\t\t\tlegacyBinding = attributeName.indexOf('can-') === 0,\n\t\t\t\tevent = attributeName.indexOf('can-') === 0 ?\n\t\t\t\t\tattributeName.substr(\"can-\".length) :\n\t\t\t\t\tremoveBrackets(attributeName, '(', ')'),\n\t\t\t\tonBindElement = legacyBinding;\n\n\t\t\tevent = decodeAttrName(event);\n\n\t\t\tif(event.charAt(0) === \"$\") {\n\t\t\t\tevent = event.substr(1);\n\t\t\t\tonBindElement = true;\n\t\t\t}\n\n\t\t\t// This is the method that the event will initially trigger. It will look up the method by the string name\n\t\t\t// passed in the attribute and call it.\n\t\t\tvar handler = function (ev) {\n\t\t\t\t\tvar attrVal = el.getAttribute(attributeName);\n\t\t\t\t\tif (!attrVal) { return; }\n\n\t\t\t\t\tvar viewModel = canViewModel(el);\n\n\t\t\t\t\t// expression.parse will read the attribute\n\t\t\t\t\t// value and parse it identically to how mustache helpers\n\t\t\t\t\t// get parsed.\n\t\t\t\t\tvar expr = expression.parse(removeBrackets(attrVal),{\n\t\t\t\t\t\tlookupRule: function(){\n\t\t\t\t\t\t\treturn expression.Lookup;\n\t\t\t\t\t\t}, methodRule: \"call\"});\n\n\t\t\t\t\tif(!(expr instanceof expression.Call) && !(expr instanceof expression.Helper)) {\n\n\t\t\t\t\t\tvar defaultArgs = [data.scope._context, el].concat(makeArray(arguments)).map(function(data){\n\t\t\t\t\t\t\treturn new expression.Arg(new expression.Literal(data));\n\t\t\t\t\t\t});\n\t\t\t\t\t\texpr = new expression.Call(expr, defaultArgs, {} );\n\t\t\t\t\t}\n\n\t\t\t\t\t// make a scope with these things just under\n\t\t\t\t\tvar localScope = data.scope.add({\n\t\t\t\t\t\t\"@element\": el,\n\t\t\t\t\t\t\"@event\": ev,\n\t\t\t\t\t\t\"@viewModel\": viewModel,\n\t\t\t\t\t\t\"@scope\": data.scope,\n\t\t\t\t\t\t\"@context\": data.scope._context,\n\n\t\t\t\t\t\t\"%element\": this,\n\t\t\t\t\t\t\"$element\": types.wrapElement(el),\n\t\t\t\t\t\t\"%event\": ev,\n\t\t\t\t\t\t\"%viewModel\": viewModel,\n\t\t\t\t\t\t\"%scope\": data.scope,\n\t\t\t\t\t\t\"%context\": data.scope._context,\n\t\t\t\t\t\t\"%arguments\": arguments\n\t\t\t\t\t},{\n\t\t\t\t\t\tnotContext: true\n\t\t\t\t\t});\n\n\n\t\t\t\t\t// We grab the first item and treat it as a method that\n\t\t\t\t\t// we'll call.\n\t\t\t\t\tvar scopeData = localScope.read(expr.methodExpr.key, {\n\t\t\t\t\t\tisArgument: true\n\t\t\t\t\t}), args, stacheHelper, stacheHelperResult;\n\n\t\t\t\t\tif (!scopeData.value) {\n\t\t\t\t\t\t// nothing found yet, look for a stache helper\n\t\t\t\t\t\tvar name = observeReader.reads(expr.methodExpr.key).map(function(part){\n\t\t\t\t\t\t\treturn part.key;\n\t\t\t\t\t\t}).join(\".\");\n\n\t\t\t\t\t\tstacheHelper = stacheHelperCore.getHelper(name);\n\t\t\t\t\t\tif(stacheHelper){\n\t\t\t\t\t\t\targs = expr.args(localScope, null)();\n\t\t\t\t\t\t\tstacheHelperResult = stacheHelper.fn.apply(localScope.peek(\".\"), args);\n\t\t\t\t\t\t\tif(typeof stacheHelperResult === \"function\"){\n\t\t\t\t\t\t\t  stacheHelperResult(el);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn stacheHelperResult;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tdev.warn(\"can-stache-bindings: \" + attributeName + \" couldn't find method named \" + expr.methodExpr.key, {\n\t\t\t\t\t\t\telement: el,\n\t\t\t\t\t\t\tscope: data.scope\n\t\t\t\t\t\t});\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\targs = expr.args(localScope, null)();\n\t\t\t\t\treturn scopeData.value.apply(scopeData.parent, args);\n\t\t\t\t};\n\n\t\t\t// This code adds support for special event types, like can-enter=\"foo\". special.enter (or any special[event]) is\n\t\t\t// a function that returns an object containing an event and a handler. These are to be used for binding. For example,\n\t\t\t// when a user adds a can-enter attribute, we'll bind on the keyup event, and the handler performs special logic to\n\t\t\t// determine on keyup if the enter key was pressed.\n\t\t\tif (special[event]) {\n\t\t\t\tvar specialData = special[event](data, el, handler);\n\t\t\t\thandler = specialData.handler;\n\t\t\t\tevent = specialData.event;\n\t\t\t}\n\n\t\t\tvar context;\n\t\t\tif(onBindElement){\n\t\t\t\tcontext = el;\n\t\t\t}else{\n\t\t\t\tif(event.indexOf(\" \") >= 0){\n\t\t\t\t\tvar eventSplit = event.split(\" \");\n\t\t\t\t\tcontext = data.scope.get(eventSplit[0]);\n\t\t\t\t\tevent = eventSplit[1];\n\t\t\t\t}else{\n\t\t\t\t\tcontext = canViewModel(el);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unbind the event when the attribute is removed from the DOM\n\t\t\tvar attributesHandler = function(ev) {\n\t\t\t\tvar isEventAttribute = ev.attributeName === attributeName;\n\t\t\t\tvar isRemoved = !this.getAttribute(attributeName);\n\t\t\t\tvar isEventAttributeRemoved = isEventAttribute && isRemoved;\n\t\t\t\tif (isEventAttributeRemoved) {\n\t\t\t\t\tunbindEvent();\n\t\t\t\t}\n\t\t\t};\n\t\t\t// Unbind the event when the target is removed from the DOM\n\t\t\tvar removedHandler = function(ev) {\n\t\t\t\tunbindEvent();\n\t\t\t};\n\t\t\tvar unbindEvent = function() {\n\t\t\t\tcanEvent.off.call(context, event, handler);\n\t\t\t\tcanEvent.off.call(el, 'attributes', attributesHandler);\n\t\t\t\tcanEvent.off.call(el, 'removed', removedHandler);\n\t\t\t};\n\n\t\t\t// Bind the handler defined above to the element we're currently processing and the event name provided in this\n\t\t\t// attribute name (can-click=\"foo\")\n\t\t\tcanEvent.on.call(context, event, handler);\n\t\t\tcanEvent.on.call(el, 'attributes', attributesHandler);\n\t\t\tcanEvent.on.call(el, 'removed', removedHandler);\n\t\t},\n\t\t// ### bindings.behaviors.value\n\t\t// Behavior for the deprecated can-value\n\t\tvalue: function(el, data) {\n\t\t\tvar propName = \"$value\",\n\t\t\t\tattrValue = removeBrackets(el.getAttribute(\"can-value\")).trim(),\n\t\t\t\tnodeName = el.nodeName.toLowerCase(),\n\t\t\t\telType = nodeName === \"input\" && (el.type || el.getAttribute(\"type\")),\n\t\t\t\tgetterSetter;\n\n\t\t\tif (nodeName === \"input\" && (elType === \"checkbox\" || elType === \"radio\")) {\n\n\t\t\t\tvar property = getComputeFrom.scope(el, data.scope, attrValue, {}, true);\n\t\t\t\tif (el.type === \"checkbox\") {\n\n\t\t\t\t\tvar trueValue = attr.has(el, \"can-true-value\") ? el.getAttribute(\"can-true-value\") : true,\n\t\t\t\t\t\tfalseValue = attr.has(el, \"can-false-value\") ? el.getAttribute(\"can-false-value\") : false;\n\n\t\t\t\t\tgetterSetter = compute(function (newValue) {\n\t\t\t\t\t\t// jshint eqeqeq: false\n\t\t\t\t\t\tvar isSet = arguments.length !== 0;\n\t\t\t\t\t\tvar isCompute = property && property.isComputed;\n\t\t\t\t\t\tif (isCompute) {\n\t\t\t\t\t\t\tif (isSet) {\n\t\t\t\t\t\t\t\tproperty(newValue ? trueValue : falseValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn property() == trueValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (isSet) {\n\t\t\t\t\t\t\t\t// TODO: https://github.com/canjs/can-stache-bindings/issues/180\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn property == trueValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if(elType === \"radio\") {\n\t\t\t\t\t// radio is two-way bound to if the property value\n\t\t\t\t\t// equals the element value\n\t\t\t\t\tgetterSetter = compute(function (newValue) {\n\t\t\t\t\t\t// jshint eqeqeq: false\n\t\t\t\t\t\tvar isSet = arguments.length !== 0 && newValue;\n\t\t\t\t\t\tvar isCompute = property && property.isComputed;\n\t\t\t\t\t\tif (isCompute) {\n\t\t\t\t\t\t\tif (isSet) {\n\t\t\t\t\t\t\t\tproperty(el.value);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn property() == el.value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (isSet) {\n\t\t\t\t\t\t\t\t// TODO: https://github.com/canjs/can-stache-bindings/issues/180\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn property == el.value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tpropName = \"$checked\";\n\t\t\t\tattrValue = \"getterSetter\";\n\t\t\t\tdata.scope = new Scope({\n\t\t\t\t\tgetterSetter: getterSetter\n\t\t\t\t});\n\t\t\t}\n\t\t\t// For contenteditable elements, we instantiate a Content control.\n\t\t\telse if (isContentEditable(el)) {\n\t\t\t\tpropName = \"$innerHTML\";\n\t\t\t}\n\n\t\t\tvar dataBinding = makeDataBinding({\n\t\t\t\tname: \"{(\" + propName + \"})\",\n\t\t\t\tvalue: attrValue\n\t\t\t}, el, {\n\t\t\t\ttemplateType: data.templateType,\n\t\t\t\tscope: data.scope,\n\t\t\t\tsemaphore: {},\n\t\t\t\tinitializeValues: true,\n\t\t\t\tlegacyBindings: true\n\t\t\t});\n\n\t\t\tcanEvent.one.call(el, \"removed\", function(){\n\t\t\t\tdataBinding.onTeardown();\n\t\t\t});\n\n\t\t}\n\t};\n\n\n\t// ## Attribute Syntaxes\n\t// The following sets up the bindings functions to be called\n\t// when called in a template.\n\n\t// `{}=\"bar\"` data bindings.\n\tviewCallbacks.attr(/^\\{[^\\}]+\\}$/, behaviors.data);\n\n\t// `*ref-export` shorthand.\n\tviewCallbacks.attr(/\\*[\\w\\.\\-_]+/, behaviors.reference);\n\n\t// `(EVENT)` event bindings.\n\tviewCallbacks.attr(/^\\([\\$?\\w\\.\\\\]+\\)$/, behaviors.event);\n\n\n\t//!steal-remove-start\n\tfunction syntaxWarning(el, attrData) {\n\t\tdev.warn('can-stache-bindings: mismatched binding syntax - ' + attrData.attributeName);\n\t}\n\tviewCallbacks.attr(/^\\(.+\\}$/, syntaxWarning);\n\tviewCallbacks.attr(/^\\{.+\\)$/, syntaxWarning);\n\tviewCallbacks.attr(/^\\(\\{.+\\}\\)$/, syntaxWarning);\n\t//!steal-remove-end\n\n\n\t// Legacy bindings.\n\tviewCallbacks.attr(/can-[\\w\\.]+/, behaviors.event);\n\tviewCallbacks.attr(\"can-value\", behaviors.value);\n\n\n\t// ## getComputeFrom\n\t// An object of helper functions that make a getter/setter compute\n\t// on different types of objects.\n\tvar getComputeFrom = {\n\t\t// ### getComputeFrom.scope\n\t\t// Returns a compute from the scope.  This handles expressions like `someMethod(.,1)`.\n\t\tscope: function(el, scope, scopeProp, bindingData, mustBeACompute, stickyCompute){\n\t\t\tif(!scopeProp) {\n\t\t\t\treturn compute();\n\t\t\t} else {\n\t\t\t\tif(mustBeACompute) {\n\t\t\t\t\tvar parentExpression = expression.parse(scopeProp,{baseMethodType: \"Call\"});\n\t\t\t\t\treturn parentExpression.value(scope, new Scope.Options({}));\n\t\t\t\t} else {\n\t\t\t\t\treturn function(newVal){\n\t\t\t\t\t\tscope.set(cleanVMName(scopeProp), newVal);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t},\n\t\t// ### getComputeFrom.viewModel\n\t\t// Returns a compute that's two-way bound to the `viewModel` returned by\n\t\t// `options.getViewModel()`.\n\t\tviewModel: function(el, scope, vmName, bindingData, mustBeACompute, stickyCompute) {\n\t\t\tvar setName = cleanVMName(vmName);\n\t\t\tif(mustBeACompute) {\n\t\t\t\treturn compute(function(newVal){\n\t\t\t\t\tvar viewModel = bindingData.getViewModel();\n\t\t\t\t\tif(arguments.length) {\n\t\t\t\t\t\tif( types.isMapLike(viewModel) ) {\n\t\t\t\t\t\t\tobserveReader.set(viewModel,setName,newVal);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tviewModel[setName] = newVal;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn vmName === \".\" ? viewModel : observeReader.read(viewModel, observeReader.reads(vmName), {}).value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn function(newVal){\n\t\t\t\t\tvar childCompute;\n\t\t\t\t\tvar viewModel = bindingData.getViewModel();\n\n\t\t\t\t\tfunction updateViewModel(value, options) {\n\t\t\t\t\t\tif( types.isMapLike(viewModel) ) {\n\t\t\t\t\t\t\tobserveReader.set(viewModel, setName, value, options);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tviewModel[setName] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(stickyCompute) {\n\t\t\t\t\t\tchildCompute = observeReader.get(viewModel, setName, { readCompute: false });\n\t\t\t\t\t\t// childCompute is a compute at this point unless it was locally overwritten\n\t\t\t\t\t\t//  in the child viewModel.\n\t\t\t\t\t\tif(!childCompute || !childCompute.isComputed) {\n\t\t\t\t\t\t\t// If it was locally overwritten, make a new compute for the property.\n\t\t\t\t\t\t\tchildCompute = compute();\n\t\t\t\t\t\t\tupdateViewModel(childCompute, { readCompute: false });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Otherwise update the compute's value.\n\t\t\t\t\t\tchildCompute(newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateViewModel(newVal);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\n\t\t},\n\t\t// ### getComputeFrom.attribute\n\t\t// Returns a compute that is two-way bound to an attribute or property on the element.\n\t\tattribute: function(el, scope, prop, bindingData, mustBeACompute, stickyCompute, event){\n\t\t\t// Determine the event or events we need to listen to\n\t\t\t// when this value changes.\n\t\t\tif(!event) {\n\t\t\t\tevent = \"change\";\n\t\t\t\tvar isRadioInput = el.nodeName === 'INPUT' && el.type === 'radio';\n\t\t\t\tvar isValidProp = prop === 'checked' && !bindingData.legacyBindings;\n\t\t\t\tif (isRadioInput && isValidProp) {\n\t\t\t\t\tevent = 'radiochange';\n\t\t\t\t}\n\n\t\t\t\tvar isSpecialProp = attr.special[prop] && attr.special[prop].addEventListener;\n\t\t\t\tif (isSpecialProp) {\n\t\t\t\t\tevent = prop;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar hasChildren = el.nodeName.toLowerCase() === \"select\",\n\t\t\t\tisMultiselectValue = prop === \"value\" && hasChildren && el.multiple,\n\t\t\t\t// Sets the element property or attribute.\n\t\t\t\tset = function(newVal){\n\t\t\t\t\tif(bindingData.legacyBindings && hasChildren &&\n\t\t\t\t\t\t (\"selectedIndex\" in el) && prop === \"value\") {\n\t\t\t\t\t\tattr.setAttrOrProp(el, prop, newVal == null ? \"\" : newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr.setAttrOrProp(el, prop, newVal);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn newVal;\n\t\t\t\t},\n\t\t\t\tget = function(){\n\t\t\t\t\treturn attr.get(el, prop);\n\t\t\t\t};\n\n\t\t\tif(isMultiselectValue) {\n\t\t\t\tprop = \"values\";\n\t\t\t}\n\n\t\t\treturn compute(get(), {\n\t\t\t\ton: function(updater){\n\t\t\t\t\tif (event === \"radiochange\") {\n\t\t\t\t\t\tcanEvent.on.call(el, \"change\", updater);\n\t\t\t\t\t}\n\n\t\t\t\t\tcanEvent.on.call(el, event, updater);\n\t\t\t\t},\n\t\t\t\toff: function(updater){\n\t\t\t\t\tif (event === \"radiochange\") {\n\t\t\t\t\t\tcanEvent.off.call(el, \"change\", updater);\n\t\t\t\t\t}\n\n\t\t\t\t\tcanEvent.off.call(el, event, updater);\n\t\t\t\t},\n\t\t\t\tget: get,\n\t\t\t\tset: set\n\t\t\t});\n\t\t}\n\t};\n\n\t// ## bind\n\t// An object with helpers that perform bindings in a certain direction.\n\t// These use the semaphore to prevent cycles.\n\tvar bind = {\n\t\t// ## bind.childToParent\n\t\t// Listens to the child and updates the parent when it changes.\n\t\t// - `syncChild` - Makes sure the child is equal to the parent after the parent is set.\n\t\tchildToParent: function(el, parentCompute, childCompute, bindingsSemaphore, attrName, syncChild){\n\t\t\tvar parentUpdateIsFunction = typeof parentCompute === \"function\";\n\n\t\t\t// Updates the parent if\n\t\t\tvar updateParent = function(ev, newVal){\n\n\t\t\t\tif (!bindingsSemaphore[attrName]) {\n\t\t\t\t\tif(parentUpdateIsFunction) {\n\t\t\t\t\t\tparentCompute(newVal);\n\n\t\t\t\t\t\tif( syncChild ) {\n\t\t\t\t\t\t\t// If, after setting the parent, it's value is not the same as the child,\n\t\t\t\t\t\t\t// update the child with the value of the parent.\n\t\t\t\t\t\t\t// This is used by `can-value`.\n\t\t\t\t\t\t\tif(parentCompute() !== childCompute()) {\n\t\t\t\t\t\t\t\tbindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0 )+1;\n\t\t\t\t\t\t\t\tchildCompute(parentCompute());\n\t\t\t\t\t\t\t\tObservation.afterUpdateAndNotify(function(){\n\t\t\t\t\t\t\t\t\t--bindingsSemaphore[attrName];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// The parentCompute can sometimes be just an observable if the observable\n\t\t\t\t\t// is on a plain JS object. This updates the observable to match whatever the\n\t\t\t\t\t// new value is.\n\t\t\t\t\telse if(types.isMapLike(parentCompute)) {\n\t\t\t\t\t\t// !steal-dev-start\n\t\t\t\t\t\tvar attrValue = el.getAttribute(attrName);\n\t\t\t\t\t\tdev.warn(\"can-stache-bindings: Merging \" + attrName + \" into \" + attrValue + \" because its parent is non-observable\");\n\t\t\t\t\t\t// !steal-dev-end\n\t\t\t\t\t\t(parentCompute.set || parentCompute.attr).call(\n\t\t\t\t\t\t\tparentCompute,\n\t\t\t\t\t\t\tnewVal.serialize ? newVal.serialize() : newVal,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif(childCompute && childCompute.isComputed) {\n\t\t\t\tchildCompute.bind(\"change\", updateParent);\n\t\t\t}\n\n\t\t\treturn updateParent;\n\t\t},\n\t\t// parent -> child binding\n\t\tparentToChild: function(el, parentCompute, childUpdate, bindingsSemaphore, attrName){\n\n\t\t\t// setup listening on parent and forwarding to viewModel\n\t\t\tvar updateChild = function(ev, newValue){\n\n\t\t\t\t// Save the viewModel property name so it is not updated multiple times.\n\t\t\t\t// We listen for when the batch has ended, and all observation updates have ended.\n\t\t\t\tbindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0 )+1;\n\t\t\t\tcanBatch.start();\n\t\t\t\tchildUpdate(newValue);\n\n\t\t\t\t// only after computes have been updated, reduce the update counter\n\t\t\t\tObservation.afterUpdateAndNotify(function(){\n\t\t\t\t\t--bindingsSemaphore[attrName];\n\t\t\t\t});\n\t\t\t\tcanBatch.stop();\n\t\t\t};\n\n\t\t\tif(parentCompute && parentCompute.isComputed) {\n\t\t\t\tparentCompute.bind(\"change\", updateChild);\n\t\t\t}\n\n\t\t\treturn updateChild;\n\t\t}\n\t};\n\n\t// Regular expressions for getBindingInfo\n\tvar bindingsRegExp = /\\{(\\()?(\\^)?([^\\}\\)]+)\\)?\\}/,\n\t\tignoreAttributesRegExp = /^(data-view-id|class|id|\\[[\\w\\.-]+\\]|#[\\w\\.-])$/i,\n\t\tDOUBLE_CURLY_BRACE_REGEX = /\\{\\{/g,\n\t\tencodedSpacesRegExp = /\\\\s/g,\n\t\tencodedForwardSlashRegExp = /\\\\f/g;\n\n\t// ## getBindingInfo\n\t// takes a node object like {name, value} and returns\n\t// an object with information about that binding.\n\t// Properties:\n\t// - `parent` - where is the parentName read from: \"scope\", \"attribute\", \"viewModel\".\n\t// - `parentName` - what is the parent property that should be read.\n\t// - `child` - where is the childName read from: \"scope\", \"attribute\", \"viewModel\".\n\t//  - `childName` - what is the child property that should be read.\n\t// - `parentToChild` - should changes in the parent update the child.\n\t// - `childToParent` - should changes in the child update the parent.\n\t// - `bindingAttributeName` - the attribute name that created this binding.\n\t// - `initializeValues` - should parent and child be initialized to their counterpart.\n\t// If undefined is return, there is no binding.\n\tvar getBindingInfo = function(node, attributeViewModelBindings, templateType, tagName){\n\t\tvar bindingInfo,\n\t\t\tattributeName = node.name,\n\t\t\tattributeValue = node.value || \"\";\n\n\t\t// Does this match the new binding syntax?\n\t\tvar matches = attributeName.match(bindingsRegExp);\n\t\tif(!matches) {\n\t\t\tvar ignoreAttribute = ignoreAttributesRegExp.test(attributeName);\n\t\t\tvar vmName = string.camelize(attributeName);\n\n\t\t\t//!steal-remove-start\n\t\t\t// user tried to pass something like id=\"{foo}\", so give them a good warning\n\t\t\t// Something like id=\"{{foo}}\" is ok, though. (not a binding)\n\t\t\tif(ignoreAttribute && node.value.replace(DOUBLE_CURLY_BRACE_REGEX, \"\").indexOf(\"{\") > -1) {\n\t\t\t\tdev.warn(\"can-component: looks like you're trying to pass \"+attributeName+\" as an attribute into a component, \"+\n\t\t\t\t\"but it is not a supported attribute\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// if this is handled by another binding or a attribute like `id`.\n\t\t\tif ( ignoreAttribute || viewCallbacks.attr(attributeName) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar syntaxRight = attributeValue[0] === \"{\" && last(attributeValue) === \"}\";\n\t\t\tvar isAttributeToChild = templateType === \"legacy\" ? attributeViewModelBindings[vmName] : !syntaxRight;\n\t\t\tvar scopeName = syntaxRight ? attributeValue.substr(1, attributeValue.length - 2 ) : attributeValue;\n\t\t\tif(isAttributeToChild) {\n\t\t\t\treturn {\n\t\t\t\t\tbindingAttributeName: attributeName,\n\t\t\t\t\tparent: \"attribute\",\n\t\t\t\t\tparentName: attributeName,\n\t\t\t\t\tchild: \"viewModel\",\n\t\t\t\t\tchildName: vmName,\n\t\t\t\t\tparentToChild: true,\n\t\t\t\t\tchildToParent: true,\n\t\t\t\t\tsyncChildWithParent: true\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tbindingAttributeName: attributeName,\n\t\t\t\t\tparent: \"scope\",\n\t\t\t\t\tparentName: scopeName,\n\t\t\t\t\tchild: \"viewModel\",\n\t\t\t\t\tchildName: vmName,\n\t\t\t\t\tparentToChild: true,\n\t\t\t\t\tchildToParent: true,\n\t\t\t\t\tsyncChildWithParent: true\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tvar twoWay = !!matches[1],\n\t\t\tchildToParent = twoWay || !!matches[2],\n\t\t\tparentToChild = twoWay || !childToParent;\n\n\t\tvar childName = matches[3];\n\t\tvar isDOM = childName.charAt(0) === \"$\";\n\t\tif(isDOM) {\n\t\t\tbindingInfo = {\n\t\t\t\tparent: \"scope\",\n\t\t\t\tchild: \"attribute\",\n\t\t\t\tchildToParent: childToParent,\n\t\t\t\tparentToChild: parentToChild,\n\t\t\t\tbindingAttributeName: attributeName,\n\t\t\t\tchildName: childName.substr(1),\n\t\t\t\tparentName: attributeValue,\n\t\t\t\tinitializeValues: true,\n\t\t\t\tsyncChildWithParent: twoWay\n\t\t\t};\n\t\t\tif(tagName === \"select\") {\n\t\t\t\tbindingInfo.stickyParentToChild = true;\n\t\t\t}\n\t\t\treturn bindingInfo;\n\t\t} else {\n\t\t\tbindingInfo = {\n\t\t\t\tparent: \"scope\",\n\t\t\t\tchild: \"viewModel\",\n\t\t\t\tchildToParent: childToParent,\n\t\t\t\tparentToChild: parentToChild,\n\t\t\t\tbindingAttributeName: attributeName,\n\t\t\t\tchildName: decodeAttrName(string.camelize(childName)),\n\t\t\t\tparentName: attributeValue,\n\t\t\t\tinitializeValues: true,\n\t\t\t\tsyncChildWithParent: twoWay\n\t\t\t};\n\t\t\tif(attributeValue.trim().charAt(0) === \"~\") {\n\t\t\t\tbindingInfo.stickyParentToChild = true;\n\t\t\t}\n\t\t\treturn bindingInfo;\n\t\t}\n\n\t};\n\tvar decodeAttrName = function(name){\n\t\treturn name\n\t\t\t.replace(encodedSpacesRegExp, \" \")\n\t\t\t.replace(encodedForwardSlashRegExp, \"/\");\n\t};\n\n\n\t// ## makeDataBinding\n\t// Makes a data binding for an attribute `node`.  Returns an object with information\n\t// about the binding, including an `onTeardown` method that undoes the binding.\n\t// If the data binding involves a `viewModel`, an `onCompleteBinding` method is returned on\n\t// the object.  This method must be called after the element has a `viewModel` with the\n\t// `viewModel` to complete the binding.\n\t//\n\t// - `node` - an attribute node or an object with a `name` and `value` property.\n\t// - `el` - the element this binding belongs on.\n\t// - `bindingData` - an object with:\n\t//   - `templateType` - the type of template.\n\t//   - `scope` - the `Scope`,\n\t//   - `semaphore` - an object that keeps track of changes in different properties to prevent cycles,\n\t//   - `getViewModel`  - a function that returns the `viewModel` when called.  This function can be passed around (not called) even if the\n\t//      `viewModel` doesn't exist yet.\n\t//   - `attributeViewModelBindings` - properties already specified as being a viewModel<->attribute (as opposed to viewModel<->scope) binding.\n\t//\n\t// Returns:\n\t// - `undefined` - If this isn't a data binding.\n\t// - `object` - An object with information about the binding.\n\tvar makeDataBinding = function(node, el, bindingData){\n\n\t\t// Get information about the binding.\n\t\tvar bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase());\n\t\tif(!bindingInfo) {\n\t\t\treturn;\n\t\t}\n\t\t// assign some bindingData props to the bindingInfo\n\t\tbindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;\n\t\tif( bindingData.initializeValues) {\n\t\t\tbindingInfo.initializeValues = true;\n\t\t}\n\n\t\t// Get computes for the parent and child binding\n\t\tvar parentCompute = getComputeFrom[bindingInfo.parent](\n\t\t\t\tel,\n\t\t\t\tbindingData.scope,\n\t\t\t\tbindingInfo.parentName,\n\t\t\t\tbindingData, bindingInfo.parentToChild\n\t\t\t),\n\t\t\tchildCompute = getComputeFrom[bindingInfo.child](\n\t\t\t\tel,\n\t\t\t\tbindingData.scope,\n\t\t\t\tbindingInfo.childName,\n\t\t\t\tbindingData,\n\t\t\t\tbindingInfo.childToParent,\n\t\t\t\tbindingInfo.stickyParentToChild && parentCompute\n\t\t\t),\n\t\t\t// these are the functions bound to one compute that update the other.\n\t\t\tupdateParent,\n\t\t\tupdateChild,\n\t\t\tchildLifecycle;\n\n\t\tif(bindingData.nodeList) {\n\t\t\tif(parentCompute && parentCompute.isComputed){\n\t\t\t\tparentCompute.computeInstance.setPrimaryDepth(bindingData.nodeList.nesting+1);\n\t\t\t}\n\t\t\tif(childCompute && childCompute.isComputed){\n\t\t\t\tchildCompute.computeInstance.setPrimaryDepth(bindingData.nodeList.nesting+1);\n\t\t\t}\n\t\t}\n\n\t\t// Only bind to the parent if it will update the child.\n\t\tif(bindingInfo.parentToChild){\n\t\t\tupdateChild = bind.parentToChild(el, parentCompute, childCompute, bindingData.semaphore, bindingInfo.bindingAttributeName);\n\t\t}\n\n\t\t// This completes the binding.  We can't call it right away because\n\t\t// the `viewModel` might not have been created yet.\n\t\tvar completeBinding = function(){\n\t\t\tif(bindingInfo.childToParent){\n\t\t\t\t// setup listening on parent and forwarding to viewModel\n\t\t\t\tupdateParent = bind.childToParent(el, parentCompute, childCompute, bindingData.semaphore, bindingInfo.bindingAttributeName,\n\t\t\t\t\tbindingInfo.syncChildWithParent);\n\t\t\t}\n\t\t\t// the child needs to be bound even if\n\t\t\telse if(bindingInfo.stickyParentToChild) {\n\t\t\t\tchildCompute.bind(\"change\", childLifecycle = function(){});\n\t\t\t}\n\n\t\t\tif(bindingInfo.initializeValues) {\n\t\t\t\tinitializeValues(bindingInfo, childCompute, parentCompute, updateChild, updateParent);\n\t\t\t}\n\n\n\t\t};\n\t\t// This tears down the binding.\n\t\tvar onTeardown = function() {\n\t\t\tunbindUpdate(parentCompute, updateChild);\n\t\t\tunbindUpdate(childCompute, updateParent);\n\t\t\tunbindUpdate(childCompute, childLifecycle);\n\t\t};\n\t\t// If this binding depends on the viewModel, which might not have been created,\n\t\t// return the function to complete the binding as `onCompleteBinding`.\n\t\tif(bindingInfo.child === \"viewModel\") {\n\t\t\treturn {\n\t\t\t\tvalue: bindingInfo.stickyParentToChild ? compute(getValue(parentCompute)) : getValue(parentCompute),\n\t\t\t\tonCompleteBinding: completeBinding,\n\t\t\t\tbindingInfo: bindingInfo,\n\t\t\t\tonTeardown: onTeardown\n\t\t\t};\n\t\t} else {\n\t\t\tcompleteBinding();\n\t\t\treturn {\n\t\t\t\tbindingInfo: bindingInfo,\n\t\t\t\tonTeardown: onTeardown\n\t\t\t};\n\n\t\t}\n\t};\n\n\t// ## initializeValues\n\t// Updates the parent or child value depending on the direction of the binding\n\t// or if the child or parent is `undefined`.\n\tvar initializeValues = function(bindingInfo, childCompute, parentCompute, updateChild, updateParent){\n\t\tvar doUpdateParent = false;\n\t\tif(bindingInfo.parentToChild && !bindingInfo.childToParent) {\n\t\t\t// updateChild\n\t\t}\n\t\telse if(!bindingInfo.parentToChild && bindingInfo.childToParent) {\n\t\t\tdoUpdateParent = true;\n\t\t}\n\t\t// Two way\n\t\t// Update child or parent depending on who has a value.\n\t\t// If both have a value, update the child.\n\t\telse if( getValue(childCompute) === undefined) {\n\t\t\t// updateChild\n\t\t} else if(getValue(parentCompute) === undefined) {\n\t\t\tdoUpdateParent = true;\n\t\t}\n\n\t\tif(doUpdateParent) {\n\t\t\tupdateParent({}, getValue(childCompute) );\n\t\t} else {\n\t\t\tif(!bindingInfo.alreadyUpdatedChild) {\n\t\t\t\tupdateChild({}, getValue(parentCompute) );\n\t\t\t}\n\t\t}\n\t};\n\n\t// For \"sticky\" select values, we need to know when `<option>`s are\n\t// added or removed to a `<select>`.  If we don't have\n\t// MutationObserver, we need to setup can.view.live to\n\t// callback when this happens.\n\tif( !getMutationObserver() ) {\n\t\tvar updateSelectValue = function(el){\n\t\t\tvar bindingCallback = domData.get.call(el,\"canBindingCallback\");\n\t\t\tif(bindingCallback) {\n\t\t\t\tbindingCallback.onMutation(el);\n\t\t\t}\n\t\t};\n\t\tlive.registerChildMutationCallback(\"select\",updateSelectValue);\n\t\tlive.registerChildMutationCallback(\"optgroup\",function(el){\n\t\t\tupdateSelectValue(el.parentNode);\n\t\t});\n\t}\n\n\n\t// ## isContentEditable\n\t// Determines if an element is contenteditable.\n\t// An element is contenteditable if it contains the `contenteditable`\n\t// attribute set to either an empty string or \"true\".\n\t// By default an element is also contenteditable if its immediate parent\n\t// has a truthy version of the attribute, unless the element is explicitly\n\t// set to \"false\".\n\tvar isContentEditable = (function(){\n\t\t// A contenteditable element has a value of an empty string or \"true\"\n\t\tvar values = {\n\t\t\t\"\": true,\n\t\t\t\"true\": true,\n\t\t\t\"false\": false\n\t\t};\n\n\t\t// Tests if an element has the appropriate contenteditable attribute\n\t\tvar editable = function(el){\n\t\t\t// DocumentFragments do not have a getAttribute\n\t\t\tif(!el || !el.getAttribute) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar attr = el.getAttribute(\"contenteditable\");\n\t\t\treturn values[attr];\n\t\t};\n\n\t\treturn function (el){\n\t\t\t// First check if the element is explicitly true or false\n\t\t\tvar val = editable(el);\n\t\t\tif(typeof val === \"boolean\") {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\t// Otherwise, check the parent\n\t\t\t\treturn !!editable(el.parentNode);\n\t\t\t}\n\t\t};\n\t})(),\n\t\tremoveBrackets = function(value, open, close){\n\t\t\topen = open || \"{\";\n\t\t\tclose = close || \"}\";\n\n\t\t\tif(value[0] === open && value[value.length-1] === close) {\n\t\t\t\treturn value.substr(1, value.length - 2);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tgetValue = function(value){\n\t\t\treturn value && value.isComputed ? value() : value;\n\t\t},\n\t\tunbindUpdate = function(compute, updateOther){\n\t\t\tif(compute && compute.isComputed && typeof updateOther === \"function\") {\n\t\t\t\tcompute.unbind(\"change\", updateOther);\n\t\t\t}\n\t\t},\n\t\tcleanVMName = function(name){\n\t\t\treturn name.replace(/@/g,\"\");\n\t\t};\n\n\n\t// ## Special Event Types (can-SPECIAL)\n\t//\n\t// A special object, similar to [$.event.special](http://benalman.com/news/2010/03/jquery-special-events/),\n\t// for adding hooks for special can-SPECIAL types (not native DOM events). Right now, only can-enter is\n\t// supported, but this object might be exported so that it can be added to easily.\n\t//\n\t// To implement a can-SPECIAL event type, add a property to the special object, whose value is a function\n\t// that returns the following:\n\t//\n\t//\t\t// the real event name to bind to\n\t//\t\tevent: \"event-name\",\n\t//\t\thandler: function (ev) {\n\t//\t\t\t// some logic that figures out if the original handler should be called or not, and if so...\n\t//\t\t\treturn original.call(this, ev);\n\t//\t\t}\n\tvar special = {\n\t\tenter: function (data, el, original) {\n\t\t\treturn {\n\t\t\t\tevent: \"keyup\",\n\t\t\t\thandler: function (ev) {\n\t\t\t\t\tif (ev.keyCode === 13 || ev.key === \"Enter\") {\n\t\t\t\t\t\treturn original.call(this, ev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\tmodule.exports = {\n\t\tbehaviors: behaviors,\n\t\tgetBindingInfo: getBindingInfo,\n\t\tspecial: special\n\t};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache-bindings/can-stache-bindings.js\n// module id = 86\n// module chunks = 0","var helpers = require(\"./core\");\nvar expression = require(\"../src/expression\");\nvar makeArray = require(\"can-util/js/make-array/make-array\")\n\nhelpers.registerConverter = function(name, getterSetter) {\n\tgetterSetter = getterSetter || {};\n\thelpers.registerHelper(name, function(newVal, source) {\n\t\tvar args = makeArray(arguments);\n\t\tif(newVal instanceof expression.SetIdentifier) {\n\t\t\treturn typeof getterSetter.set === \"function\" \n\t\t\t\t? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) \n\t\t\t\t: source(newVal.value);\n\t\t} else {\n\t\t\treturn typeof getterSetter.get === \"function\" \n\t\t\t\t? getterSetter.get.apply(this, args)\n\t\t\t\t: args[0];\n\t\t}\n\t});\n};\n\nmodule.exports = helpers;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/helpers/converter.js\n// module id = 87\n// module chunks = 0","var target = require('can-view-target');\nvar Scope = require('can-view-scope');\nvar Observation = require('can-observation');\n\nvar utils = require('./utils');\nvar mustacheCore = require('./mustache_core');\n\nvar getDocument = require(\"can-util/dom/document/document\");\n\nvar assign = require('can-util/js/assign/assign');\nvar last = require('can-util/js/last/last');\n\nvar decodeHTML = typeof document !== \"undefined\" && (function(){\n\tvar el = getDocument().createElement('div');\n\treturn function(html){\n\t\tif(html.indexOf(\"&\") === -1) {\n\t\t\treturn html.replace(/\\r\\n/g,\"\\n\");\n\t\t}\n\t\tel.innerHTML = html;\n\t\treturn el.childNodes.length === 0 ? \"\" : el.childNodes.item(0).nodeValue;\n\t};\n})();\n// ## HTMLSectionBuilder\n//\n// Contains a stack of HTMLSections.\n// An HTMLSection is created everytime a subsection is found. For example:\n//\n//     {{#if items}} {{#items}} X\n//\n// At the point X was being processed, their would be 2 HTMLSections in the\n// stack.  One for the content of `{{#if items}}` and the other for the\n// content of `{{#items}}`\nvar HTMLSectionBuilder = function(){\n\tthis.stack = [new HTMLSection()];\n};\n\nassign(HTMLSectionBuilder.prototype,utils.mixins);\n\nassign(HTMLSectionBuilder.prototype,{\n\tstartSubSection: function(process){\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.stack.push(newSection);\n\t\treturn newSection;\n\t},\n\t// Ends the current section and returns a renderer.\n\t// But only returns a renderer if there is a template.\n\tendSubSectionAndReturnRenderer: function(){\n\t\tif(this.last().isEmpty()) {\n\t\t\tthis.stack.pop();\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar htmlSection = this.endSection();\n\t\t\treturn htmlSection.compiled.hydrate.bind(htmlSection.compiled);\n\t\t}\n\t},\n\tstartSection: function( process ) {\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.last().add(newSection.targetCallback);\n\t\t// adding a section within a section ...\n\t\t// the stack has section ...\n\t\tthis.stack.push(newSection);\n\t},\n\tendSection: function(){\n\t\tthis.last().compile();\n\t\treturn this.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.last().inverse();\n\t},\n\tcompile: function(){\n\t\tvar compiled = this.stack.pop().compile();\n\t\t// ignore observations here.  the render fn\n\t\t//  itself doesn't need to be observable.\n\t\treturn Observation.ignore(function(scope, options, nodeList){\n\t\t\tif ( !(scope instanceof Scope) ) {\n\t\t\t\tscope = Scope.refsScope().add(scope || {});\n\t\t\t}\n\t\t\tif ( !(options instanceof mustacheCore.Options) ) {\n\t\t\t\toptions = new mustacheCore.Options(options || {});\n\t\t\t}\n\t\t\treturn compiled.hydrate(scope, options, nodeList);\n\t\t});\n\t},\n\tpush: function(chars){\n\t\tthis.last().push(chars);\n\t},\n\tpop: function(){\n\t\treturn this.last().pop();\n\t}\n});\n\nvar HTMLSection = function(process){\n\tthis.data = \"targetData\";\n\tthis.targetData = [];\n\t// A record of what targetData element we are within.\n\tthis.targetStack = [];\n\tvar self = this;\n\tthis.targetCallback = function(scope, options, sectionNode){\n\t\tprocess.call(this,\n\t\t\tscope,\n\t\t\toptions,\n\t\t\tsectionNode,\n\t\t\tself.compiled.hydrate.bind(self.compiled),\n\t\t\tself.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled)  ) ;\n\t};\n};\nassign(HTMLSection.prototype,{\n\tinverse: function(){\n\t\tthis.inverseData = [];\n\t\tthis.data = \"inverseData\";\n\t},\n\t// Adds a DOM node.\n\tpush: function(data){\n\t\tthis.add(data);\n\t\tthis.targetStack.push(data);\n\t},\n\tpop: function(){\n\t\treturn this.targetStack.pop();\n\t},\n\tadd: function(data){\n\t\tif(typeof data === \"string\"){\n\t\t\tdata = decodeHTML(data);\n\t\t}\n\t\tif(this.targetStack.length) {\n\t\t\tlast(this.targetStack).children.push(data);\n\t\t} else {\n\t\t\tthis[this.data].push(data);\n\t\t}\n\t},\n\tcompile: function(){\n\t\tthis.compiled = target(this.targetData, getDocument());\n\t\tif(this.inverseData) {\n\t\t\tthis.inverseCompiled = target(this.inverseData, getDocument());\n\t\t\tdelete this.inverseData;\n\t\t}\n\t\tthis.targetStack = this.targetData = null;\n\t\treturn this.compiled;\n\t},\n\tchildren: function(){\n\t\tif(this.targetStack.length) {\n\t\t\treturn last(this.targetStack).children;\n\t\t} else {\n\t\t\treturn this[this.data];\n\t\t}\n\t},\n\t// Returns if a section is empty\n\tisEmpty: function(){\n\t\treturn !this.targetData.length;\n\t}\n});\nHTMLSectionBuilder.HTMLSection = HTMLSection;\n\nmodule.exports = HTMLSectionBuilder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/src/html_section.js\n// module id = 88\n// module chunks = 0","var compute = require('can-compute');\nvar live = require('can-view-live');\n\nvar utils = require('./utils');\n\nvar attr = require(\"can-util/dom/attr/attr\");\n\nvar assign = require('can-util/js/assign/assign');\n\nvar noop = function(){};\n\nvar TextSectionBuilder = function(){\n\tthis.stack = [new TextSection()];\n};\n\nassign(TextSectionBuilder.prototype,utils.mixins);\n\nassign(TextSectionBuilder.prototype,{\n\t// Adds a subsection.\n\tstartSection: function(process){\n\t\tvar subSection = new TextSection();\n\t\tthis.last().add({process: process, truthy: subSection});\n\t\tthis.stack.push(subSection);\n\t},\n\tendSection: function(){\n\t\tthis.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.stack.pop();\n\t\tvar falseySection = new TextSection();\n\t\tthis.last().last().falsey = falseySection;\n\t\tthis.stack.push(falseySection);\n\t},\n\tcompile: function(state){\n\n\t\tvar renderer = this.stack[0].compile();\n\n\t\treturn function(scope, options){\n\n\t\t\tvar computeValue = compute(function(){\n\t\t\t\treturn renderer(scope, options);\n\t\t\t}, null, false);\n\n\t\t\tcomputeValue.computeInstance.addEventListener(\"change\", noop);\n\t\t\tvar value = computeValue();\n\t\t\tif( computeValue.computeInstance.hasDependencies ) {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tlive.text(this, computeValue);\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, computeValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, computeValue, scope, options);\n\t\t\t\t}\n\t\t\t\tcomputeValue.computeInstance.removeEventListener(\"change\", noop);\n\t\t\t} else {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tthis.nodeValue = value;\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tattr.set(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\nvar passTruthyFalsey = function(process, truthy, falsey){\n\treturn function(scope, options){\n\t\treturn process.call(this, scope, options, truthy, falsey);\n\t};\n};\n\nvar TextSection = function(){\n\tthis.values = [];\n};\n\nassign( TextSection.prototype, {\n\tadd: function(data){\n\t\tthis.values.push(data);\n\t},\n\tlast: function(){\n\t\treturn this.values[this.values.length - 1];\n\t},\n\tcompile: function(){\n\t\tvar values = this.values,\n\t\t\tlen = values.length;\n\n\t\tfor(var i = 0 ; i < len; i++) {\n\t\t\tvar value = this.values[i];\n\t\t\tif(typeof value === \"object\") {\n\t\t\t\tvalues[i] = passTruthyFalsey( value.process,\n\t\t\t\t    value.truthy && value.truthy.compile(),\n\t\t\t\t    value.falsey && value.falsey.compile());\n\t\t\t}\n\t\t}\n\n\t\treturn function(scope, options){\n\t\t\tvar txt = \"\",\n\t\t\t\tvalue;\n\t\t\tfor(var i = 0; i < len; i++){\n\t\t\t\tvalue = values[i];\n\t\t\t\ttxt += typeof value === \"string\" ? value : value.call(this, scope, options);\n\t\t\t}\n\t\t\treturn txt;\n\t\t};\n\t}\n});\n\nmodule.exports = TextSectionBuilder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-stache/src/text_section.js\n// module id = 89\n// module chunks = 0","'use strict';\n\n// From http://jaketrent.com/post/addremove-classes-raw-javascript/\n\nvar has = function(className) {\n\tif (this.classList) {\n\t\treturn this.classList.contains(className);\n\t} else {\n\t\treturn !!this.className.match(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'));\n\t}\n};\n\n/**\n * @module {{}} can-util/dom/class-name/class-name class-name\n * @parent can-util/dom\n * @description Allows querying and manipulation of classes on HTML elements\n *\n * ```js\n * var className = require(\"can-util/dom/class-name/class-name\");\n *\n * var fooDiv = document.createElement(\"div\");\n * className.add(fooDiv, \"foo\");\n * fooDiv.outerHTML; //-> '<div class=\"foo\"></div>'\n * ```\n */\nmodule.exports = {\n\t/**\n\t * @function can-util/dom/class-name/class-name.has className.has\n\t * @parent can-util/dom/class-name/class-name\n   * @signature `className.has.call(el, cls)`\n\t *\n\t * Determine wheter a DOM node has a given class name.\n\t *\n\t * ```js\n\t * var className = require(\"can-util/dom/class-name/class-name\");\n\t * \n\t * var isContainer = className.has.call(el, \"container\");\n\t * ```\n\t *\n\t * @param {String} className A string representing a single class name token\n\t *\n\t * @return {Boolean} true if the element's class attribute contains the token, false otherwise.\n\t */\n\thas: has,\n\t/**\n\t * @function can-util/dom/class-name/class-name.add className.add\n\t * @parent can-util/dom/class-name/class-name\n\t * @signature `className.add.call(el, cls)`\n\t *\n\t * Add a class name to a DOM node if it is not already there.\n\t *\n\t * ```js\n\t * var className = require(\"can-util/dom/class-name/class-name\");\n\t * \n\t * className.add.call(el, \"container\");\n\t * ```\n\t *\n\t * @param {String} className A string representing a single class name token\n\t *\n\t * @return {void}\n\t */\n\tadd: function(className) {\n\t\tif (this.classList) {\n\t\t\tthis.classList.add(className);\n\t\t}\n\t\telse if (!has.call(this, className)) {\n\t\t\tthis.className += \" \" + className;\n\t\t}\n\t},\n\t/**\n\t * @function can-util/dom/class-name/class-name.remove className.remove\n\t * @parent can-util/dom/class-name/class-name\n\t * @signature `className.remove.call(el, cls)`\n\t *\n\t * Remove a class name from a DOM node if it exists on the node\n\t *\n\t * ```js\n\t * var className = require(\"can-util/dom/class-name/class-name\");\n\t * \n\t * className.remove.call(el, \"container\");\n\t * ```\n\t *\n\t * @param {String} className A string representing a single class name token\n\t *\n\t * @return {void}\n\t */\n\tremove: function(className) {\n\t\tif (this.classList) {\n\t\t\tthis.classList.remove(className);\n\t\t} else if (has.call(this, className)) {\n\t\t\tvar reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n\t\t\tthis.className = this.className.replace(reg, ' ');\n\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/class-name/class-name.js\n// module id = 90\n// module chunks = 0","'use strict';\n\nvar events = require(\"../events\");\nvar isOfGlobalDocument = require(\"../../is-of-global-document/is-of-global-document\");\nvar domData = require(\"../../data/data\");\nvar getMutationObserver = require(\"../../mutation-observer/mutation-observer\");\nvar assign = require(\"../../../js/assign/assign\");\nvar domDispatch = require(\"../../dispatch/dispatch\");\n\nvar originalAdd = events.addEventListener,\n\toriginalRemove = events.removeEventListener;\n\n/**\n * @module {events} can-util/dom/events/attributes/attributes attributes\n * @parent can-util/dom/events/events\n *\n * Adds a listenable \"attributes\" event to DOM nodes, which fires when\n * the node's attributes change.\n *\n * ```js\n * var events = require(\"can-util/dom/events/events\");\n * require(\"can-util/dom/events/attributes/attributes\");\n * var el = document.createElement(\"div\");\n *\n * function attributesHandler() {\n * \tconsole.log(\"attributes event fired\");\n * }\n * \n * events.addEventListener.call(el, \"attributes\", attributesHandler, false);\n *\n * events.removeEventListener.call(el, \"attributes\", attributesHandler);\n * ```\n */\nevents.addEventListener = function(eventName){\n\tif(eventName === \"attributes\") {\n\t\tvar MutationObserver = getMutationObserver();\n\t\tif( isOfGlobalDocument(this) && MutationObserver ) {\n\t\t\tvar self = this;\n\t\t\tvar observer = new MutationObserver(function (mutations) {\n\t\t\t\tmutations.forEach(function (mutation) {\n\t\t\t\t\tvar copy = assign({}, mutation);\n\t\t\t\t\tdomDispatch.call(self, copy, [], false);\n\t\t\t\t});\n\n\t\t\t});\n\t\t\tobserver.observe(this, {\n\t\t\t\tattributes: true,\n\t\t\t\tattributeOldValue: true\n\t\t\t});\n\t\t\tdomData.set.call(this, \"canAttributesObserver\", observer);\n\t\t} else {\n\t\t\tdomData.set.call(this, \"canHasAttributesBindings\", true);\n\t\t}\n\t}\n\treturn originalAdd.apply(this, arguments);\n\n};\n\nevents.removeEventListener = function(eventName){\n\tif(eventName === \"attributes\") {\n\t\tvar MutationObserver = getMutationObserver();\n\t\tvar observer;\n\n\t\tif(isOfGlobalDocument(this) && MutationObserver) {\n\t\t\tobserver = domData.get.call(this, \"canAttributesObserver\");\n\n\t\t\tif (observer && observer.disconnect) {\n\t\t\t\tobserver.disconnect();\n\t\t\t\tdomData.clean.call(this, \"canAttributesObserver\");\n\t\t\t}\n\t\t} else {\n\t\t\tdomData.clean.call(this, \"canHasAttributesBindings\");\n\t\t}\n\t}\n\treturn originalRemove.apply(this, arguments);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/attributes/attributes.js\n// module id = 91\n// module chunks = 0","'use strict';\n\n/*!\n * Based on jQuery v3.2.1 https://jquery.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n */\n\nvar domEvents = require(\"../events\"),\n\tsingleRef = require(\"../../../js/single-reference/single-reference\"),\n\tcid = require(\"../../../js/cid/get-cid\");\n\n// Some mouse/pointer events do not bubble so we derive these events from other\n// bubbling events so they work with delegated listeners\n\nvar eventMap = {\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t},\n\tclassMap = {\n\t\tmouseenter: \"MouseEvent\",\n\t\tmouseleave: \"MouseEvent\",\n\t\tpointerenter: \"PointerEvent\",\n\t\tpointerleave: \"PointerEvent\"\n\t},\n\t_addDelegateListener = domEvents.addDelegateListener,\n\t_removeDelegateListener = domEvents.removeDelegateListener;\n\n\ndomEvents.addDelegateListener = function(eventType, selector, handler) {\n\tif (eventMap[eventType] !== undefined) {\n\t\tvar origHandler = handler,\n\t\t\torigType = eventType;\n\n\t\teventType = eventMap[eventType];\n\t\thandler = function(event) {\n\t\t\tvar target = this,\n\t\t\t\trelated = event.relatedTarget;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !target.contains(related)) ) {\n\t\t\t\t// get new event with correct event type\n\t\t\t\tvar eventClass = classMap[origType];\n\n\t\t\t\tif (eventClass === 'MouseEvent') {\n\t\t\t\t\tvar newEv = document.createEvent(eventClass);\n\t\t\t\t\tnewEv.initMouseEvent(origType, false, false, event.view, event.detail, event.screenX, event.screenY,\n\t\t\t\t\t\tevent.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button,\n\t\t\t\t\t\tevent.relatedTarget);\n\t\t\t\t\tevent = newEv;\n\t\t\t\t} else if (eventClass === 'PointerEvent') {\n\t\t\t\t\tevent = new PointerEvent(origType, event);\n\t\t\t\t}\n\n\t\t\t\treturn origHandler.call(this, event);\n\t\t\t}\n\t\t};\n\n\t\tsingleRef.set(origHandler, cid(this)+eventType, handler);\n\t}\n\n\t_addDelegateListener.call(this, eventType, selector, handler);\n};\n\ndomEvents.removeDelegateListener = function(eventType, selector, handler) {\n\tif (eventMap[eventType] !== undefined) {\n\t\teventType = eventMap[eventType];\n\t\thandler = singleRef.getAndDelete(handler, cid(this)+eventType);\n\t}\n\n\t_removeDelegateListener.call(this, eventType, selector, handler);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/events/delegate/enter-leave.js\n// module id = 92\n// module chunks = 0","'use strict';\n\nvar getDocument = require(\"../document/document\"),\n\tchildNodes = require(\"../child-nodes/child-nodes\");\n// fragment.js\n// ---------\n// _DOM Fragment support._\nvar fragmentRE = /^\\s*<(\\w+)[^>]*>/,\n\ttoString = {}.toString,\n\tfragment = function (html, name, doc) {\n\t\tif (name === undefined) {\n\t\t\tname = fragmentRE.test(html) && RegExp.$1;\n\t\t}\n\t\tif (html && toString.call(html.replace) === \"[object Function]\") {\n\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\thtml = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi, '<$1></$2>');\n\t\t}\n\t\tvar container = doc.createElement('div'),\n\t\t\ttemp = doc.createElement('div');\n\t\t// IE's parser will strip any `<tr><td>` tags when `innerHTML`\n\t\t// is called on a `tbody`. To get around this, we construct a\n\t\t// valid table with a `tbody` that has the `innerHTML` we want.\n\t\t// Then the container is the `firstChild` of the `tbody`.\n\t\t// [source](http://www.ericvasilik.com/2006/07/code-karma.html).\n\t\tif (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {\n\t\t\ttemp.innerHTML = '<table>' + html + '</table>';\n\t\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;\n\t\t} else if (name === 'col') {\n\t\t\ttemp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';\n\t\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;\n\t\t} else if (name === 'tr') {\n\t\t\ttemp.innerHTML = '<table><tbody>' + html + '</tbody></table>';\n\t\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;\n\t\t} else if (name === 'td' || name === 'th') {\n\t\t\ttemp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';\n\t\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;\n\t\t} else if (name === 'option') {\n\t\t\ttemp.innerHTML = '<select>' + html + '</select>';\n\t\t\tcontainer = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;\n\t\t} else {\n\t\t\tcontainer.innerHTML = '' + html;\n\t\t}\n\t\t// IE8 barfs if you pass slice a `childNodes` object, so make a copy.\n\t\tvar tmp = {},\n\t\t\tchildren = childNodes( container );\n\t\ttmp.length = children.length;\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\ttmp[i] = children[i];\n\t\t}\n\t\treturn [].slice.call(tmp);\n\t};\nvar buildFragment = function (html, doc) {\n\tif(html && html.nodeType === 11) {\n\t\treturn html;\n\t}\n\tif(!doc) {\n\t\tdoc = getDocument();\n\t} else if(doc.length) {\n\t\tdoc = doc[0];\n\t}\n\n\tvar parts = fragment(html, undefined, doc),\n\t\tfrag = (doc || document).createDocumentFragment();\n\tfor(var i = 0, length = parts.length; i < length; i++) {\n\t\tfrag.appendChild(parts[i]);\n\t}\n\treturn frag;\n};\n\n// ## Fix build fragment.\n// In IE8, we can pass a fragment and it removes newlines.\n// This checks for that and replaces can.buildFragment with something\n// that if only a single text node is returned, returns a fragment with\n// a text node that is set to the content.\n\n\nmodule.exports = buildFragment;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/fragment/fragment.js\n// module id = 93\n// module chunks = 0","'use strict';\n\nvar matchesMethod = function(element) {\n\treturn element.matches || element.webkitMatchesSelector || element.webkitMatchesSelector ||\n\t\telement.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;\n};\n\nmodule.exports = function(){\n\tvar method = matchesMethod(this);\n\treturn method ? method.apply(this, arguments) : false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/dom/matches/matches.js\n// module id = 94\n// module chunks = 0","'use strict';\n\nvar getGlobal = require('../global/global');\nvar getDomDocument = require('../../dom/document/document');\n\n/**\n * @module {function} can-util/js/base-url/base-url base-url\n * @parent can-util/js\n * @signature `baseUrl(optionalBaseUrlToSet)`\n *\n * Get and/or set the \"base\" (containing path) of the document.\n *\n * ```js\n * var baseUrl = require(\"can-util/js/base-url/base-url\");\n *\n * console.log(baseUrl());           // -> \"http://localhost:8080\"\n * console.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\n * console.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n * ```\n *\n * @param {String} setUrl An optional base url to override reading the base URL from the known path.\n *\n * @return {String} Returns the set or computed base URL\n */\n\nvar setBaseUrl;\nmodule.exports = function(setUrl){\n\tif(setUrl !== undefined) {\n\t\tsetBaseUrl = setUrl;\n\t}\n\tif(setBaseUrl !== undefined) {\n\t\treturn setBaseUrl;\n\t}\n\tvar global = getGlobal();\n\tvar domDocument = getDomDocument();\n\tif (domDocument && 'baseURI' in domDocument) {\n\t\treturn domDocument.baseURI;\n\t} else if(global.location) {\n\t\tvar href = global.location.href;\n\t\tvar lastSlash = href.lastIndexOf(\"/\");\n\t\treturn lastSlash !== -1 ? href.substr(0, lastSlash) : href;\n\t} else if(typeof process !== \"undefined\") {\n\t\treturn process.cwd();\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/base-url/base-url.js\n// module id = 95\n// module chunks = 0","'use strict';\n\nvar GLOBAL = require(\"../global/global\");\nvar each = require(\"../each/each\");\nvar getCID = require(\"../cid/get-cid\");\n\nvar CIDSet;\n\nif(GLOBAL().Set) {\n\tCIDSet = GLOBAL().Set;\n} else {\n\tvar CIDSet = function(){\n\t\tthis.values = {};\n\t};\n\tCIDSet.prototype.add = function(value){\n\t\tthis.values[getCID(value)] = value;\n\t};\n\tCIDSet.prototype[\"delete\"] = function(key){\n\t\tvar has = getCID(key) in this.values;\n\t\tif(has) {\n\t\t\tdelete this.values[getCID(key)];\n\t\t}\n\t\treturn has;\n\t};\n\tCIDSet.prototype.forEach = function(cb, thisArg) {\n\t\teach(this.values, cb, thisArg);\n\t};\n\tCIDSet.prototype.has = function(value) {\n\t\treturn (getCID(value) in this.values);\n\t};\n\tCIDSet.prototype.clear = function(key) {\n\t\treturn this.values = {};\n\t};\n\tObject.defineProperty(CIDSet.prototype,\"size\",{\n\t\tget: function(){\n\t\t\tvar size = 0;\n\t\t\teach(this.values, function(){\n\t\t\t\tsize++;\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\t});\n}\n\nmodule.exports = CIDSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/cid-set/cid-set.js\n// module id = 96\n// module chunks = 0","'use strict';\n\nvar isArray = require('../is-array/is-array');\nvar isFunction = require('../is-function/is-function');\nvar isPlainObject = require('../is-plain-object/is-plain-object');\n\nfunction deepAssign() {\n\t/*jshint maxdepth:6 */\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length;\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif (typeof target !== \"object\" && !isFunction(target)) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif (length === i) {\n\t\t/*jshint validthis:true*/\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor (; i < length; i++) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ((options = arguments[i]) != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target === copy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif (copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[name] = deepAssign(clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n}\n\nmodule.exports = deepAssign;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/deep-assign/deep-assign.js\n// module id = 97\n// module chunks = 0","'use strict';\n\n\n/**\n * @module {function} can-util/js/defaults/defaults defaults\n * @parent can-util/js\n * @signature `defaults(target, [ ... sources])`\n *\n * Mimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to\n * right if they are not already defined.\n *\n * ```js\n * var defaults = require(\"can-util/js/defaults/defaults\");\n *\n * var obj = {a: 1, b: 2};\n * var src = {b: 3, c: 3};\n *\n * assign(obj, src, {a: 2, d: 4});\n *\n * console.log(obj); // -> {a: 1, b: 2, c: 3, d: 4}\n * ```\n *\n * @param {Object} target The destination object. This object's properties will be mutated based on the objects provided as [ ... sources].\n * @param {Object} [ ... sources] The source objects whose own properties will be applied to `target`.\n *\n * @return {Object} Returns the `target` argument.\n */\n\nmodule.exports = function (target) {\n\tvar length = arguments.length;\n\tfor (var i = 1; i < length; i++) {\n\t\tfor (var prop in arguments[i]) {\n\t\t\tif (target[prop] === undefined) {\n\t\t\t\ttarget[prop] = arguments[i][prop];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/defaults/defaults.js\n// module id = 98\n// module chunks = 0","'use strict';\n\nvar isFunction = require('../is-function/is-function');\nvar global = require(\"../global/global\")();\n\n/**\n * @module {function} can-util/js/import/import import\n * @parent can-util/js\n * @signature `importModule(moduleName, parentName)`\n *\n * ```js\n * var importModule = require(\"can-util/js/import/import\");\n *\n * importModule(\"foo.stache\").then(function(){\n *   // module was imported\n * });\n * ```\n *\n * @param {String} moduleName The module to be imported.\n * @param {String} [parentName] A parent module that will be used as a reference for resolving relative module imports.\n * @return {Promise} A Promise that will resolve when the module has been imported.\n */\n\nmodule.exports = function(moduleName, parentName) {\n\treturn new Promise(function(resolve, reject) {\n\t\ttry {\n\t\t\tif(typeof global.System === \"object\" && isFunction(global.System[\"import\"])) {\n\t\t\t\tglobal.System[\"import\"](moduleName, {\n\t\t\t\t\tname: parentName\n\t\t\t\t}).then(resolve, reject);\n\t\t\t} else if(global.define && global.define.amd){\n\t\t\t\tglobal.require([moduleName], function(value){\n\t\t\t\t\tresolve(value);\n\t\t\t\t});\n\t\t\t} else if(global.require){\n\t\t\t\tresolve(global.require(moduleName));\n\t\t\t} else {\n\t\t\t\t// ideally this will use can.getObject\n\t\t\t\tresolve();\n\t\t\t}\n\t\t} catch(err) {\n\t\t\treject(err);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/import/import.js\n// module id = 99\n// module chunks = 0","'use strict';\n\n/**\n * @module {function} can-util/js/is-browser-window/is-browser-window is-browser-window\n * @parent can-util/js\n * @signature `isBrowserWindow()`\n *\n * Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n *\n * ```js\n * var isBrowserWindow = require(\"can-util/js/is-browser-window/is-browser-window\");\n * var GLOBAL = require(\"can-util/js/global/global\");\n *\n * if(isBrowserWindow()) {\n *   console.log(GLOBAL() === window); // -> true\n * }\n * ```\n *\n * @return {Boolean} True if the environment is a Browser window.\n */\n\nmodule.exports = function(){\n\treturn typeof window !== \"undefined\" &&\n\t\ttypeof document !== \"undefined\" && typeof SimpleDOM === \"undefined\";\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-browser-window/is-browser-window.js\n// module id = 100\n// module chunks = 0","'use strict';\n\n/**\n * @module {function} can-util/js/is-promise-like/is-promise-like is-promise-like\n * @parent can-util/js\n * @signature `isPromiseLike(obj)`\n *\n * Determines if an object is \"Then-able\".\n * Also see `isPromise(obj)` which checks for a standard [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n *\n * ```js\n * var isPromiseLike = require(\"can-util/js/is-promise-like/is-promise-like\");\n *\n * var promise = new Promise(function(resolve){\n *   resolve();\n * });\n *\n * console.log(isPromiseLike(promise)); // -> true\n * console.log(isPromiseLike(\"foo bar\")); // -> false\n * ```\n *\n * @param {Object} obj An object to be tested.\n * @return {Boolean} True if the object is a Promise.\n */\nmodule.exports = function(obj){\n\treturn !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/is-promise-like/is-promise-like.js\n// module id = 101\n// module chunks = 0","'use strict';\n\nvar parseURI = require('../parse-uri/parse-uri');\n\nmodule.exports = function(base, href) {\n\tfunction removeDotSegments(input) {\n\t\tvar output = [];\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, '')\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, '/')\n\t\t\t.replace(/\\/\\.\\.$/, '/../')\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\n\t\t\t\tif (p === '/..') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(p);\n\t\t\t\t}\n\t\t\t});\n\t\treturn output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n\t}\n\n\thref = parseURI(href || '');\n\tbase = parseURI(base || '');\n\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\n\t\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n\t\t\thref.hash;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/join-uris/join-uris.js\n// module id = 102\n// module chunks = 0","'use strict';\n\nmodule.exports = function(url){\n\t\tvar m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n\t\t\t// authority = '//' + user + ':' + pass '@' + hostname + ':' port\n\t\treturn (m ? {\n\t\t\thref     : m[0] || '',\n\t\t\tprotocol : m[1] || '',\n\t\t\tauthority: m[2] || '',\n\t\t\thost     : m[3] || '',\n\t\t\thostname : m[4] || '',\n\t\t\tport     : m[5] || '',\n\t\t\tpathname : m[6] || '',\n\t\t\tsearch   : m[7] || '',\n\t\t\thash     : m[8] || ''\n\t\t} : null);\n\t};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/parse-uri/parse-uri.js\n// module id = 103\n// module chunks = 0","// can-util/js/single-reference/single-reference\nvar CID = require(\"../cid/get-cid\");\n\n\nvar singleReference;\n\n\n// weak maps are slow\n/* if(typeof WeakMap !== \"undefined\") {\n\tvar globalMap = new WeakMap();\n\tsingleReference = {\n\t\tset: function(obj, key, value){\n\t\t\tvar localMap = globalMap.get(obj);\n\t\t\tif( !localMap ) {\n\t\t\t\tglobalMap.set(obj, localMap = new WeakMap());\n\t\t\t}\n\t\t\tlocalMap.set(key, value);\n\t\t},\n\t\tgetAndDelete: function(obj, key){\n\t\t\treturn globalMap.get(obj).get(key);\n\t\t},\n\t\treferences: globalMap\n\t};\n} else {*/\n  singleReference = {\n      // obj is a function ... we need to place `value` on it so we can retreive it\n      // we can't use a global map\n      set: function(obj, key, value){\n         // check if it has a single reference map\n         var keyName = CID(key);\n         obj[keyName] = value;\n      },\n\n      getAndDelete: function(obj, key){\n         var cid = CID(key);\n         var value = obj[cid];\n         delete obj[cid];\n         return value;\n      }\n  };\n//}\n\nmodule.exports = singleReference;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/single-reference/single-reference.js\n// module id = 104\n// module chunks = 0","'use strict';\n\n\nmodule.exports = function(str){\n\tswitch(str) {\n\t\tcase \"NaN\":\n\t\tcase \"Infinity\":\n\t\t\treturn +str;\n\t\tcase \"null\":\n\t\t\treturn null;\n\t\tcase \"undefined\":\n\t\t\treturn undefined;\n\t\tcase \"true\":\n\t\tcase \"false\":\n\t\t\treturn str === \"true\";\n\t\tdefault:\n\t\t\tvar val = +str;\n\t\t\tif(!isNaN(val)) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn str;\n\t\t\t}\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-util/js/string-to-any/string-to-any.js\n// module id = 105\n// module chunks = 0","var attr = require('can-util/dom/attr/attr');\nvar live = require('./core');\n/**\n * @function can-view-live.attr attr\n * @parent can-view-live\n *\n * @signature `live.attr(el, attributeName, compute)`\n *\n * Keep an attribute live to a [can-compute].\n *\n * ```js\n * var div = document.createElement('div');\n * var compute = canCompute(\"foo bar\");\n * live.attr(div,\"class\", compute);\n * ```\n *\n * @param {HTMLElement} el The element whos attribute will be kept live.\n * @param {String} attributeName The attribute name.\n * @param {can-compute} compute The compute.\n *\n */\nlive.attr = function(el, attributeName, compute){\n\t// #### live.attr\n\t// Bind a single attribute on an element to a compute\n\tlive.listen(el, compute, function (ev, newVal) {\n\t// when compute gets a new value, set the attribute\n\t//  to the new value\n\t\tattr.set(el, attributeName, newVal);\n\t});\n\t// do initial set of attribute as well\n\tattr.set(el, attributeName, compute());\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/attr.js\n// module id = 106\n// module chunks = 0","// This provides live binding for stache attributes.\nvar live = require('./core');\nvar viewCallbacks = require('can-view-callbacks');\nvar attr = require('can-util/dom/attr/attr');\nvar domEvents = require('can-util/dom/events/events');\nvar types = require('can-types');\n\nlive.attrs = function(el, compute, scope, options) {\n\tif(!types.isCompute(compute)) {\n\t\t// Non-live case (`compute` was not a compute):\n\t\t//  set all attributes on the element and don't\n\t\t//  worry about setting up live binding since there\n\t\t//  is not compute to bind on.\n\t\tvar attrs = live.getAttributeParts(compute);\n\t\tfor(var name in attrs) {\n\t\t\tattr.set(el, name, attrs[name]);\n\t\t}\n\t\treturn;\n\t}\n\n\t// last set of attributes\n\tvar oldAttrs = {};\n\n\t// set up a callback for handling changes when the compute\n\t// changes\n\tvar setAttrs = function (newVal) {\n\t\tvar newAttrs = live.getAttributeParts(newVal),\n\t\t\tname;\n\t\tfor(name in newAttrs) {\n\t\t\tvar newValue = newAttrs[name],\n\t\t\t\t// `oldAttrs` was set on the last run of setAttrs in this context\n\t\t\t\t//  (for this element and compute)\n\t\t\t\toldValue = oldAttrs[name];\n\t\t\t// Only fire a callback\n\t\t\t//  if the value of the attribute has changed\n\t\t\tif(newValue !== oldValue) {\n\t\t\t\t// set on DOM attributes (dispatches an \"attributes\" event as well)\n\t\t\t\tattr.set(el, name, newValue);\n\t\t\t\t// get registered callback for attribute name and fire\n\t\t\t\tvar callback = viewCallbacks.attr(name);\n\t\t\t\tif(callback) {\n\t\t\t\t\tcallback(el, {\n\t\t\t\t\t\tattributeName: name,\n\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// remove key found in new attrs from old attrs\n\t\t\tdelete oldAttrs[name];\n\t\t}\n\t\t// any attrs left at this point are not set on the element now,\n\t\t// so remove them.\n\t\tfor(name in oldAttrs) {\n\t\t\tattr.remove(el, name);\n\t\t}\n\t\toldAttrs = newAttrs;\n\t};\n\n\tvar handler = function (ev, newVal) {\n\t\tsetAttrs(newVal);\n\t};\n\n\t// set attributes on any change to the compute\n\tcompute.addEventListener('change', handler);\n\n\tvar teardownHandler = function() {\n\t\tcompute.removeEventListener('change', handler);\n\t\tdomEvents.removeEventListener.call(el, 'removed', teardownHandler);\n\t};\n\t// unbind on element removal\n\tdomEvents.addEventListener.call(el, 'removed', teardownHandler);\n\n\t// set up a current attribute set and assign to oldAttrs\n\tsetAttrs(compute());\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/attrs.js\n// module id = 107\n// module chunks = 0","var live = require('./core');\nvar nodeLists = require('can-view-nodelist');\nvar makeFrag = require('can-util/dom/frag/frag');\nvar makeArray = require('can-util/js/make-array/make-array');\nvar childNodes = require('can-util/dom/child-nodes/child-nodes');\n\n/**\n * @function can-view-live.html html\n * @parent can-view-live\n * @release 2.0.4\n *\n * Live binds a compute's value to a collection of elements.\n *\n * @signature `live.html(el, compute, [parentNode])`\n *\n * `live.html` is used to setup incremental live-binding on a block of html.\n *\n * ```js\n * // a compute that changes its list\n * var greeting = compute(function(){\n *   return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n * });\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"#greeting\").append(placeholder);\n *\n * live.html(placeholder, greeting);\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {can.compute} compute A [can.compute] whose value is HTML.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n *\n */\nlive.html = function (el, compute, parentNode, nodeList) {\n\tvar data;\n\t// prefer to manipulate el's actual parent over the supplied parent\n\tparentNode = live.getParentNode(el, parentNode);\n\tdata = live.listen(parentNode, compute, function (ev, newVal, oldVal) {\n\t\t// the attachment point for the nodelist\n\t\tvar attached = nodeLists.first(nodes).parentNode;\n\t\t// update the nodes in the DOM with the new rendered value\n\t\tif (attached) {\n\t\t\tmakeAndPut(newVal);\n\t\t}\n\t\tvar pn = nodeLists.first(nodes).parentNode;\n\t\tdata.teardownCheck(pn);\n\t\tlive.callChildMutationCallback(pn);\n\t});\n\n\t// Nodes registered to the live operation, either a list of nodes or a single element\n\tvar nodes = nodeList || [el],\n\t\tmakeAndPut = function (val) {\n\t\t\t// ##### makeandput\n\t\t\t// Receives the compute output (must be some DOM representation or a function)\n\t\t\tvar isFunction = typeof val === \"function\",\n\t\t\t\taNode = live.isNode(val),\n\t\t\t\t// translate val into a document fragment if it's DOM-like\n\t\t\t\tfrag = makeFrag(isFunction ? \"\" : val),\n\t\t\t\t// previous set of nodes\n\t\t\t\toldNodes = makeArray(nodes);\n\n\t\t\t// Add a placeholder textNode if necessary.\n\t\t\tlive.addTextNodeIfNoChildren(frag);\n\n\t\t\t// Mark each node as belonging to the node list.\n\t\t\toldNodes = nodeLists.update(nodes, childNodes(frag));\n\t\t\tif(isFunction) {\n\t\t\t\tval(frag.firstChild);\n\t\t\t}\n\t\t\t// DOM replace old nodes with new frag (which might contain some old nodes)\n\t\t\tnodeLists.replace(oldNodes, frag);\n\t\t};\n\n\tdata.nodeList = nodes;\n\n\t// register the span so nodeLists knows the parentNodeList\n\tif(!nodeList) {\n\t\tnodeLists.register(nodes, data.teardownCheck);\n\t} else {\n\t\tnodeList.unregistered = data.teardownCheck;\n\t}\n\t// Finally give the subtree an initial value\n\tmakeAndPut(compute());\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/html.js\n// module id = 108\n// module chunks = 0","var live = require('./core');\nvar makeRunInOrder = require('./util/runInOrder');\nvar runInOrder = makeRunInOrder();\n\nvar nodeLists = require('can-view-nodelist');\nvar makeCompute = require('can-compute');\nvar canBatch = require('can-event/batch/batch');\n\nvar frag = require('can-util/dom/frag/frag');\nvar domMutate = require('can-util/dom/mutate/mutate');\nvar childNodes = require('can-util/dom/child-nodes/child-nodes');\n\nvar makeArray = require('can-util/js/make-array/make-array');\nvar each = require('can-util/js/each/each');\nvar isFunction = require('can-util/js/is-function/is-function');\nvar diff = require('can-util/js/diff/diff');\nvar splice = [].splice;\n\n// #### renderAndAddToNodeLists\n// a helper function that renders something and adds its nodeLists to newNodeLists\n// in the right way for stache.\nvar renderAndAddToNodeLists = function(newNodeLists, parentNodeList, render, context, args){\n\tvar itemNodeList = [];\n\n\tif(parentNodeList) {\n\t\t// With a supplied parent list, \"directly\" register the new nodeList\n\t\t//  as a child.\n\t\tnodeLists.register(itemNodeList,null, parentNodeList, true);\n\t\titemNodeList.parentList = parentNodeList;\n\t\titemNodeList.expression = \"#each SUBEXPRESSION\";\n\t}\n\n\t// call the renderer, passing in the new nodeList as the last argument\n\tvar itemHTML = render.apply(context, args.concat([itemNodeList])),\n\t// and put the output into a document fragment\n\t\titemFrag = frag(itemHTML);\n\n\t// get all the direct children of the frag\n\tvar children = makeArray(childNodes(itemFrag));\n\tif(parentNodeList) {\n\t\t// if a parent list was supplied, children of the frag become the\n\t\t//  child nodeList items.\n\t\tnodeLists.update(itemNodeList, children);\n\t\tnewNodeLists.push(itemNodeList);\n\t} else {\n\t\t// If no parent nodeList, register the new array of frag children as a nodeList\n\t\t//  and push into the nodeLists\n\t\tnewNodeLists.push(nodeLists.register(children));\n\t}\n\treturn itemFrag;\n},\n// #### removeFromNodeList\n// a splicing helper for nodeLists, which removes sublists, including unregistering,\n//  for a contiguous slice of the master list.\nremoveFromNodeList = function(masterNodeList, index, length){\n\tvar removedMappings = masterNodeList.splice(index + 1, length),\n\t\titemsToRemove = [];\n\teach(removedMappings, function (nodeList) {\n\n\t\t// Unregister to free up event bindings.\n\t\tvar nodesToRemove = nodeLists.unregister(nodeList);\n\n\t\t// add items that we will remove all at once\n\t\t[].push.apply(itemsToRemove, nodesToRemove);\n\t});\n\treturn itemsToRemove;\n},\n// #### addFalseyIfEmpty\n// Add the results of redering the \"falsey\" or inverse case render to the \n// master nodeList and the DOM if the live list is empty\naddFalseyIfEmpty = function(list, falseyRender, masterNodeList, nodeList){\n\tif(falseyRender && list.length === 0){\n\t\t// If there are no items ... we should render the falsey template\n\t\tvar falseyNodeLists = [];\n\t\tvar falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);\n\n\t\t// put the frag after the reference element in the associated nodeList\n\t\tnodeLists.after([masterNodeList[0]], falseyFrag);\n\t\t// and push the first element onto the master list\n\t\tmasterNodeList.push(falseyNodeLists[0]);\n\t}\n};\n\n/**\n * @function can-view-live.list list\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.list(el, list, render, context, [parentNode])`\n *\n * Live binds a compute's list incrementally.\n *\n * ```js\n * // a compute that change's it's list\n * var todos = compute(function(){\n *   return new Todo.List({page: can.route.attr(\"page\")})\n * })\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"ul#todos\").append(placeholder);\n *\n * can.view.live.list(\n *   placeholder,\n *   todos,\n *   function(todo, index){\n *     return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n *   });\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {can-compute|can-list|can-define/list/list} list An observable list type.\n *\n * @param {function(this:*,*,index):String} render(index, index) A function that when called with\n * the incremental item to render and the index of the item in the list.\n *\n * @param {Object} context The `this` the `render` function will be called with.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n *\n */\nlive.list = function (el, compute, render, context, parentNode, nodeList, falseyRender) {\n\t// A nodeList of all elements this live-list manages.\n\t// This is here so that if this live list is within another section\n\t// that section is able to remove the items in this list.\n\tvar masterNodeList = nodeList || [el],\n\t\t// A mapping of items to their indices\n\t\tindexMap = [],\n\t\t// True once all previous events have been fired\n\t\tafterPreviousEvents = false,\n\t\t// Indicates that we should not be responding to changes in the list.\n\t\t// It's possible that the compute change causes this list behavior to be torn down.\n\t\t// However that same \"change\" dispatch will eventually fire the updateList handler because\n\t\t// the list of \"change\" handlers is copied when dispatching starts.\n\t\t// A 'perfect' fix would be to use linked lists for event handlers.\n\t\tisTornDown = false,\n\t\t// Called when items are added to the list.\n\t\tadd = runInOrder(function add (ev, items, index) {\n\n\t\t\tif (!afterPreviousEvents) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Collect new html and mappings\n\t\t\tvar frag = text.ownerDocument.createDocumentFragment(),\n\t\t\t\tnewNodeLists = [],\n\t\t\t\tnewIndicies = [];\n\t\t\t// For each new item,\n\t\t\teach(items, function (item, key) {\n\n\t\t\t\tvar itemIndex = makeCompute(key + index),\n\t\t\t\t\titemCompute = makeCompute(function(newVal){\n\t\t\t\t\t\tif(arguments.length) {\n\t\t\t\t\t\t\tif(\"set\" in list) {\n\t\t\t\t\t\t\t\tlist.set(itemIndex(), newVal);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.attr(itemIndex(), newVal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\titemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [itemCompute, itemIndex]);\n\n\t\t\t\t// Hookup the fragment (which sets up child live-bindings) and\n\t\t\t\t// add it to the collection of all added elements.\n\t\t\t\tfrag.appendChild(itemFrag);\n\t\t\t\t// track indicies;\n\t\t\t\tnewIndicies.push(itemIndex);\n\t\t\t});\n\t\t\t// The position of elements is always after the initial text placeholder node\n\t\t\tvar masterListIndex = index+1;\n\n\t\t\t// remove falsey if there's something there\n\t\t\tif(!indexMap.length) {\n\t\t\t\t// remove all leftover things\n\t\t\t\tvar falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);\n\t\t\t\tnodeLists.remove(falseyItemsToRemove);\n\t\t\t}\n\n\t\t\t// Check if we are adding items at the end\n\t\t\tif (!masterNodeList[masterListIndex]) {\n\t\t\t\tnodeLists.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);\n\t\t\t} else {\n\t\t\t\t// Add elements before the next index's first element.\n\t\t\t\tvar el = nodeLists.first(masterNodeList[masterListIndex]);\n\t\t\t\tdomMutate.insertBefore.call(el.parentNode, frag, el);\n\t\t\t}\n\t\t\tsplice.apply(masterNodeList, [\n\t\t\t\tmasterListIndex,\n\t\t\t\t0\n\t\t\t].concat(newNodeLists));\n\n\t\t\t// update indices after insert point\n\t\t\tsplice.apply(indexMap, [\n\t\t\t\tindex,\n\t\t\t\t0\n\t\t\t].concat(newIndicies));\n\n\t\t\tfor (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {\n\t\t\t\tindexMap[i](i);\n\t\t\t}\n\t\t\tif(ev.callChildMutationCallback !== false) {\n\t\t\t\tlive.callChildMutationCallback(text.parentNode);\n\t\t\t}\n\n\t\t}),\n\t\t// Called when an item is set with .attr\n\t\tset = function(ev, newVal, index) {\n\t\t\tremove({}, { length: 1 }, index, true);\n\t\t\tadd({}, [newVal], index);\n\t\t},\n\t\t// Called when items are removed or when the bindings are torn down.\n\t\tremove = runInOrder(function remove (ev, items, index, duringTeardown, fullTeardown) {\n\n\t\t\tif (!afterPreviousEvents) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If this is because an element was removed, we should\n\t\t\t// check to make sure the live elements are still in the page.\n\t\t\t// If we did this during a teardown, it would cause an infinite loop.\n\t\t\tif (!duringTeardown && data.teardownCheck(text.parentNode)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(index < 0) {\n\t\t\t\tindex = indexMap.length + index;\n\t\t\t}\n\t\t\tvar itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);\n\n\t\t\t// update indices after remove point\n\t\t\tindexMap.splice(index, items.length);\n\t\t\tfor (var i = index, len = indexMap.length; i < len; i++) {\n\t\t\t\tindexMap[i](i);\n\t\t\t}\n\n\t\t\t// don't remove elements during teardown.  Something else will probably be doing that.\n\t\t\tif(!fullTeardown) {\n\t\t\t\t// adds the falsey section if the list is empty\n\t\t\t\taddFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);\n\t\t\t\tnodeLists.remove(itemsToRemove);\n\t\t\t\tif(ev.callChildMutationCallback !== false) {\n\t\t\t\t\tlive.callChildMutationCallback(text.parentNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnodeLists.unregister(masterNodeList);\n\t\t\t}\n\t\t}),\n\t\tmove = function (ev, item, newIndex, currentIndex) {\n\t\t\tif (!afterPreviousEvents) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// The position of elements is always after the initial text\n\t\t\t// placeholder node\n\t\t\tnewIndex = newIndex + 1;\n\t\t\tcurrentIndex = currentIndex + 1;\n\n\t\t\tvar referenceNodeList = masterNodeList[newIndex];\n\t\t\tvar movedElements = frag( nodeLists.flatten(masterNodeList[currentIndex]) );\n\t\t\tvar referenceElement;\n\n\t\t\t// If we're moving forward in the list, we want to be placed before\n\t\t\t// the item AFTER the target index since removing the item from\n\t\t\t// the currentIndex drops the referenceItem's index. If there is no\n\t\t\t// nextSibling, insertBefore acts like appendChild.\n\t\t\tif (currentIndex < newIndex) {\n\t\t\t\treferenceElement = nodeLists.last(referenceNodeList).nextSibling;\n\t\t\t} else {\n\t\t\t\treferenceElement = nodeLists.first(referenceNodeList);\n\t\t\t}\n\n\t\t\tvar parentNode = masterNodeList[0].parentNode;\n\n\t\t\t// Move the DOM nodes into the proper location\n\t\t\tparentNode.insertBefore(movedElements, referenceElement);\n\n\t\t\t// Now, do the same for the masterNodeList. We need to keep it\n\t\t\t// in sync with the DOM.\n\n\t\t\t// Save a reference to the \"node\" that we're manually moving\n\t\t\tvar temp = masterNodeList[currentIndex];\n\n\t\t\t// Remove the movedItem from the masterNodeList\n\t\t\t[].splice.apply(masterNodeList, [currentIndex, 1]);\n\n\t\t\t// Move the movedItem to the correct index in the masterNodeList\n\t\t\t[].splice.apply(masterNodeList, [newIndex, 0, temp]);\n\n\t\t\t// Convert back to a zero-based array index\n\t\t\tnewIndex = newIndex - 1;\n\t\t\tcurrentIndex = currentIndex - 1;\n\n\t\t\t// Grab the index compute from the `indexMap`\n\t\t\tvar indexCompute = indexMap[currentIndex];\n\n\t\t\t// Remove the index compute from the `indexMap`\n\t\t\t[].splice.apply(indexMap, [currentIndex, 1]);\n\n\t\t\t// Move the index compute to the correct index in the `indexMap`\n\t\t\t[].splice.apply(indexMap, [newIndex, 0, indexCompute]);\n\n\t\t\tvar i = Math.min(currentIndex, newIndex);\n\t\t\tvar len = indexMap.length;\n\n\t\t\tfor (i, len; i < len; i++) {\n\t\t\t\t// set each compute to have its current index in the map as its value\n\t\t\t\tindexMap[i](i);\n\t\t\t}\n\t\t\tif(ev.callChildMutationCallback !== false) {\n\t\t\t\t// fire any registered mutation callback\n\t\t\t\tlive.callChildMutationCallback(text.parentNode);\n\t\t\t}\n\t\t},\n\t\t// A text node placeholder\n\t\ttext = el.ownerDocument.createTextNode(''),\n\t\t// The current list.\n\t\tlist,\n\t\t// Called when the list is replaced with a new list or the binding is torn-down.\n\t\tteardownList = function (fullTeardown) {\n\t\t\t// there might be no list right away, and the list might be a plain\n\t\t\t// array\n\t\t\tif (list && list.removeEventListener) {\n\t\t\t\tlist.removeEventListener('add', add);\n\t\t\t\tlist.removeEventListener('set', set);\n\t\t\t\tlist.removeEventListener('remove', remove);\n\t\t\t\tlist.removeEventListener('move', move);\n\t\t\t}\n\t\t\t// use remove to clean stuff up for us\n\t\t\tremove({callChildMutationCallback: !!fullTeardown}, {\n\t\t\t\tlength: masterNodeList.length - 1\n\t\t\t}, 0, true, fullTeardown);\n\t\t},\n\t\t// Called when the list is replaced or setup.\n\t\tupdateList = function (ev, newList, oldList) {\n\n\t\t\tif(isTornDown) {\n\t\t\t\t// take no further action if teardown is already done\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tafterPreviousEvents = true;\n\t\t\tif(newList && oldList) {\n\t\t\t\t// Update old list nodes to new ones if an update from list to list\n\t\t\t\tlist = newList || [];\n\t\t\t\t// The minimal diff between lists\n\t\t\t\tvar patches = diff(oldList, newList);\n\n\t\t\t\t// Tear down event bindings if old list is observable\n\t\t\t\tif ( oldList.removeEventListener ) {\n\t\t\t\t\toldList.removeEventListener('add', add);\n\t\t\t\t\toldList.removeEventListener('set', set);\n\t\t\t\t\toldList.removeEventListener('remove', remove);\n\t\t\t\t\toldList.removeEventListener('move', move);\n\t\t\t\t}\n\t\t\t\tfor(var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\t\t\t\tvar patch = patches[i];\n\t\t\t\t\tif(patch.deleteCount) {\n\t\t\t\t\t\t// Remove any items scheduled for deletion from the patch.\n\t\t\t\t\t\tremove({callChildMutationCallback: false}, {\n\t\t\t\t\t\t\tlength: patch.deleteCount\n\t\t\t\t\t\t}, patch.index, true);\n\t\t\t\t\t}\n\t\t\t\t\tif(patch.insert.length) {\n\t\t\t\t\t\t// Insert any new items at the index\n\t\t\t\t\t\tadd({callChildMutationCallback: false}, patch.insert, patch.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(oldList) {\n\t\t\t\t\t// no new list.  Teardown.\n\t\t\t\t\tteardownList();\n\t\t\t\t}\n\t\t\t\t// push new items list onto the list (there are no oldItems of concern)\n\t\t\t\tlist = newList || [];\n\t\t\t\tadd({callChildMutationCallback: false}, list, 0);\n\t\t\t\t// for an empty newList, render the falsey section\n\t\t\t\taddFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);\n\t\t\t}\n\t\t\t// Listeners on the mutation observer should fire now (DOM has been fully updated)\n\t\t\tlive.callChildMutationCallback(text.parentNode);\n\n\t\t\tafterPreviousEvents = false;\n\t\t\t// list might be a plain array.\n\t\t\tif (list.addEventListener) {\n\t\t\t\t// If observable, set up bindings on list changes\n\t\t\t\tlist.addEventListener('add', add);\n\t\t\t\tlist.addEventListener('set', set);\n\t\t\t\tlist.addEventListener('remove', remove);\n\t\t\t\tlist.addEventListener('move', move);\n\t\t\t}\n\n\t\t\tcanBatch.afterPreviousEvents(function(){\n\t\t\t\t// at this time, all current add/move/set/remove in this context is complete,\n\t\t\t\t// so allow those functions to be called again.\n\t\t\t\tafterPreviousEvents = true;\n\t\t\t});\n\t\t};\n\n\t// Use element's parent node if available\n\tparentNode = live.getParentNode(el, parentNode);\n\t// Setup binding and teardown to add and remove events\n\tvar data = live.setup(parentNode, function () {\n\t\t// TODO: for stache, binding on the compute is not necessary.\n\t\tif (isFunction(compute)) {\n\t\t\tcompute.addEventListener('change', updateList);\n\t\t}\n\t}, function () {\n\t\t// Teardown handler when parentNode is removed\n\t\tif (isFunction(compute)) {\n\t\t\tcompute.removeEventListener('change', updateList);\n\t\t}\n\t\tteardownList(true);\n\t});\n\n\tif(!nodeList) {\n\t\t// When no nodeList specified, the masterNodeList is the original element;\n\t\t//  replace with the rendered text transformed to DOM elements.\n\t\tlive.replace(masterNodeList, text, data.teardownCheck);\n\t} else {\n\t\t// Otherwise replace the nodeList elements, and set up an unregister\n\t\t// handler\n\t\tnodeLists.replace(masterNodeList, text);\n\t\tnodeLists.update(masterNodeList, [text]);\n\t\tnodeList.unregistered = function(){\n\t\t\tdata.teardownCheck();\n\t\t\tisTornDown = true;\n\t\t};\n\t}\n\t// run the list setup\n\tupdateList({}, isFunction(compute) ? compute() : compute);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/list.js\n// module id = 109\n// module chunks = 0","var live = require('./core');\nvar nodeLists = require('can-view-nodelist');\n\n/**\n * @function can-view-live.text text\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.text(el, compute, [parentNode], [nodeList])`\n *\n * Replaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n */\nlive.text = function (el, compute, parentNode, nodeList) {\n\tvar parent = live.getParentNode(el, parentNode);\n\t// setup listening right away so we don't have to re-calculate value\n\tvar data = live.listen(parent, compute, function (ev, newVal, oldVal) {\n\t\t// Sometimes `node.nodeValue` is 'unknown' in IE and will throw an exception if it is\n\t\t/* jshint ignore:start */\n\t\tif (typeof node.nodeValue !== 'unknown') {\n\t\t\tnode.nodeValue = live.makeString(newVal);\n\t\t}\n\t\t/* jshint ignore:end */\n\t});\n\n\t// Create a new text node from the compute value\n\tvar node = el.ownerDocument.createTextNode(live.makeString(compute()));\n\tif(nodeList) {\n\t\t// If a known nodelist is passed in, update the list to have the new\n\t\t//  callbacks... \n\t\tnodeList.unregistered = data.teardownCheck;\n\t\tdata.nodeList = nodeList;\n\n\t\t// ...and new text node, and replace the previously associated node with \n\t\t//  the new node\n\t\tnodeLists.update(nodeList, [node]);\n\t\tnodeLists.replace([el], node);\n\t} else {\n\t\t// Otherwise, replace the placeholder with the live node and do the nodeLists thing.\n\t\t// Add that node to nodeList so we can remove it when the parent element is removed from the page\n\t\tdata.nodeList = live.replace([el], node, data.teardownCheck);\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/text.js\n// module id = 110\n// module chunks = 0","module.exports = function makeRunInOrder() {\n\tvar running = 0;\n\tvar tasks = [];\n\n\treturn function runInOrder(fn) {\n\t\treturn function() {\n\t\t\tvar fnArgs = arguments;\n\n\t\t\tif (running) {\n\t\t\t\ttasks.push({\n\t\t\t\t\tfn: fn,\n\t\t\t\t\targs: fnArgs\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trunning++;\n\t\t\tfn.apply(null, fnArgs);\n\t\t\trunning--;\n\n\t\t\twhile (tasks.length) {\n\t\t\t\trunning++;\n\t\t\t\ttasks[0].fn.apply(null, tasks[0].args);\n\t\t\t\ttasks.shift();\n\t\t\t\trunning--;\n\t\t\t}\n\t\t};\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-live/lib/util/runInOrder.js\n// module id = 111\n// module chunks = 0","var Observation = require('can-observation');\nvar observeReader = require('can-observation/reader/reader');\nvar makeCompute = require('can-compute');\n\nvar types = require('can-types');\nvar isFunction = require('can-util/js/is-function/is-function');\nvar isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');\n\n\n// The goal of this is to create a high-performance compute that represents a key value from can.view.Scope.\n// If the key value is something like {{name}} and the context is a can.Map, a faster\n// binding path will be used where new rebindings don't need to be looked for with every change of\n// the observable property.\n// However, if the property changes to a compute, then the slower `can.compute.read` method of\n// observing values will be used.\n\nvar isFastPath = function(computeData){\n\tif(  computeData.reads &&\n\t\t\t\t// a single property read\n\t\t\t\tcomputeData.reads.length === 1 ) {\n\t\tvar root = computeData.root;\n\t\tif( types.isCompute(root) ) {\n\t\t\troot = root();\n\t\t}\n\t\t// on a map\n\t\treturn types.isMapLike(root) &&\n\t\t\t// that isn't calling a function\n\t\t\t!isFunction(root[computeData.reads[0].key]);\n\t}\n\treturn;\n};\n\nvar scopeReader = function(scope, key, options, computeData, newVal){\n\tif (arguments.length > 4) {\n\t\tvar root = computeData.root || computeData.setRoot;\n\t\tif(root) {\n\t\t\tobserveReader.write(root, computeData.reads, newVal, options);\n\t\t} else {\n\t\t\tscope.set(key, newVal, options);\n\t\t}\n\t\t// **Compute getter**\n\t} else {\n\t\t// If computeData has found the value for the key in the past in an observable then go directly to\n\t\t// the observable (computeData.root) that the value was found in the last time and return the new value.  This\n\t\t// is a huge performance gain for the fact that we aren't having to check the entire scope each time.\n\t\tif (computeData.root) {\n\t\t\treturn observeReader.read(computeData.root, computeData.reads, options)\n\t\t\t\t.value;\n\t\t}\n\t\t// If the key has not already been located in a observable then we need to search the scope for the\n\t\t// key.  Once we find the key then we need to return it's value and if it is found in an observable\n\t\t// then we need to store the observable so the next time this compute is called it can grab the value\n\t\t// directly from the observable.\n\t\tvar data = scope.read(key, options);\n\t\tcomputeData.scope = data.scope;\n\t\tcomputeData.initialValue = data.value;\n\t\tcomputeData.reads = data.reads;\n\t\tcomputeData.root = data.rootObserve;\n\t\tcomputeData.setRoot = data.setRoot;\n\t\treturn data.value;\n\t}\n};\n\nmodule.exports = function(scope, key, options){\n\toptions = options || {\n\t\targs: []\n\t};\n\t// the object we are returning\n\tvar computeData = {},\n\t\t// a function that can be passed to Observation, or used as a setter\n\t\tscopeRead = function (newVal) {\n\t\t\tif(arguments.length) {\n\t\t\t\treturn scopeReader(scope, key, options, computeData, newVal);\n\t\t\t} else {\n\t\t\t\treturn scopeReader(scope, key, options, computeData);\n\t\t\t}\n\t\t},\n\t\tcompute = makeCompute(undefined,{\n\t\t\ton: function() {\n\t\t\t\t// setup the observing\n\t\t\t\tobservation.start();\n\n\t\t\t\tif( isFastPath(computeData) ) {\n\t\t\t\t\t// When the one dependency changes, we can simply get its newVal and\n\t\t\t\t\t// save it.  If it's a function, we need to start binding the old way.\n\t\t\t\t\tobservation.dependencyChange = function(ev, newVal){\n\n\t\t\t\t\t\tif(types.isMapLike(ev.target) && typeof newVal !== \"function\") {\n\t\t\t\t\t\t\tthis.newVal = newVal;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// restore\n\t\t\t\t\t\t\tobservation.dependencyChange = Observation.prototype.dependencyChange;\n\t\t\t\t\t\t\tobservation.start = Observation.prototype.start;\n\t\t\t\t\t\t\tcompute.fastPath = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Observation.prototype.dependencyChange.call(this, ev);\n\t\t\t\t\t};\n\t\t\t\t\tobservation.start = function(){\n\t\t\t\t\t\tthis.value = this.newVal;\n\t\t\t\t\t};\n\t\t\t\t\tcompute.fastPath = true;\n\t\t\t\t}\n\t\t\t\t// TODO deal with this right\n\t\t\t\tcompute.computeInstance.value = observation.value;\n\t\t\t\tcompute.computeInstance.hasDependencies = !isEmptyObject(observation.newObserved);\n\t\t\t},\n\t\t\toff: function(){\n\t\t\t\tobservation.stop();\n\t\t\t},\n\t\t\tset: scopeRead,\n\t\t\tget: scopeRead,\n\t\t\t// a hack until we clean up can.compute for 3.0\n\t\t\t__selfUpdater: true\n\t\t}),\n\n\t\t// the observables read by the last calling of `scopeRead`\n\t\tobservation = new Observation(scopeRead, null, compute.computeInstance);\n\tcompute.computeInstance.observation = observation;\n\tcomputeData.compute = compute;\n\treturn computeData;\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-scope/compute_data.js\n// module id = 112\n// module chunks = 0","var types = require(\"can-types\");\nvar SimpleMap = require(\"can-simple-map\");\n\n// this is a very simple can-map like object\nvar ReferenceMap = SimpleMap.extend({});\n\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj) {\n\tif(obj instanceof ReferenceMap) {\n\t\treturn true;\n\t}\n\treturn oldIsMapLike.call(this, obj);\n};\n\nmodule.exports = ReferenceMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/can-view-scope/reference-map.js\n// module id = 113\n// module chunks = 0","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 114\n// module chunks = 0","import DefineMap from 'can-define/map/map';\r\nimport CanEvent from 'can-event';\r\nimport FieldIteratorMap from '../util/field/base/FieldIteratorMap';\r\nimport assign from 'object-assign';\r\n\r\n/**\r\n * @constructor property-table.ViewModel ViewModel\r\n * @parent property-table\r\n * @group property-table.ViewModel.props Properties\r\n * @description A `<property-table />` component's ViewModel. This viewmodel\r\n * extends the [util/field/ ]'s properties\r\n *\r\n */\r\nconst ViewModel = FieldIteratorMap.extend('PropertyTable', {\r\n    /**\r\n     * @prototype\r\n     */\r\n   /**\r\n    * A string referencing a field property that will exclude that field\r\n    * from this classes fields. The default is 'detail'.\r\n    * @property {String} property-table.ViewModel.props.excludeFieldKey excludeFieldKey\r\n    * @parent property-table.ViewModel.props\r\n    */\r\n    excludeFieldKey: {\r\n        value: 'detail'\r\n    },\r\n    /**\r\n     * A flag to allow editing (Not yet implemented)\r\n     * TODO: implement editing\r\n     * @property {Boolean} property-table.ViewModel.props.edit\r\n     * @parent property-table.ViewModel.props\r\n     */\r\n    edit: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * A flag to allow deleting (Not yet implemented)\r\n     * TODO: implement deleting\r\n     * @property {Boolean} property-table.ViewModel.props.delete\r\n     * @parent property-table.ViewModel.props\r\n     */\r\n    delete: {\r\n        type: 'boolean',\r\n        value: true\r\n    },\r\n    /**\r\n     * The ID value of the object that should be retrieved. This value along with the connection object will be used to retrieve an object from a RESTful service\r\n     * @property {Number} property-table.ViewModel.props.objectId\r\n     * @parent property-table.ViewModel.props\r\n     */\r\n    objectId: {\r\n        type: 'number',\r\n        set (id) {\r\n            this.fetchObject(this.connection, id);\r\n            return id;\r\n        }\r\n    },\r\n    /**\r\n     * The connection object that should be used to retrieve an object. This\r\n     * value along with the objectId value will be used to retrieve an object\r\n     * from a RESTful service\r\n     * @link http://canjs.com/doc/can-connect.html can-connect\r\n     * @property {can-connect} property-table.ViewModel.props.connection\r\n     * @parent property-table.ViewModel.props\r\n     */\r\n    connection: {\r\n        set (con) {\r\n            this.fetchObject(con, this.objectId);\r\n            return con;\r\n        }\r\n    },\r\n    /**\r\n     * A generic object to display in a tabular format. This can be used instead\r\n     * of providing a connection and objectId property\r\n     * @property {Object} property-table.ViewModel.props.object\r\n     * @parent property-table.ViewModel.props\r\n     */\r\n    object: DefineMap,\r\n    /**\r\n     * A promise that resolves to the object. Used to determine state of current fetching operations\r\n     * @property {Promise}  property-table.ViewModel.props.objectPromise\r\n     * @parent property-table.ViewModel.props\r\n     */\r\n    objectPromise: {},\r\n    /**\r\n     * Asynchronously fetches an object using a can-connect model and an id\r\n     * @function fetchObject\r\n     * @signature\r\n     * @param  {can-connect.model} con The connection object to an api resource\r\n     * @param  {Number} id  The id number of the object to retrieve\r\n     * @return {Promise}     A promise that is resolved once the object is retreived\r\n     * @link https://connect.canjs.com/ can-connect\r\n     */\r\n    fetchObject (con, id) {\r\n        if (!con || !id) {\r\n            return null;\r\n        }\r\n        const def = con.get({\r\n            id: id\r\n        });\r\n        def.then((obj) => {\r\n            this.object = obj;\r\n        });\r\n\r\n        this.objectPromise = def;\r\n        return def;\r\n    }\r\n});\r\n\r\nassign(ViewModel.prototype, CanEvent);\r\nexport default ViewModel;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/property-table/ViewModel.js\n// module id = 115\n// module chunks = 0","import template from './property-table.stache';\r\nimport Component from 'can-component';\r\nimport ViewModel from './ViewModel';\r\n\r\nexport default Component.extend({\r\n    tag: 'property-table',\r\n    ViewModel: ViewModel,\r\n    view: template\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/property-table/property-table.js\n// module id = 116\n// module chunks = 0","import DefineMap from 'can-define/map/map';\r\nimport parseFieldArray from '../parseFieldArray/parseFieldArray';\r\nimport Field from '../Field';\r\nimport DefineList from 'can-define/list/list';\r\n\r\n/**\r\n * @constructor util/field/base/FieldIteratorMap FieldIteratorMap\r\n * @parent util/field.types\r\n * @group FieldIteratorMap.props\r\n * A base class for widgets that need to iterate through a set or subset\r\n * of fields.\r\n * ViewModels inheriting this map should define a excludeFieldKey which\r\n * is a field property that will exclude those fields from this class. For\r\n * instance, if we are designing an edit widget, an appropriate way to exclude\r\n * fields from the widget would be to use the key `edit: false` and set\r\n * `excludeFieldKey: 'edit'` in this class.\r\n */\r\nexport default DefineMap.extend({\r\n  /**\r\n   * A string referencing a field property that will exclude that field\r\n   * from this classes fields.\r\n   * @property {String} FieldIteratorMap.props.excludeFieldKey excludeFieldKey\r\n   * @parent FieldIteratorMap.props\r\n   */\r\n    excludeFieldKey: 'string',\r\n    /**\r\n     * A property that converts this class's object to an array of\r\n     * fields if fields are not provided.\r\n     * @property {DefineMap} FieldIteratorMap.props.object object\r\n     * @parent FieldIteratorMap.props\r\n     */\r\n    object: DefineMap,\r\n  /**\r\n   * An array of fields\r\n   * @property {Array<util/field/Field>} FieldIteratorMap.props.fields fields\r\n   * @parent FieldIteratorMap.props\r\n   */\r\n    fields: {\r\n        Value: DefineList,\r\n        Type: DefineList,\r\n        get (fields) {\r\n            if (fields.length && !(fields[0] instanceof Field)) {\r\n                fields = parseFieldArray(fields);\r\n            }\r\n            if (!fields.length && this.object) {\r\n                const obj = this.object.serialize ? this.object.serialize() : this.object;\r\n                return parseFieldArray(Object.keys(obj));\r\n            }\r\n            return fields.filter((f) => {\r\n                return f[this.excludeFieldKey] !== false;\r\n            });\r\n        }\r\n    }\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/util/field/base/FieldIteratorMap.js\n// module id = 117\n// module chunks = 0","import Field from '../Field';\r\n// eslint-disable-next-line\r\n/**\r\n * Converts an array of strings or field json objects into Field objects\r\n * @function util/field/parseFieldArray/parseFieldArray parseFieldArray\r\n * @parent util/field.methods\r\n * @signature `parseFieldArray(fields)`\r\n * @param  {Array<util/field/Field | String>} fields An array of either strings or JSON like objects representing Field object properties\r\n * @return {Array<util/field/Field>} The array of fields\r\n */\r\nexport default function parseFieldArray (fields) {\r\n    // create field objects\r\n    return fields.map((f) => {\r\n        // if we have a string give it a default name\r\n        if (typeof f === 'string') {\r\n            f = {\r\n                name: f\r\n            };\r\n        }\r\n        // add additional props with field constructor\r\n        return new Field(f);\r\n\r\n        // filter fields to exclude any '__' hidden props\r\n    }).filter((f) => {\r\n        return f.name.indexOf('__') === -1;\r\n    });\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/util/field/parseFieldArray/parseFieldArray.js\n// module id = 118\n// module chunks = 0","import string from 'can-util/js/string/string';\r\n\r\n/**\r\n * @module {{}} util/string string\r\n * @parent spectre.util\r\n * @description a collection of string utilities\r\n */\r\n\r\n/**\r\n * Formats the field by replacing underscores with spaces and capitalizing the first letter\r\n * @parent util/string\r\n * @function makeSentenceCase\r\n * @signature `makeSentenceCase(text)`\r\n * @param  {String} text The name of the field\r\n * @return {String} The formatted field string. Example: `my_field_name` will become `My field name`.\r\n */\r\nexport function makeSentenceCase (text) {\r\n    text = String(text);\r\n    return string.capitalize(String.prototype.trim.call(\r\n    text.split('_')\r\n    .join(' ')\r\n    .toLowerCase()\r\n    .replace(/ +/g, ' ')\r\n  ));\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spectre-canjs/util/string/string.js\n// module id = 119\n// module chunks = 0","// Provide a \"System\" global.\r\nmodule.exports = {\r\n\t// Make sure import is only used as \"System.import\"\r\n\timport: function() {\r\n\t\tthrow new Error(\"System.import cannot be used indirectly\");\r\n\t}\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/system.js\n// module id = 120\n// module chunks = 0","import 'spectre-canjs/property-table/property-table';\nimport stache from 'can-stache';\n\nvar render = require('./template.stache')\n\nvar viewModel = {\n    fields: [{\n        //fields can be specified using a detailed object\n        name: 'prop_1',\n        alias: 'Property 1',\n\n    },\n        //or a simple field name\n        'another_property_value', 'etc_or_misc'\n    ],\n    data: {\n        prop_1: 'This is a property',\n        another_property_value: 'Value here',\n        etc_or_misc: 'This is a value'\n    }\n};\n\ndocument.body.appendChild(render(viewModel));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ts/test.js\n// module id = 121\n// module chunks = 0","/* (ignored) */\n\n\n//////////////////\n// WEBPACK FOOTER\n// vertx (ignored)\n// module id = 122\n// module chunks = 0"],"sourceRoot":""}